package SQL::Translator::Parser::DB2::Grammar;
use Parse::RecDescent;

{ my $ERRORS;


package Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar;
use strict; use warnings;
use vars qw($skip $AUTOLOAD  );
$skip = '\s*';

    my ( %tables, $table_order, @table_comments, @views, @triggers );
;


{
local $SIG{__WARN__} = sub {0};
# PRETEND TO BE IN Parse::RecDescent NAMESPACE
*Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::AUTOLOAD  = sub
{
  no strict 'refs';
  $AUTOLOAD =~ s/^Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar/Parse::RecDescent/;
  goto &{$AUTOLOAD};
}
}

push @Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::ISA, 'Parse::RecDescent';
# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_17_of_rule_sysibm_function
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_17_of_rule_sysibm_function"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_17_of_rule_sysibm_function]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_17_of_rule_sysibm_function},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/DECIMAL/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_17_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_17_of_rule_sysibm_function});
    %item = (__RULE__ => q{_alternation_1_of_production_17_of_rule_sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/DECIMAL/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_17_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:DECIMAL)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/DECIMAL/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_17_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/DEC/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_17_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_17_of_rule_sysibm_function});
    %item = (__RULE__ => q{_alternation_1_of_production_17_of_rule_sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/DEC/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_17_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:DEC)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/DEC/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_17_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_17_of_rule_sysibm_function},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_17_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_17_of_rule_sysibm_function},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_17_of_rule_sysibm_function},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::triggered_action
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"triggered_action"};

  Parse::RecDescent::_trace(q{Trying rule: [triggered_action]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{triggered_action},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [when_clause SQL_procedure_statement]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{triggered_action},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{triggered_action});
    %item = (__RULE__ => q{triggered_action});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying repeated subrule: [when_clause]},
          Parse::RecDescent::_tracefirst($text),
          q{triggered_action},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{})->at($text);

    unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::when_clause, 0, 1, $_noactions,$expectation,undef)))
    {
      Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [when_clause]>>},
              Parse::RecDescent::_tracefirst($text),
              q{triggered_action},
              $tracelevel)
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched repeated subrule: [when_clause]<< (}
          . @$_tok . q{ times)},

            Parse::RecDescent::_tracefirst($text),
            q{triggered_action},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{when_clause(?)}} = $_tok;
    push @item, $_tok;



    Parse::RecDescent::_trace(q{Trying subrule: [SQL_procedure_statement]},
          Parse::RecDescent::_tracefirst($text),
          q{triggered_action},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{SQL_procedure_statement})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::SQL_procedure_statement($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [SQL_procedure_statement]>>},
              Parse::RecDescent::_tracefirst($text),
              q{triggered_action},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [SQL_procedure_statement]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{triggered_action},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{SQL_procedure_statement}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying action},
            Parse::RecDescent::_tracefirst($text),
            q{triggered_action},
            $tracelevel)
            if defined $::RD_TRACE;


    $_tok = ($_noactions) ? 0 : do { $return = { 'condition' => $item[1][0],
              'statement' => $item{'SQL_procedure_statement'} };
};
    unless (defined $_tok)
    {
      Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
          if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
            . $_tok . q{])},
            Parse::RecDescent::_tracefirst($text))
            if defined $::RD_TRACE;
    push @item, $_tok;
    $item{__ACTION1__}=$_tok;



    Parse::RecDescent::_trace(q{>>Matched production: [when_clause SQL_procedure_statement]<<},
            Parse::RecDescent::_tracefirst($text),
            q{triggered_action},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{triggered_action},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{triggered_action},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{triggered_action},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{triggered_action},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_2_of_rule_search_condition
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_2_of_rule_search_condition"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_2_of_rule_search_condition]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_2_of_rule_search_condition},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [predicate /SELECTIVITY/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_2_of_rule_search_condition},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_2_of_rule_search_condition});
    %item = (__RULE__ => q{_alternation_1_of_production_2_of_rule_search_condition});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [predicate]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_1_of_production_2_of_rule_search_condition},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::predicate($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [predicate]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_1_of_production_2_of_rule_search_condition},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [predicate]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_2_of_rule_search_condition},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{predicate}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying repeated subrule: [/SELECTIVITY/i]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_1_of_production_2_of_rule_search_condition},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{/SELECTIVITY/i})->at($text);

    unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule__alternation_1_of_production_2_of_rule_search_condition, 0, 1, $_noactions,$expectation,undef)))
    {
      Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [/SELECTIVITY/i]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_1_of_production_2_of_rule_search_condition},
              $tracelevel)
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched repeated subrule: [_alternation_1_of_production_1_of_rule__alternation_1_of_production_2_of_rule_search_condition]<< (}
          . @$_tok . q{ times)},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_2_of_rule_search_condition},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_2_of_rule_search_condition(?)}} = $_tok;
    push @item, $_tok;




    Parse::RecDescent::_trace(q{>>Matched production: [predicate /SELECTIVITY/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_2_of_rule_search_condition},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: ['(' search_condition ')']},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_2_of_rule_search_condition},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_2_of_rule_search_condition});
    %item = (__RULE__ => q{_alternation_1_of_production_2_of_rule_search_condition});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: ['(']},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_2_of_rule_search_condition},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\(//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [search_condition]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_1_of_production_2_of_rule_search_condition},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{search_condition})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::search_condition($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [search_condition]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_1_of_production_2_of_rule_search_condition},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [search_condition]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_2_of_rule_search_condition},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{search_condition}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: [')']},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_2_of_rule_search_condition},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{')'})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING2__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: ['(' search_condition ')']<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_2_of_rule_search_condition},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_2_of_rule_search_condition},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_2_of_rule_search_condition},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_2_of_rule_search_condition},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_2_of_rule_search_condition},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::name1
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"name1"};

  Parse::RecDescent::_trace(q{Trying rule: [name1]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{name1},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [NAME]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{name1},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{name1});
    %item = (__RULE__ => q{name1});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [NAME]},
          Parse::RecDescent::_tracefirst($text),
          q{name1},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::NAME($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [NAME]>>},
              Parse::RecDescent::_tracefirst($text),
              q{name1},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [NAME]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{name1},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{NAME}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [NAME]<<},
            Parse::RecDescent::_tracefirst($text),
            q{name1},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{name1},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{name1},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{name1},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{name1},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_2_of_production_1_of_rule_cond
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_2_of_production_1_of_rule_cond"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_2_of_production_1_of_rule_cond]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_2_of_production_1_of_rule_cond},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [predicate /SELECTIVITY/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_2_of_production_1_of_rule_cond},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_2_of_production_1_of_rule_cond});
    %item = (__RULE__ => q{_alternation_2_of_production_1_of_rule_cond});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [predicate]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_2_of_production_1_of_rule_cond},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::predicate($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [predicate]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_2_of_production_1_of_rule_cond},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [predicate]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule_cond},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{predicate}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying repeated subrule: [/SELECTIVITY/i]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_2_of_production_1_of_rule_cond},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{/SELECTIVITY/i})->at($text);

    unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cond, 0, 1, $_noactions,$expectation,undef)))
    {
      Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [/SELECTIVITY/i]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_2_of_production_1_of_rule_cond},
              $tracelevel)
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched repeated subrule: [_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cond]<< (}
          . @$_tok . q{ times)},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule_cond},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cond(?)}} = $_tok;
    push @item, $_tok;




    Parse::RecDescent::_trace(q{>>Matched production: [predicate /SELECTIVITY/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule_cond},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: ['(' search_condition ')']},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_2_of_production_1_of_rule_cond},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_2_of_production_1_of_rule_cond});
    %item = (__RULE__ => q{_alternation_2_of_production_1_of_rule_cond});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: ['(']},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule_cond},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\(//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [search_condition]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_2_of_production_1_of_rule_cond},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{search_condition})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::search_condition($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [search_condition]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_2_of_production_1_of_rule_cond},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [search_condition]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule_cond},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{search_condition}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: [')']},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule_cond},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{')'})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING2__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: ['(' search_condition ')']<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule_cond},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_2_of_production_1_of_rule_cond},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_2_of_production_1_of_rule_cond},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_2_of_production_1_of_rule_cond},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_2_of_production_1_of_rule_cond},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_expression
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule_expression"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule_expression]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_1_of_rule_expression},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: ['+', or '-' function, or '(', or constant, or column_name, or host_variable, or special_register, or labeled_duration, or case_expression, or cast_specification, or OLAP_function, or method_invocation, or subtype_treatment, or sequence_reference]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule_expression});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_expression});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying repeated subrule: ['+', or '-']},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_1_of_production_1_of_rule_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{})->at($text);

    unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression, 0, 1, $_noactions,$expectation,undef)))
    {
      Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: ['+', or '-']>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_1_of_production_1_of_rule_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched repeated subrule: [_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression]<< (}
          . @$_tok . q{ times)},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression(?)}} = $_tok;
    push @item, $_tok;



    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_1_of_production_1_of_rule_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{function, or '(', or constant, or column_name, or host_variable, or special_register, or labeled_duration, or case_expression, or cast_specification, or OLAP_function, or method_invocation, or subtype_treatment, or sequence_reference})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_1_of_production_1_of_rule_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: ['+', or '-' function, or '(', or constant, or column_name, or host_variable, or special_register, or labeled_duration, or case_expression, or cast_specification, or OLAP_function, or method_invocation, or subtype_treatment, or sequence_reference]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_1_of_rule_expression},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_1_of_rule_expression},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::SCHEMA
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"SCHEMA"};

  Parse::RecDescent::_trace(q{Trying rule: [SCHEMA]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{SCHEMA},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/\\w+/]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{SCHEMA},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{SCHEMA});
    %item = (__RULE__ => q{SCHEMA});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/\\w+/]}, Parse::RecDescent::_tracefirst($text),
            q{SCHEMA},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:\w+)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/\\w+/]<<},
            Parse::RecDescent::_tracefirst($text),
            q{SCHEMA},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/\\w\{1,128\}/]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{SCHEMA},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{SCHEMA});
    %item = (__RULE__ => q{SCHEMA});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/\\w\{1,128\}/]}, Parse::RecDescent::_tracefirst($text),
            q{SCHEMA},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:\w{1,128})//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/\\w\{1,128\}/]<<},
            Parse::RecDescent::_tracefirst($text),
            q{SCHEMA},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{SCHEMA},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{SCHEMA},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{SCHEMA},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{SCHEMA},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_87_of_rule_sysibm_function
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_87_of_rule_sysibm_function"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_87_of_rule_sysibm_function]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_87_of_rule_sysibm_function},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/VARIANCE/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_87_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_87_of_rule_sysibm_function});
    %item = (__RULE__ => q{_alternation_1_of_production_87_of_rule_sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/VARIANCE/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_87_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:VARIANCE)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/VARIANCE/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_87_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/VAR/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_87_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_87_of_rule_sysibm_function});
    %item = (__RULE__ => q{_alternation_1_of_production_87_of_rule_sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/VAR/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_87_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:VAR)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/VAR/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_87_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_87_of_rule_sysibm_function},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_87_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_87_of_rule_sysibm_function},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_87_of_rule_sysibm_function},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: ['+']},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: ['+']},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\+//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: ['+']<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: ['-']},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: ['-']},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\-//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: ['-']<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::get_bracketed
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"get_bracketed"};

  Parse::RecDescent::_trace(q{Trying rule: [get_bracketed]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{get_bracketed},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: []},
            Parse::RecDescent::_tracefirst($_[1]),
            q{get_bracketed},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{get_bracketed});
    %item = (__RULE__ => q{get_bracketed});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying action},
            Parse::RecDescent::_tracefirst($text),
            q{get_bracketed},
            $tracelevel)
            if defined $::RD_TRACE;


    $_tok = ($_noactions) ? 0 : do {
    extract_bracketed($text, '(');
};
    unless (defined $_tok)
    {
      Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
          if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
            . $_tok . q{])},
            Parse::RecDescent::_tracefirst($text))
            if defined $::RD_TRACE;
    push @item, $_tok;
    $item{__ACTION1__}=$_tok;



    Parse::RecDescent::_trace(q{>>Matched production: []<<},
            Parse::RecDescent::_tracefirst($text),
            q{get_bracketed},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{get_bracketed},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{get_bracketed},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{get_bracketed},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{get_bracketed},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::labeled_duration
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"labeled_duration"};

  Parse::RecDescent::_trace(q{Trying rule: [labeled_duration]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{labeled_duration},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [ld_type ld_duration]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{labeled_duration},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{labeled_duration});
    %item = (__RULE__ => q{labeled_duration});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [ld_type]},
          Parse::RecDescent::_tracefirst($text),
          q{labeled_duration},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::ld_type($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [ld_type]>>},
              Parse::RecDescent::_tracefirst($text),
              q{labeled_duration},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [ld_type]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{labeled_duration},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{ld_type}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying subrule: [ld_duration]},
          Parse::RecDescent::_tracefirst($text),
          q{labeled_duration},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{ld_duration})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::ld_duration($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [ld_duration]>>},
              Parse::RecDescent::_tracefirst($text),
              q{labeled_duration},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [ld_duration]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{labeled_duration},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{ld_duration}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [ld_type ld_duration]<<},
            Parse::RecDescent::_tracefirst($text),
            q{labeled_duration},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{labeled_duration},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{labeled_duration},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{labeled_duration},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{labeled_duration},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::group_end
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"group_end"};

  Parse::RecDescent::_trace(q{Trying rule: [group_end]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{group_end},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/UNBOUNDED\\s+PRECEDING/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{group_end},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{group_end});
    %item = (__RULE__ => q{group_end});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/UNBOUNDED\\s+PRECEDING/i]}, Parse::RecDescent::_tracefirst($text),
            q{group_end},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:UNBOUNDED\s+PRECEDING)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/UNBOUNDED\\s+PRECEDING/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{group_end},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [unsigned_constant /FOLLOWING/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{group_end},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{group_end});
    %item = (__RULE__ => q{group_end});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [unsigned_constant]},
          Parse::RecDescent::_tracefirst($text),
          q{group_end},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::unsigned_constant($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [unsigned_constant]>>},
              Parse::RecDescent::_tracefirst($text),
              q{group_end},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [unsigned_constant]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{group_end},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{unsigned_constant}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: [/FOLLOWING/i]}, Parse::RecDescent::_tracefirst($text),
            q{group_end},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/FOLLOWING/i})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:FOLLOWING)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [unsigned_constant /FOLLOWING/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{group_end},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{group_end},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{group_end},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{group_end},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{group_end},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::statement
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"statement"};

  Parse::RecDescent::_trace(q{Trying rule: [statement]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{statement},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [comment]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{statement},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{statement});
    %item = (__RULE__ => q{statement});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [comment]},
          Parse::RecDescent::_tracefirst($text),
          q{statement},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::comment($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [comment]>>},
              Parse::RecDescent::_tracefirst($text),
              q{statement},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [comment]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{statement},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{comment}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [comment]<<},
            Parse::RecDescent::_tracefirst($text),
            q{statement},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [create]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{statement},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{statement});
    %item = (__RULE__ => q{statement});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [create]},
          Parse::RecDescent::_tracefirst($text),
          q{statement},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::create($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [create]>>},
              Parse::RecDescent::_tracefirst($text),
              q{statement},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [create]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{statement},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{create}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [create]<<},
            Parse::RecDescent::_tracefirst($text),
            q{statement},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched)
  {

    Parse::RecDescent::_trace(q{Trying production: [<error...>]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{statement},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[2];

    my $_savetext;
    @item = (q{statement});
    %item = (__RULE__ => q{statement});
    my $repcount = 0;




    Parse::RecDescent::_trace(q{Trying directive: [<error...>]},
          Parse::RecDescent::_tracefirst($text),
            q{statement},
            $tracelevel)
            if defined $::RD_TRACE;
    $_tok = do { if (1) { do {
    my $rule = $item[0];
       $rule =~ s/_/ /g;
    #WAS: Parse::RecDescent::_error("Invalid $rule: " . $expectation->message() ,$thisline);
    push @{$thisparser->{errors}}, ["Invalid $rule: " . $expectation->message() ,$thisline];
    } unless  $_noactions; undef } else {0} };
    if (defined($_tok))
    {
      Parse::RecDescent::_trace(q{>>Matched directive<< (return value: [}
            . $_tok . q{])},
            Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    }
    else
    {
      Parse::RecDescent::_trace(q{<<Didn't match directive>>},
            Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    }

    last unless defined $_tok;
    push @item, $item{__DIRECTIVE1__}=$_tok;



    Parse::RecDescent::_trace(q{>>Matched production: [<error...>]<<},
            Parse::RecDescent::_tracefirst($text),
            q{statement},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{statement},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{statement},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{statement},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{statement},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_simple_when_clause
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_simple_when_clause"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_simple_when_clause]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_simple_when_clause},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [result_expression]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_simple_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_simple_when_clause});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_simple_when_clause});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [result_expression]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_simple_when_clause},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::result_expression($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [result_expression]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_simple_when_clause},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [result_expression]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_simple_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{result_expression}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [result_expression]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_simple_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/NULL/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_simple_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_simple_when_clause});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_simple_when_clause});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/NULL/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_simple_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:NULL)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/NULL/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_simple_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_simple_when_clause},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_simple_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_simple_when_clause},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_simple_when_clause},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_2_of_production_1_of_rule_case_expression
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_2_of_production_1_of_rule_case_expression"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_2_of_production_1_of_rule_case_expression]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_2_of_production_1_of_rule_case_expression},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/ELSE\\s+NULL/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_2_of_production_1_of_rule_case_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_2_of_production_1_of_rule_case_expression});
    %item = (__RULE__ => q{_alternation_2_of_production_1_of_rule_case_expression});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/ELSE\\s+NULL/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule_case_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:ELSE\s+NULL)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/ELSE\\s+NULL/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule_case_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/ELSE/i result_expression]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_2_of_production_1_of_rule_case_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_2_of_production_1_of_rule_case_expression});
    %item = (__RULE__ => q{_alternation_2_of_production_1_of_rule_case_expression});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/ELSE/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule_case_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:ELSE)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [result_expression]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_2_of_production_1_of_rule_case_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{result_expression})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::result_expression($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [result_expression]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_2_of_production_1_of_rule_case_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [result_expression]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule_case_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{result_expression}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [/ELSE/i result_expression]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule_case_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_2_of_production_1_of_rule_case_expression},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_2_of_production_1_of_rule_case_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_2_of_production_1_of_rule_case_expression},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_2_of_production_1_of_rule_case_expression},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::subject_expression
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"subject_expression"};

  Parse::RecDescent::_trace(q{Trying rule: [subject_expression]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{subject_expression},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [expression]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{subject_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{subject_expression});
    %item = (__RULE__ => q{subject_expression});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [expression]},
          Parse::RecDescent::_tracefirst($text),
          q{subject_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::expression($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [expression]>>},
              Parse::RecDescent::_tracefirst($text),
              q{subject_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [expression]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{subject_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{expression}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying action},
            Parse::RecDescent::_tracefirst($text),
            q{subject_expression},
            $tracelevel)
            if defined $::RD_TRACE;


    $_tok = ($_noactions) ? 0 : do { # with static result type that is a used-defined struct type
};
    unless (defined $_tok)
    {
      Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
          if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
            . $_tok . q{])},
            Parse::RecDescent::_tracefirst($text))
            if defined $::RD_TRACE;
    push @item, $_tok;
    $item{__ACTION1__}=$_tok;



    Parse::RecDescent::_trace(q{>>Matched production: [expression]<<},
            Parse::RecDescent::_tracefirst($text),
            q{subject_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{subject_expression},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{subject_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{subject_expression},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{subject_expression},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_desc_option
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule_desc_option"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule_desc_option]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_1_of_rule_desc_option},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/NULLS\\s+FIRST/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule_desc_option},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule_desc_option});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_desc_option});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/NULLS\\s+FIRST/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_desc_option},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:NULLS\s+FIRST)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/NULLS\\s+FIRST/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_desc_option},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/NULLS\\s+LAST/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule_desc_option},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule_desc_option});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_desc_option});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/NULLS\\s+LAST/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_desc_option},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:NULLS\s+LAST)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/NULLS\\s+LAST/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_desc_option},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_1_of_rule_desc_option},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_1_of_rule_desc_option},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_1_of_rule_desc_option},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_1_of_rule_desc_option},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::view_name
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"view_name"};

  Parse::RecDescent::_trace(q{Trying rule: [view_name]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{view_name},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [SCHEMA '.' NAME]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{view_name},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{view_name});
    %item = (__RULE__ => q{view_name});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [SCHEMA]},
          Parse::RecDescent::_tracefirst($text),
          q{view_name},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::SCHEMA($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [SCHEMA]>>},
              Parse::RecDescent::_tracefirst($text),
              q{view_name},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [SCHEMA]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{view_name},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{SCHEMA}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: ['.']},
            Parse::RecDescent::_tracefirst($text),
            q{view_name},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{'.'})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\.//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [NAME]},
          Parse::RecDescent::_tracefirst($text),
          q{view_name},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{NAME})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::NAME($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [NAME]>>},
              Parse::RecDescent::_tracefirst($text),
              q{view_name},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [NAME]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{view_name},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{NAME}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying action},
            Parse::RecDescent::_tracefirst($text),
            q{view_name},
            $tracelevel)
            if defined $::RD_TRACE;


    $_tok = ($_noactions) ? 0 : do { $return = { schema => $item[1], name => $item[3] } };
    unless (defined $_tok)
    {
      Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
          if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
            . $_tok . q{])},
            Parse::RecDescent::_tracefirst($text))
            if defined $::RD_TRACE;
    push @item, $_tok;
    $item{__ACTION1__}=$_tok;



    Parse::RecDescent::_trace(q{>>Matched production: [SCHEMA '.' NAME]<<},
            Parse::RecDescent::_tracefirst($text),
            q{view_name},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [NAME]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{view_name},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{view_name});
    %item = (__RULE__ => q{view_name});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [NAME]},
          Parse::RecDescent::_tracefirst($text),
          q{view_name},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::NAME($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [NAME]>>},
              Parse::RecDescent::_tracefirst($text),
              q{view_name},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [NAME]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{view_name},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{NAME}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying action},
            Parse::RecDescent::_tracefirst($text),
            q{view_name},
            $tracelevel)
            if defined $::RD_TRACE;


    $_tok = ($_noactions) ? 0 : do { $return = { name => $item[1] } };
    unless (defined $_tok)
    {
      Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
          if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
            . $_tok . q{])},
            Parse::RecDescent::_tracefirst($text))
            if defined $::RD_TRACE;
    push @item, $_tok;
    $item{__ACTION1__}=$_tok;



    Parse::RecDescent::_trace(q{>>Matched production: [NAME]<<},
            Parse::RecDescent::_tracefirst($text),
            q{view_name},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{view_name},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{view_name},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{view_name},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{view_name},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_cond
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule_cond"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule_cond]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_1_of_rule_cond},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/AND/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule_cond},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule_cond});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_cond});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/AND/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_cond},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:AND)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/AND/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_cond},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/OR/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule_cond},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule_cond});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_cond});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/OR/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_cond},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:OR)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/OR/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_cond},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_1_of_rule_cond},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_1_of_rule_cond},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_1_of_rule_cond},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_1_of_rule_cond},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::numbering_function
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"numbering_function"};

  Parse::RecDescent::_trace(q{Trying rule: [numbering_function]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{numbering_function},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/ROW_NUMBER|ROWNUMBER/i '()' /OVER/i '(' window_partition_clause window_order_clause /RANGE\\s+BETWEEN\\s+UNBOUNDED\\s+PRECEDING\\s+AND\\s+UNBBOUNDED\\s+FOLLOWING/i, or window_aggregation_group_clause ')']},
            Parse::RecDescent::_tracefirst($_[1]),
            q{numbering_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{numbering_function});
    %item = (__RULE__ => q{numbering_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/ROW_NUMBER|ROWNUMBER/i]}, Parse::RecDescent::_tracefirst($text),
            q{numbering_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:ROW_NUMBER|ROWNUMBER)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying terminal: ['()']},
            Parse::RecDescent::_tracefirst($text),
            q{numbering_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{'()'})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\(\)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;


    Parse::RecDescent::_trace(q{Trying terminal: [/OVER/i]}, Parse::RecDescent::_tracefirst($text),
            q{numbering_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/OVER/i})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:OVER)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN2__}=$&;


    Parse::RecDescent::_trace(q{Trying terminal: ['(']},
            Parse::RecDescent::_tracefirst($text),
            q{numbering_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{'('})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\(//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING2__}=$&;


    Parse::RecDescent::_trace(q{Trying repeated subrule: [window_partition_clause]},
          Parse::RecDescent::_tracefirst($text),
          q{numbering_function},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{window_partition_clause})->at($text);

    unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::window_partition_clause, 0, 1, $_noactions,$expectation,undef)))
    {
      Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [window_partition_clause]>>},
              Parse::RecDescent::_tracefirst($text),
              q{numbering_function},
              $tracelevel)
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched repeated subrule: [window_partition_clause]<< (}
          . @$_tok . q{ times)},

            Parse::RecDescent::_tracefirst($text),
            q{numbering_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{window_partition_clause(?)}} = $_tok;
    push @item, $_tok;



    Parse::RecDescent::_trace(q{Trying repeated subrule: [window_order_clause]},
          Parse::RecDescent::_tracefirst($text),
          q{numbering_function},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{window_order_clause})->at($text);

    unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_numbering_function, 0, 1, $_noactions,$expectation,undef)))
    {
      Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [window_order_clause]>>},
              Parse::RecDescent::_tracefirst($text),
              q{numbering_function},
              $tracelevel)
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched repeated subrule: [_alternation_1_of_production_1_of_rule_numbering_function]<< (}
          . @$_tok . q{ times)},

            Parse::RecDescent::_tracefirst($text),
            q{numbering_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_1_of_rule_numbering_function(?)}} = $_tok;
    push @item, $_tok;



    Parse::RecDescent::_trace(q{Trying repeated subrule: [/RANGE\\s+BETWEEN\\s+UNBOUNDED\\s+PRECEDING\\s+AND\\s+UNBBOUNDED\\s+FOLLOWING/i, or window_aggregation_group_clause]},
          Parse::RecDescent::_tracefirst($text),
          q{numbering_function},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{/RANGE\\s+BETWEEN\\s+UNBOUNDED\\s+PRECEDING\\s+AND\\s+UNBBOUNDED\\s+FOLLOWING/i, or window_aggregation_group_clause})->at($text);

    unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_2_of_production_1_of_rule_numbering_function, 0, 1, $_noactions,$expectation,undef)))
    {
      Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [/RANGE\\s+BETWEEN\\s+UNBOUNDED\\s+PRECEDING\\s+AND\\s+UNBBOUNDED\\s+FOLLOWING/i, or window_aggregation_group_clause]>>},
              Parse::RecDescent::_tracefirst($text),
              q{numbering_function},
              $tracelevel)
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched repeated subrule: [_alternation_2_of_production_1_of_rule_numbering_function]<< (}
          . @$_tok . q{ times)},

            Parse::RecDescent::_tracefirst($text),
            q{numbering_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_2_of_production_1_of_rule_numbering_function(?)}} = $_tok;
    push @item, $_tok;



    Parse::RecDescent::_trace(q{Trying terminal: [')']},
            Parse::RecDescent::_tracefirst($text),
            q{numbering_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{')'})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING3__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/ROW_NUMBER|ROWNUMBER/i '()' /OVER/i '(' window_partition_clause window_order_clause /RANGE\\s+BETWEEN\\s+UNBOUNDED\\s+PRECEDING\\s+AND\\s+UNBBOUNDED\\s+FOLLOWING/i, or window_aggregation_group_clause ')']<<},
            Parse::RecDescent::_tracefirst($text),
            q{numbering_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{numbering_function},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{numbering_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{numbering_function},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{numbering_function},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_window_aggregation_group_clause
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule_window_aggregation_group_clause"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule_window_aggregation_group_clause]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_1_of_rule_window_aggregation_group_clause},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/ROWS/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule_window_aggregation_group_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule_window_aggregation_group_clause});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_window_aggregation_group_clause});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/ROWS/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_window_aggregation_group_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:ROWS)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/ROWS/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_window_aggregation_group_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/RANGE/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule_window_aggregation_group_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule_window_aggregation_group_clause});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_window_aggregation_group_clause});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/RANGE/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_window_aggregation_group_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:RANGE)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/RANGE/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_window_aggregation_group_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_1_of_rule_window_aggregation_group_clause},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_1_of_rule_window_aggregation_group_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_1_of_rule_window_aggregation_group_clause},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_1_of_rule_window_aggregation_group_clause},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::group_bound1
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"group_bound1"};

  Parse::RecDescent::_trace(q{Trying rule: [group_bound1]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{group_bound1},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/UNBOUNDED\\s+PRECEDING/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{group_bound1},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{group_bound1});
    %item = (__RULE__ => q{group_bound1});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/UNBOUNDED\\s+PRECEDING/i]}, Parse::RecDescent::_tracefirst($text),
            q{group_bound1},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:UNBOUNDED\s+PRECEDING)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/UNBOUNDED\\s+PRECEDING/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{group_bound1},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [unsigned_constant /PRECEDING/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{group_bound1},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{group_bound1});
    %item = (__RULE__ => q{group_bound1});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [unsigned_constant]},
          Parse::RecDescent::_tracefirst($text),
          q{group_bound1},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::unsigned_constant($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [unsigned_constant]>>},
              Parse::RecDescent::_tracefirst($text),
              q{group_bound1},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [unsigned_constant]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{group_bound1},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{unsigned_constant}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: [/PRECEDING/i]}, Parse::RecDescent::_tracefirst($text),
            q{group_bound1},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/PRECEDING/i})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:PRECEDING)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [unsigned_constant /PRECEDING/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{group_bound1},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [unsigned_constant /FOLLOWING/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{group_bound1},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[2];
    $text = $_[1];
    my $_savetext;
    @item = (q{group_bound1});
    %item = (__RULE__ => q{group_bound1});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [unsigned_constant]},
          Parse::RecDescent::_tracefirst($text),
          q{group_bound1},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::unsigned_constant($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [unsigned_constant]>>},
              Parse::RecDescent::_tracefirst($text),
              q{group_bound1},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [unsigned_constant]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{group_bound1},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{unsigned_constant}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: [/FOLLOWING/i]}, Parse::RecDescent::_tracefirst($text),
            q{group_bound1},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/FOLLOWING/i})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:FOLLOWING)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [unsigned_constant /FOLLOWING/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{group_bound1},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/CURRENT\\s+ROW/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{group_bound1},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[3];
    $text = $_[1];
    my $_savetext;
    @item = (q{group_bound1});
    %item = (__RULE__ => q{group_bound1});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/CURRENT\\s+ROW/i]}, Parse::RecDescent::_tracefirst($text),
            q{group_bound1},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:CURRENT\s+ROW)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/CURRENT\\s+ROW/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{group_bound1},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{group_bound1},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{group_bound1},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{group_bound1},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{group_bound1},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::OLAP_function
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"OLAP_function"};

  Parse::RecDescent::_trace(q{Trying rule: [OLAP_function]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{OLAP_function},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [ranking_function]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{OLAP_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{OLAP_function});
    %item = (__RULE__ => q{OLAP_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [ranking_function]},
          Parse::RecDescent::_tracefirst($text),
          q{OLAP_function},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::ranking_function($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [ranking_function]>>},
              Parse::RecDescent::_tracefirst($text),
              q{OLAP_function},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [ranking_function]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{OLAP_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{ranking_function}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [ranking_function]<<},
            Parse::RecDescent::_tracefirst($text),
            q{OLAP_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [numbering_function]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{OLAP_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{OLAP_function});
    %item = (__RULE__ => q{OLAP_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [numbering_function]},
          Parse::RecDescent::_tracefirst($text),
          q{OLAP_function},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::numbering_function($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [numbering_function]>>},
              Parse::RecDescent::_tracefirst($text),
              q{OLAP_function},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [numbering_function]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{OLAP_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{numbering_function}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [numbering_function]<<},
            Parse::RecDescent::_tracefirst($text),
            q{OLAP_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [aggregation_function]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{OLAP_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[2];
    $text = $_[1];
    my $_savetext;
    @item = (q{OLAP_function});
    %item = (__RULE__ => q{OLAP_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [aggregation_function]},
          Parse::RecDescent::_tracefirst($text),
          q{OLAP_function},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::aggregation_function($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [aggregation_function]>>},
              Parse::RecDescent::_tracefirst($text),
              q{OLAP_function},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [aggregation_function]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{OLAP_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{aggregation_function}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [aggregation_function]<<},
            Parse::RecDescent::_tracefirst($text),
            q{OLAP_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{OLAP_function},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{OLAP_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{OLAP_function},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{OLAP_function},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_30_of_rule_sysibm_function
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_30_of_rule_sysibm_function"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_30_of_rule_sysibm_function]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_30_of_rule_sysibm_function},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/DOUBLE/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_30_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_30_of_rule_sysibm_function});
    %item = (__RULE__ => q{_alternation_1_of_production_30_of_rule_sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/DOUBLE/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_30_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:DOUBLE)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/DOUBLE/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_30_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/DOUBLE_PRECISION/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_30_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_30_of_rule_sysibm_function});
    %item = (__RULE__ => q{_alternation_1_of_production_30_of_rule_sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/DOUBLE_PRECISION/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_30_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:DOUBLE_PRECISION)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/DOUBLE_PRECISION/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_30_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_30_of_rule_sysibm_function},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_30_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_30_of_rule_sysibm_function},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_30_of_rule_sysibm_function},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::FULL
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"FULL"};

  Parse::RecDescent::_trace(q{Trying rule: [FULL]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{FULL},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/full/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{FULL},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{FULL});
    %item = (__RULE__ => q{FULL});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/full/i]}, Parse::RecDescent::_tracefirst($text),
            q{FULL},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:full)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/full/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{FULL},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{FULL},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{FULL},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{FULL},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{FULL},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_2_of_production_1_of_rule_cast_specification
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_2_of_production_1_of_rule_cast_specification"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_2_of_production_1_of_rule_cast_specification]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_2_of_production_1_of_rule_cast_specification},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/SCOPE/ typed_table_name, or typed_view_name]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_2_of_production_1_of_rule_cast_specification},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_2_of_production_1_of_rule_cast_specification});
    %item = (__RULE__ => q{_alternation_2_of_production_1_of_rule_cast_specification});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/SCOPE/]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule_cast_specification},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:SCOPE)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cast_specification]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_2_of_production_1_of_rule_cast_specification},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{typed_table_name, or typed_view_name})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cast_specification($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cast_specification]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_2_of_production_1_of_rule_cast_specification},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cast_specification]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule_cast_specification},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cast_specification}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [/SCOPE/ typed_table_name, or typed_view_name]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule_cast_specification},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_2_of_production_1_of_rule_cast_specification},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_2_of_production_1_of_rule_cast_specification},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_2_of_production_1_of_rule_cast_specification},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_2_of_production_1_of_rule_cast_specification},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::case_expression
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"case_expression"};

  Parse::RecDescent::_trace(q{Trying rule: [case_expression]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{case_expression},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/CASE/i searched_when_clause, or simple_when_clause /ELSE\\s+NULL/i, or /ELSE/i /END/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{case_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{case_expression});
    %item = (__RULE__ => q{case_expression});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/CASE/i]}, Parse::RecDescent::_tracefirst($text),
            q{case_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:CASE)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_1_of_rule_case_expression]},
          Parse::RecDescent::_tracefirst($text),
          q{case_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{searched_when_clause, or simple_when_clause})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_case_expression($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_1_of_rule_case_expression]>>},
              Parse::RecDescent::_tracefirst($text),
              q{case_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_1_of_rule_case_expression]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{case_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_1_of_rule_case_expression}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying repeated subrule: [/ELSE\\s+NULL/i, or /ELSE/i]},
          Parse::RecDescent::_tracefirst($text),
          q{case_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{/ELSE\\s+NULL/i, or /ELSE/i})->at($text);

    unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_2_of_production_1_of_rule_case_expression, 0, 1, $_noactions,$expectation,undef)))
    {
      Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [/ELSE\\s+NULL/i, or /ELSE/i]>>},
              Parse::RecDescent::_tracefirst($text),
              q{case_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched repeated subrule: [_alternation_2_of_production_1_of_rule_case_expression]<< (}
          . @$_tok . q{ times)},

            Parse::RecDescent::_tracefirst($text),
            q{case_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_2_of_production_1_of_rule_case_expression(?)}} = $_tok;
    push @item, $_tok;



    Parse::RecDescent::_trace(q{Trying terminal: [/END/i]}, Parse::RecDescent::_tracefirst($text),
            q{case_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/END/i})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:END)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN2__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/CASE/i searched_when_clause, or simple_when_clause /ELSE\\s+NULL/i, or /ELSE/i /END/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{case_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{case_expression},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{case_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{case_expression},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{case_expression},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::operator
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"operator"};

  Parse::RecDescent::_trace(q{Trying rule: [operator]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{operator},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/CONCAT/i, or '||']},
            Parse::RecDescent::_tracefirst($_[1]),
            q{operator},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{operator});
    %item = (__RULE__ => q{operator});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_1_of_rule_operator]},
          Parse::RecDescent::_tracefirst($text),
          q{operator},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_operator($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_1_of_rule_operator]>>},
              Parse::RecDescent::_tracefirst($text),
              q{operator},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_1_of_rule_operator]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{operator},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_1_of_rule_operator}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [/CONCAT/i, or '||']<<},
            Parse::RecDescent::_tracefirst($text),
            q{operator},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: ['/']},
            Parse::RecDescent::_tracefirst($_[1]),
            q{operator},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{operator});
    %item = (__RULE__ => q{operator});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: ['/']},
            Parse::RecDescent::_tracefirst($text),
            q{operator},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\///)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: ['/']<<},
            Parse::RecDescent::_tracefirst($text),
            q{operator},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: ['*']},
            Parse::RecDescent::_tracefirst($_[1]),
            q{operator},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[2];
    $text = $_[1];
    my $_savetext;
    @item = (q{operator});
    %item = (__RULE__ => q{operator});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: ['*']},
            Parse::RecDescent::_tracefirst($text),
            q{operator},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\*//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: ['*']<<},
            Parse::RecDescent::_tracefirst($text),
            q{operator},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: ['+']},
            Parse::RecDescent::_tracefirst($_[1]),
            q{operator},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[3];
    $text = $_[1];
    my $_savetext;
    @item = (q{operator});
    %item = (__RULE__ => q{operator});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: ['+']},
            Parse::RecDescent::_tracefirst($text),
            q{operator},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\+//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: ['+']<<},
            Parse::RecDescent::_tracefirst($text),
            q{operator},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: ['-']},
            Parse::RecDescent::_tracefirst($_[1]),
            q{operator},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[4];
    $text = $_[1];
    my $_savetext;
    @item = (q{operator});
    %item = (__RULE__ => q{operator});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: ['-']},
            Parse::RecDescent::_tracefirst($text),
            q{operator},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\-//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: ['-']<<},
            Parse::RecDescent::_tracefirst($text),
            q{operator},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{operator},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{operator},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{operator},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{operator},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_2_of_rule_type
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_2_of_rule_type"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_2_of_rule_type]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_2_of_rule_type},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/INSERT/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_2_of_rule_type},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_2_of_rule_type});
    %item = (__RULE__ => q{_alternation_1_of_production_2_of_rule_type});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/INSERT/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_2_of_rule_type},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:INSERT)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/INSERT/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_2_of_rule_type},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/DELETE/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_2_of_rule_type},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_2_of_rule_type});
    %item = (__RULE__ => q{_alternation_1_of_production_2_of_rule_type});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/DELETE/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_2_of_rule_type},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:DELETE)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/DELETE/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_2_of_rule_type},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/UPDATE/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_2_of_rule_type},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[2];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_2_of_rule_type});
    %item = (__RULE__ => q{_alternation_1_of_production_2_of_rule_type});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/UPDATE/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_2_of_rule_type},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:UPDATE)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/UPDATE/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_2_of_rule_type},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_2_of_rule_type},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_2_of_rule_type},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_2_of_rule_type},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_2_of_rule_type},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_8_of_rule_sysibm_function
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_8_of_rule_sysibm_function"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_8_of_rule_sysibm_function]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_8_of_rule_sysibm_function},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/CONCAT/]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_8_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_8_of_rule_sysibm_function});
    %item = (__RULE__ => q{_alternation_1_of_production_8_of_rule_sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/CONCAT/]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_8_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:CONCAT)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/CONCAT/]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_8_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: ['||']},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_8_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_8_of_rule_sysibm_function});
    %item = (__RULE__ => q{_alternation_1_of_production_8_of_rule_sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: ['||']},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_8_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\|\|//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: ['||']<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_8_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_8_of_rule_sysibm_function},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_8_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_8_of_rule_sysibm_function},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_8_of_rule_sysibm_function},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::sequence_reference
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"sequence_reference"};

  Parse::RecDescent::_trace(q{Trying rule: [sequence_reference]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{sequence_reference},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [nextval_expression]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sequence_reference},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{sequence_reference});
    %item = (__RULE__ => q{sequence_reference});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [nextval_expression]},
          Parse::RecDescent::_tracefirst($text),
          q{sequence_reference},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::nextval_expression($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [nextval_expression]>>},
              Parse::RecDescent::_tracefirst($text),
              q{sequence_reference},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [nextval_expression]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{sequence_reference},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{nextval_expression}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [nextval_expression]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sequence_reference},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [prevval_expression]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sequence_reference},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{sequence_reference});
    %item = (__RULE__ => q{sequence_reference});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [prevval_expression]},
          Parse::RecDescent::_tracefirst($text),
          q{sequence_reference},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::prevval_expression($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [prevval_expression]>>},
              Parse::RecDescent::_tracefirst($text),
              q{sequence_reference},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [prevval_expression]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{sequence_reference},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{prevval_expression}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [prevval_expression]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sequence_reference},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{sequence_reference},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{sequence_reference},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{sequence_reference},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{sequence_reference},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::sysibm_function
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"sysibm_function"};

  Parse::RecDescent::_trace(q{Trying rule: [sysibm_function]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{sysibm_function},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/ABS/i, or /ABSVAL/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_1_of_rule_sysibm_function]},
          Parse::RecDescent::_tracefirst($text),
          q{sysibm_function},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_sysibm_function($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_1_of_rule_sysibm_function]>>},
              Parse::RecDescent::_tracefirst($text),
              q{sysibm_function},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_1_of_rule_sysibm_function]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_1_of_rule_sysibm_function}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [/ABS/i, or /ABSVAL/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/AVG/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/AVG/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:AVG)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/AVG/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/BIGINT/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[2];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/BIGINT/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:BIGINT)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/BIGINT/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/BLOB/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[3];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/BLOB/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:BLOB)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/BLOB/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/CHAR/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[4];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/CHAR/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:CHAR)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/CHAR/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/CLOB/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[5];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/CLOB/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:CLOB)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/CLOB/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/COALESCE/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[6];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/COALESCE/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:COALESCE)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/COALESCE/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/CONCAT/, or '||']},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[7];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_8_of_rule_sysibm_function]},
          Parse::RecDescent::_tracefirst($text),
          q{sysibm_function},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_8_of_rule_sysibm_function($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_8_of_rule_sysibm_function]>>},
              Parse::RecDescent::_tracefirst($text),
              q{sysibm_function},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_8_of_rule_sysibm_function]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_8_of_rule_sysibm_function}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [/CONCAT/, or '||']<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/CORRELATION/i, or /CORR/]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[8];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_9_of_rule_sysibm_function]},
          Parse::RecDescent::_tracefirst($text),
          q{sysibm_function},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_9_of_rule_sysibm_function($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_9_of_rule_sysibm_function]>>},
              Parse::RecDescent::_tracefirst($text),
              q{sysibm_function},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_9_of_rule_sysibm_function]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_9_of_rule_sysibm_function}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [/CORRELATION/i, or /CORR/]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/COUNT/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[9];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/COUNT/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:COUNT)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/COUNT/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/COUNT_BIG/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[10];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/COUNT_BIG/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:COUNT_BIG)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/COUNT_BIG/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/COVARIANCE/i, or /COVAR/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[11];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_12_of_rule_sysibm_function]},
          Parse::RecDescent::_tracefirst($text),
          q{sysibm_function},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_12_of_rule_sysibm_function($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_12_of_rule_sysibm_function]>>},
              Parse::RecDescent::_tracefirst($text),
              q{sysibm_function},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_12_of_rule_sysibm_function]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_12_of_rule_sysibm_function}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [/COVARIANCE/i, or /COVAR/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/DATE/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[12];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/DATE/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:DATE)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/DATE/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/DAY/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[13];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/DAY/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:DAY)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/DAY/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/DAYS/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[14];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/DAYS/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:DAYS)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/DAYS/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/DBCLOB/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[15];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/DBCLOB/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:DBCLOB)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/DBCLOB/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/DECIMAL/i, or /DEC/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[16];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_17_of_rule_sysibm_function]},
          Parse::RecDescent::_tracefirst($text),
          q{sysibm_function},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_17_of_rule_sysibm_function($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_17_of_rule_sysibm_function]>>},
              Parse::RecDescent::_tracefirst($text),
              q{sysibm_function},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_17_of_rule_sysibm_function]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_17_of_rule_sysibm_function}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [/DECIMAL/i, or /DEC/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/DECRYPT_BIN/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[17];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/DECRYPT_BIN/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:DECRYPT_BIN)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/DECRYPT_BIN/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/DECRYPT_CHAR/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[18];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/DECRYPT_CHAR/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:DECRYPT_CHAR)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/DECRYPT_CHAR/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/DEREF/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[19];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/DEREF/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:DEREF)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/DEREF/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/DIGITS/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[20];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/DIGITS/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:DIGITS)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/DIGITS/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/DLCOMMENT/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[21];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/DLCOMMENT/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:DLCOMMENT)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/DLCOMMENT/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/DLLINKTYPE/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[22];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/DLLINKTYPE/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:DLLINKTYPE)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/DLLINKTYPE/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/DLURLCOMPLETE/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[23];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/DLURLCOMPLETE/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:DLURLCOMPLETE)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/DLURLCOMPLETE/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/DLURLPATH/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[24];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/DLURLPATH/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:DLURLPATH)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/DLURLPATH/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/DLURLPATHONLY/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[25];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/DLURLPATHONLY/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:DLURLPATHONLY)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/DLURLPATHONLY/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/DLURLSCHEME/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[26];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/DLURLSCHEME/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:DLURLSCHEME)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/DLURLSCHEME/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/DLURLSERVER/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[27];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/DLURLSERVER/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:DLURLSERVER)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/DLURLSERVER/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/DLVALUE/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[28];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/DLVALUE/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:DLVALUE)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/DLVALUE/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/DOUBLE/i, or /DOUBLE_PRECISION/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[29];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_30_of_rule_sysibm_function]},
          Parse::RecDescent::_tracefirst($text),
          q{sysibm_function},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_30_of_rule_sysibm_function($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_30_of_rule_sysibm_function]>>},
              Parse::RecDescent::_tracefirst($text),
              q{sysibm_function},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_30_of_rule_sysibm_function]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_30_of_rule_sysibm_function}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [/DOUBLE/i, or /DOUBLE_PRECISION/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/ENCRYPT/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[30];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/ENCRYPT/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:ENCRYPT)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/ENCRYPT/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/EVENT_MON_STATE/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[31];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/EVENT_MON_STATE/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:EVENT_MON_STATE)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/EVENT_MON_STATE/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/FLOAT/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[32];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/FLOAT/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:FLOAT)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/FLOAT/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/GETHINT/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[33];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/GETHINT/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:GETHINT)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/GETHINT/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/GENERATE_UNIQUE/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[34];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/GENERATE_UNIQUE/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:GENERATE_UNIQUE)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/GENERATE_UNIQUE/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/GRAPHIC/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[35];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/GRAPHIC/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:GRAPHIC)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/GRAPHIC/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/GROUPING/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[36];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/GROUPING/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:GROUPING)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/GROUPING/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/HEX/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[37];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/HEX/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:HEX)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/HEX/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/HOUR/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[38];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/HOUR/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:HOUR)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/HOUR/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/IDENTITY_VAL_LOCAL/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[39];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/IDENTITY_VAL_LOCAL/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:IDENTITY_VAL_LOCAL)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/IDENTITY_VAL_LOCAL/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/INTEGER/i, or /INT/]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[40];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_41_of_rule_sysibm_function]},
          Parse::RecDescent::_tracefirst($text),
          q{sysibm_function},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_41_of_rule_sysibm_function($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_41_of_rule_sysibm_function]>>},
              Parse::RecDescent::_tracefirst($text),
              q{sysibm_function},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_41_of_rule_sysibm_function]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_41_of_rule_sysibm_function}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [/INTEGER/i, or /INT/]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/LCASE/i, or /LOWER/]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[41];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_42_of_rule_sysibm_function]},
          Parse::RecDescent::_tracefirst($text),
          q{sysibm_function},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_42_of_rule_sysibm_function($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_42_of_rule_sysibm_function]>>},
              Parse::RecDescent::_tracefirst($text),
              q{sysibm_function},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_42_of_rule_sysibm_function]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_42_of_rule_sysibm_function}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [/LCASE/i, or /LOWER/]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/LENGTH/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[42];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/LENGTH/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:LENGTH)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/LENGTH/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/LONG_VARCHAR/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[43];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/LONG_VARCHAR/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:LONG_VARCHAR)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/LONG_VARCHAR/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/LONG_VARGRAPHIC/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[44];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/LONG_VARGRAPHIC/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:LONG_VARGRAPHIC)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/LONG_VARGRAPHIC/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/LTRIM/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[45];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/LTRIM/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:LTRIM)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/LTRIM/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/MAX/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[46];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/MAX/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:MAX)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/MAX/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/MICROSECOND/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[47];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/MICROSECOND/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:MICROSECOND)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/MICROSECOND/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/MIN/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[48];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/MIN/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:MIN)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/MIN/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/MINUTE/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[49];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/MINUTE/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:MINUTE)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/MINUTE/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/MONTH/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[50];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/MONTH/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:MONTH)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/MONTH/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/MULTIPLY_ACT/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[51];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/MULTIPLY_ACT/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:MULTIPLY_ACT)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/MULTIPLY_ACT/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/NODENUMBER/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[52];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/NODENUMBER/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:NODENUMBER)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/NODENUMBER/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/NULLIF/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[53];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/NULLIF/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:NULLIF)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/NULLIF/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/PARTITON/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[54];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/PARTITON/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:PARTITON)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/PARTITON/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/POSSTR/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[55];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/POSSTR/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:POSSTR)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/POSSTR/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/RAISE_ERROR/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[56];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/RAISE_ERROR/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:RAISE_ERROR)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/RAISE_ERROR/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/REAL/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[57];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/REAL/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:REAL)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/REAL/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/REC2XML/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[58];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/REC2XML/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:REC2XML)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/REC2XML/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/REGR_AVGX/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[59];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/REGR_AVGX/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:REGR_AVGX)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/REGR_AVGX/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/REGR_AVGY/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[60];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/REGR_AVGY/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:REGR_AVGY)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/REGR_AVGY/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/REGR_COUNT/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[61];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/REGR_COUNT/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:REGR_COUNT)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/REGR_COUNT/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/REGR_INTERCEPT/i, or /REGR_ICPT/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[62];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_63_of_rule_sysibm_function]},
          Parse::RecDescent::_tracefirst($text),
          q{sysibm_function},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_63_of_rule_sysibm_function($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_63_of_rule_sysibm_function]>>},
              Parse::RecDescent::_tracefirst($text),
              q{sysibm_function},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_63_of_rule_sysibm_function]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_63_of_rule_sysibm_function}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [/REGR_INTERCEPT/i, or /REGR_ICPT/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/REGR_R2/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[63];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/REGR_R2/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:REGR_R2)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/REGR_R2/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/REGR_SLOPE/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[64];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/REGR_SLOPE/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:REGR_SLOPE)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/REGR_SLOPE/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/REGR_SXX/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[65];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/REGR_SXX/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:REGR_SXX)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/REGR_SXX/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/REGR_SXY/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[66];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/REGR_SXY/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:REGR_SXY)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/REGR_SXY/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/REGR_SYY/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[67];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/REGR_SYY/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:REGR_SYY)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/REGR_SYY/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/RTRIM/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[68];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/RTRIM/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:RTRIM)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/RTRIM/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/SECOND/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[69];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/SECOND/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:SECOND)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/SECOND/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/SMALLINT/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[70];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/SMALLINT/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:SMALLINT)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/SMALLINT/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/STDDEV/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[71];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/STDDEV/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:STDDEV)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/STDDEV/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/SUBSTR/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[72];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/SUBSTR/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:SUBSTR)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/SUBSTR/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/SUM/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[73];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/SUM/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:SUM)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/SUM/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/TABLE_NAME/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[74];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/TABLE_NAME/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:TABLE_NAME)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/TABLE_NAME/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/TABLE_SCHEMA/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[75];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/TABLE_SCHEMA/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:TABLE_SCHEMA)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/TABLE_SCHEMA/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/TIME/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[76];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/TIME/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:TIME)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/TIME/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/TIMESTAMP/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[77];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/TIMESTAMP/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:TIMESTAMP)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/TIMESTAMP/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/TRANSLATE/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[78];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/TRANSLATE/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:TRANSLATE)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/TRANSLATE/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/TYPE_ID/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[79];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/TYPE_ID/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:TYPE_ID)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/TYPE_ID/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/TYPE_NAME/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[80];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/TYPE_NAME/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:TYPE_NAME)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/TYPE_NAME/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/TYPE_SCHEMA/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[81];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/TYPE_SCHEMA/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:TYPE_SCHEMA)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/TYPE_SCHEMA/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/UCASE/i, or /UPPER/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[82];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_83_of_rule_sysibm_function]},
          Parse::RecDescent::_tracefirst($text),
          q{sysibm_function},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_83_of_rule_sysibm_function($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_83_of_rule_sysibm_function]>>},
              Parse::RecDescent::_tracefirst($text),
              q{sysibm_function},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_83_of_rule_sysibm_function]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_83_of_rule_sysibm_function}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [/UCASE/i, or /UPPER/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/VALUE/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[83];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/VALUE/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:VALUE)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/VALUE/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/VARCHAR/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[84];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/VARCHAR/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:VARCHAR)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/VARCHAR/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/VARGRAPHIC/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[85];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/VARGRAPHIC/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:VARGRAPHIC)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/VARGRAPHIC/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/VARIANCE/i, or /VAR/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[86];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_87_of_rule_sysibm_function]},
          Parse::RecDescent::_tracefirst($text),
          q{sysibm_function},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_87_of_rule_sysibm_function($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_87_of_rule_sysibm_function]>>},
              Parse::RecDescent::_tracefirst($text),
              q{sysibm_function},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_87_of_rule_sysibm_function]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_87_of_rule_sysibm_function}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [/VARIANCE/i, or /VAR/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/YEAR/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[87];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysibm_function});
    %item = (__RULE__ => q{sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/YEAR/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:YEAR)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/YEAR/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{sysibm_function},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{sysibm_function},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{sysibm_function},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::window_partition_clause
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"window_partition_clause"};

  Parse::RecDescent::_trace(q{Trying rule: [window_partition_clause]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{window_partition_clause},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/PARTITION\\s+BY/i <leftop: partitioning_expression /,/ partitioning_expression>]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{window_partition_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{window_partition_clause});
    %item = (__RULE__ => q{window_partition_clause});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/PARTITION\\s+BY/i]}, Parse::RecDescent::_tracefirst($text),
            q{window_partition_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:PARTITION\s+BY)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying operator: [<leftop: partitioning_expression /,/ partitioning_expression>]},
          Parse::RecDescent::_tracefirst($text),
          q{window_partition_clause},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{<leftop: partitioning_expression /,/ partitioning_expression>})->at($text);

    $_tok = undef;
    OPLOOP: while (1)
    {
      $repcount = 0;
      my  @item;

      # MATCH LEFTARG

    Parse::RecDescent::_trace(q{Trying subrule: [partitioning_expression]},
          Parse::RecDescent::_tracefirst($text),
          q{window_partition_clause},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{partitioning_expression})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::partitioning_expression($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [partitioning_expression]>>},
              Parse::RecDescent::_tracefirst($text),
              q{window_partition_clause},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [partitioning_expression]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{window_partition_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{partitioning_expression}} = $_tok;
    push @item, $_tok;

    }


      $repcount++;

      my $savetext = $text;
      my $backtrack;

      # MATCH (OP RIGHTARG)(s)
      while ($repcount < 100000000)
      {
      $backtrack = 0;

    Parse::RecDescent::_trace(q{Trying terminal: [/,/]}, Parse::RecDescent::_tracefirst($text),
            q{window_partition_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/,/})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:,)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN2__}=$&;


      pop @item;
      if (defined $1) {push @item, $item{'partitioning_expression(s)'}=$1; $backtrack=1;}

    Parse::RecDescent::_trace(q{Trying subrule: [partitioning_expression]},
          Parse::RecDescent::_tracefirst($text),
          q{window_partition_clause},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{partitioning_expression})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::partitioning_expression($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [partitioning_expression]>>},
              Parse::RecDescent::_tracefirst($text),
              q{window_partition_clause},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [partitioning_expression]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{window_partition_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{partitioning_expression}} = $_tok;
    push @item, $_tok;

    }

      $savetext = $text;
      $repcount++;
      }
      $text = $savetext;
      pop @item if $backtrack;

      unless (@item) { undef $_tok; last }
      $_tok = [ @item ];
      last;
    }

    unless ($repcount>=1)
    {
      Parse::RecDescent::_trace(q{<<Didn't match operator: [<leftop: partitioning_expression /,/ partitioning_expression>]>>},
              Parse::RecDescent::_tracefirst($text),
              q{window_partition_clause},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched operator: [<leftop: partitioning_expression /,/ partitioning_expression>]<< (return value: [}
            . qq{@{$_tok||[]}} . q{]},
            Parse::RecDescent::_tracefirst($text),
            q{window_partition_clause},
            $tracelevel)
            if defined $::RD_TRACE;

    push @item, $item{'partitioning_expression(s)'}=$_tok||[];



    Parse::RecDescent::_trace(q{>>Matched production: [/PARTITION\\s+BY/i <leftop: partitioning_expression /,/ partitioning_expression>]<<},
            Parse::RecDescent::_tracefirst($text),
            q{window_partition_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{window_partition_clause},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{window_partition_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{window_partition_clause},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{window_partition_clause},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::WHERE
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"WHERE"};

  Parse::RecDescent::_trace(q{Trying rule: [WHERE]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{WHERE},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/where/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{WHERE},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{WHERE});
    %item = (__RULE__ => q{WHERE});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/where/i]}, Parse::RecDescent::_tracefirst($text),
            q{WHERE},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:where)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/where/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{WHERE},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{WHERE},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{WHERE},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{WHERE},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{WHERE},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::CREATE
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"CREATE"};

  Parse::RecDescent::_trace(q{Trying rule: [CREATE]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{CREATE},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/create/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{CREATE},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{CREATE});
    %item = (__RULE__ => q{CREATE});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/create/i]}, Parse::RecDescent::_tracefirst($text),
            q{CREATE},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:create)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/create/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{CREATE},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{CREATE},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{CREATE},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{CREATE},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{CREATE},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_sysfun
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule_sysfun"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule_sysfun]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_1_of_rule_sysfun},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/ABS/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule_sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule_sysfun});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/ABS/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:ABS)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/ABS/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/ABSVAL/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule_sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule_sysfun});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/ABSVAL/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:ABSVAL)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/ABSVAL/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_1_of_rule_sysfun},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_1_of_rule_sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_1_of_rule_sysfun},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_1_of_rule_sysfun},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_function
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule_function"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule_function]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_1_of_rule_function},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/SYSIBM\\.|/i sysibm_function]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule_function});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/SYSIBM\\.|/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:SYSIBM\.|)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [sysibm_function]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_1_of_production_1_of_rule_function},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{sysibm_function})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::sysibm_function($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [sysibm_function]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_1_of_production_1_of_rule_function},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [sysibm_function]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{sysibm_function}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [/SYSIBM\\.|/i sysibm_function]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/SYSFUN\\.|/i sysfun_function]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule_function});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/SYSFUN\\.|/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:SYSFUN\.|)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [sysfun_function]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_1_of_production_1_of_rule_function},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{sysfun_function})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::sysfun_function($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [sysfun_function]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_1_of_production_1_of_rule_function},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [sysfun_function]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{sysfun_function}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [/SYSFUN\\.|/i sysfun_function]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [userdefined_function]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[2];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule_function});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [userdefined_function]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_1_of_production_1_of_rule_function},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::userdefined_function($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [userdefined_function]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_1_of_production_1_of_rule_function},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [userdefined_function]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{userdefined_function}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [userdefined_function]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_1_of_rule_function},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_1_of_rule_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_1_of_rule_function},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_1_of_rule_function},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::identifier
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"identifier"};

  Parse::RecDescent::_trace(q{Trying rule: [identifier]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{identifier},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [NAME]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{identifier},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{identifier});
    %item = (__RULE__ => q{identifier});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [NAME]},
          Parse::RecDescent::_tracefirst($text),
          q{identifier},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::NAME($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [NAME]>>},
              Parse::RecDescent::_tracefirst($text),
              q{identifier},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [NAME]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{identifier},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{NAME}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [NAME]<<},
            Parse::RecDescent::_tracefirst($text),
            q{identifier},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{identifier},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{identifier},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{identifier},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{identifier},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_window_order_clause
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_window_order_clause"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_window_order_clause]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_window_order_clause},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [asc_option]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_window_order_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_window_order_clause});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_window_order_clause});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [asc_option]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_window_order_clause},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::asc_option($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [asc_option]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_window_order_clause},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [asc_option]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_window_order_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{asc_option}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [asc_option]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_window_order_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [desc_option]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_window_order_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_window_order_clause});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_window_order_clause});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [desc_option]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_window_order_clause},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::desc_option($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [desc_option]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_window_order_clause},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [desc_option]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_window_order_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{desc_option}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [desc_option]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_window_order_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_window_order_clause},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_window_order_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_window_order_clause},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_window_order_clause},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::result_expression
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"result_expression"};

  Parse::RecDescent::_trace(q{Trying rule: [result_expression]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{result_expression},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [expression]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{result_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{result_expression});
    %item = (__RULE__ => q{result_expression});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [expression]},
          Parse::RecDescent::_tracefirst($text),
          q{result_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::expression($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [expression]>>},
              Parse::RecDescent::_tracefirst($text),
              q{result_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [expression]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{result_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{expression}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [expression]<<},
            Parse::RecDescent::_tracefirst($text),
            q{result_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{result_expression},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{result_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{result_expression},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{result_expression},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::scoped_reference_expression
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"scoped_reference_expression"};

  Parse::RecDescent::_trace(q{Trying rule: [scoped_reference_expression]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{scoped_reference_expression},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [expression]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{scoped_reference_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{scoped_reference_expression});
    %item = (__RULE__ => q{scoped_reference_expression});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [expression]},
          Parse::RecDescent::_tracefirst($text),
          q{scoped_reference_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::expression($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [expression]>>},
              Parse::RecDescent::_tracefirst($text),
              q{scoped_reference_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [expression]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{scoped_reference_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{expression}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying action},
            Parse::RecDescent::_tracefirst($text),
            q{scoped_reference_expression},
            $tracelevel)
            if defined $::RD_TRACE;


    $_tok = ($_noactions) ? 0 : do { # scoped, reference
};
    unless (defined $_tok)
    {
      Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
          if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
            . $_tok . q{])},
            Parse::RecDescent::_tracefirst($text))
            if defined $::RD_TRACE;
    push @item, $_tok;
    $item{__ACTION1__}=$_tok;



    Parse::RecDescent::_trace(q{>>Matched production: [expression]<<},
            Parse::RecDescent::_tracefirst($text),
            q{scoped_reference_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{scoped_reference_expression},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{scoped_reference_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{scoped_reference_expression},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{scoped_reference_expression},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cast_specification
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cast_specification"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cast_specification]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cast_specification},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [typed_table_name]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cast_specification},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cast_specification});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cast_specification});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [typed_table_name]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cast_specification},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::typed_table_name($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [typed_table_name]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cast_specification},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [typed_table_name]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cast_specification},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{typed_table_name}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [typed_table_name]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cast_specification},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [typed_view_name]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cast_specification},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cast_specification});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cast_specification});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [typed_view_name]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cast_specification},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::typed_view_name($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [typed_view_name]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cast_specification},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [typed_view_name]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cast_specification},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{typed_view_name}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [typed_view_name]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cast_specification},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cast_specification},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cast_specification},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cast_specification},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cast_specification},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::when_clause
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"when_clause"};

  Parse::RecDescent::_trace(q{Trying rule: [when_clause]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{when_clause},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/WHEN/i '(' search_condition ')']},
            Parse::RecDescent::_tracefirst($_[1]),
            q{when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{when_clause});
    %item = (__RULE__ => q{when_clause});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/WHEN/i]}, Parse::RecDescent::_tracefirst($text),
            q{when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:WHEN)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying terminal: ['(']},
            Parse::RecDescent::_tracefirst($text),
            q{when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{'('})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\(//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [search_condition]},
          Parse::RecDescent::_tracefirst($text),
          q{when_clause},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{search_condition})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::search_condition($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [search_condition]>>},
              Parse::RecDescent::_tracefirst($text),
              q{when_clause},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [search_condition]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{search_condition}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: [')']},
            Parse::RecDescent::_tracefirst($text),
            q{when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{')'})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING2__}=$&;


    Parse::RecDescent::_trace(q{Trying action},
            Parse::RecDescent::_tracefirst($text),
            q{when_clause},
            $tracelevel)
            if defined $::RD_TRACE;


    $_tok = ($_noactions) ? 0 : do {$return = $item[3]};
    unless (defined $_tok)
    {
      Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
          if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
            . $_tok . q{])},
            Parse::RecDescent::_tracefirst($text))
            if defined $::RD_TRACE;
    push @item, $_tok;
    $item{__ACTION1__}=$_tok;



    Parse::RecDescent::_trace(q{>>Matched production: [/WHEN/i '(' search_condition ')']<<},
            Parse::RecDescent::_tracefirst($text),
            q{when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{when_clause},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{when_clause},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{when_clause},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_asc_option
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule_asc_option"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule_asc_option]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_1_of_rule_asc_option},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/NULLS\\s+FIRST/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule_asc_option},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule_asc_option});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_asc_option});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/NULLS\\s+FIRST/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_asc_option},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:NULLS\s+FIRST)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/NULLS\\s+FIRST/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_asc_option},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/NULLS\\s+LAST/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule_asc_option},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule_asc_option});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_asc_option});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/NULLS\\s+LAST/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_asc_option},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:NULLS\s+LAST)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/NULLS\\s+LAST/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_asc_option},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_1_of_rule_asc_option},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_1_of_rule_asc_option},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_1_of_rule_asc_option},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_1_of_rule_asc_option},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::sequence_name
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"sequence_name"};

  Parse::RecDescent::_trace(q{Trying rule: [sequence_name]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{sequence_name},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [NAME]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sequence_name},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{sequence_name});
    %item = (__RULE__ => q{sequence_name});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [NAME]},
          Parse::RecDescent::_tracefirst($text),
          q{sequence_name},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::NAME($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [NAME]>>},
              Parse::RecDescent::_tracefirst($text),
              q{sequence_name},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [NAME]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{sequence_name},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{NAME}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [NAME]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sequence_name},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{sequence_name},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{sequence_name},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{sequence_name},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{sequence_name},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::ld_duration
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"ld_duration"};

  Parse::RecDescent::_trace(q{Trying rule: [ld_duration]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{ld_duration},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/YEARS?/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{ld_duration},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{ld_duration});
    %item = (__RULE__ => q{ld_duration});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/YEARS?/i]}, Parse::RecDescent::_tracefirst($text),
            q{ld_duration},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:YEARS?)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/YEARS?/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{ld_duration},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/MONTHS?/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{ld_duration},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{ld_duration});
    %item = (__RULE__ => q{ld_duration});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/MONTHS?/i]}, Parse::RecDescent::_tracefirst($text),
            q{ld_duration},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:MONTHS?)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/MONTHS?/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{ld_duration},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/DAYS?/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{ld_duration},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[2];
    $text = $_[1];
    my $_savetext;
    @item = (q{ld_duration});
    %item = (__RULE__ => q{ld_duration});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/DAYS?/i]}, Parse::RecDescent::_tracefirst($text),
            q{ld_duration},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:DAYS?)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/DAYS?/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{ld_duration},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/HOURS?/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{ld_duration},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[3];
    $text = $_[1];
    my $_savetext;
    @item = (q{ld_duration});
    %item = (__RULE__ => q{ld_duration});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/HOURS?/i]}, Parse::RecDescent::_tracefirst($text),
            q{ld_duration},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:HOURS?)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/HOURS?/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{ld_duration},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/MINUTES?/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{ld_duration},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[4];
    $text = $_[1];
    my $_savetext;
    @item = (q{ld_duration});
    %item = (__RULE__ => q{ld_duration});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/MINUTES?/i]}, Parse::RecDescent::_tracefirst($text),
            q{ld_duration},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:MINUTES?)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/MINUTES?/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{ld_duration},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/SECONDS?/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{ld_duration},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[5];
    $text = $_[1];
    my $_savetext;
    @item = (q{ld_duration});
    %item = (__RULE__ => q{ld_duration});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/SECONDS?/i]}, Parse::RecDescent::_tracefirst($text),
            q{ld_duration},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:SECONDS?)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/SECONDS?/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{ld_duration},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/MICROSECONDS?/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{ld_duration},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[6];
    $text = $_[1];
    my $_savetext;
    @item = (q{ld_duration});
    %item = (__RULE__ => q{ld_duration});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/MICROSECONDS?/i]}, Parse::RecDescent::_tracefirst($text),
            q{ld_duration},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:MICROSECONDS?)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/MICROSECONDS?/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{ld_duration},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{ld_duration},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{ld_duration},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{ld_duration},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{ld_duration},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::reference_a
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"reference_a"};

  Parse::RecDescent::_trace(q{Trying rule: [reference_a]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{reference_a},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/REFERENCING/i old_new_corr old_new_table]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{reference_a},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{reference_a});
    %item = (__RULE__ => q{reference_a});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/REFERENCING/i]}, Parse::RecDescent::_tracefirst($text),
            q{reference_a},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:REFERENCING)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying repeated subrule: [old_new_corr]},
          Parse::RecDescent::_tracefirst($text),
          q{reference_a},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{old_new_corr})->at($text);

    unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::old_new_corr, 0, 2, $_noactions,$expectation,undef)))
    {
      Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [old_new_corr]>>},
              Parse::RecDescent::_tracefirst($text),
              q{reference_a},
              $tracelevel)
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched repeated subrule: [old_new_corr]<< (}
          . @$_tok . q{ times)},

            Parse::RecDescent::_tracefirst($text),
            q{reference_a},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{old_new_corr(0..2)}} = $_tok;
    push @item, $_tok;



    Parse::RecDescent::_trace(q{Trying repeated subrule: [old_new_table]},
          Parse::RecDescent::_tracefirst($text),
          q{reference_a},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{old_new_table})->at($text);

    unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::old_new_table, 0, 2, $_noactions,$expectation,undef)))
    {
      Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [old_new_table]>>},
              Parse::RecDescent::_tracefirst($text),
              q{reference_a},
              $tracelevel)
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched repeated subrule: [old_new_table]<< (}
          . @$_tok . q{ times)},

            Parse::RecDescent::_tracefirst($text),
            q{reference_a},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{old_new_table(0..2)}} = $_tok;
    push @item, $_tok;



    Parse::RecDescent::_trace(q{Trying action},
            Parse::RecDescent::_tracefirst($text),
            q{reference_a},
            $tracelevel)
            if defined $::RD_TRACE;


    $_tok = ($_noactions) ? 0 : do { $return = join(' ', $item[1], join(' ', @{$item[2]}), join(' ', @{$item[3]})  ) };
    unless (defined $_tok)
    {
      Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
          if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
            . $_tok . q{])},
            Parse::RecDescent::_tracefirst($text))
            if defined $::RD_TRACE;
    push @item, $_tok;
    $item{__ACTION1__}=$_tok;



    Parse::RecDescent::_trace(q{>>Matched production: [/REFERENCING/i old_new_corr old_new_table]<<},
            Parse::RecDescent::_tracefirst($text),
            q{reference_a},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{reference_a},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{reference_a},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{reference_a},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{reference_a},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::cast_specification
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"cast_specification"};

  Parse::RecDescent::_trace(q{Trying rule: [cast_specification]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{cast_specification},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/CAST/i '(' expression, or /NULL/i, or parameter_marker /AS/i data_type /SCOPE/ ')']},
            Parse::RecDescent::_tracefirst($_[1]),
            q{cast_specification},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{cast_specification});
    %item = (__RULE__ => q{cast_specification});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/CAST/i]}, Parse::RecDescent::_tracefirst($text),
            q{cast_specification},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:CAST)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying terminal: ['(']},
            Parse::RecDescent::_tracefirst($text),
            q{cast_specification},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{'('})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\(//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_1_of_rule_cast_specification]},
          Parse::RecDescent::_tracefirst($text),
          q{cast_specification},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{expression, or /NULL/i, or parameter_marker})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_cast_specification($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_1_of_rule_cast_specification]>>},
              Parse::RecDescent::_tracefirst($text),
              q{cast_specification},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_1_of_rule_cast_specification]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{cast_specification},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_1_of_rule_cast_specification}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: [/AS/i]}, Parse::RecDescent::_tracefirst($text),
            q{cast_specification},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/AS/i})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:AS)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN2__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [data_type]},
          Parse::RecDescent::_tracefirst($text),
          q{cast_specification},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{data_type})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::data_type($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [data_type]>>},
              Parse::RecDescent::_tracefirst($text),
              q{cast_specification},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [data_type]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{cast_specification},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{data_type}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying repeated subrule: [/SCOPE/]},
          Parse::RecDescent::_tracefirst($text),
          q{cast_specification},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{/SCOPE/})->at($text);

    unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_2_of_production_1_of_rule_cast_specification, 0, 1, $_noactions,$expectation,undef)))
    {
      Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [/SCOPE/]>>},
              Parse::RecDescent::_tracefirst($text),
              q{cast_specification},
              $tracelevel)
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched repeated subrule: [_alternation_2_of_production_1_of_rule_cast_specification]<< (}
          . @$_tok . q{ times)},

            Parse::RecDescent::_tracefirst($text),
            q{cast_specification},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_2_of_production_1_of_rule_cast_specification(?)}} = $_tok;
    push @item, $_tok;



    Parse::RecDescent::_trace(q{Trying terminal: [')']},
            Parse::RecDescent::_tracefirst($text),
            q{cast_specification},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{')'})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING2__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/CAST/i '(' expression, or /NULL/i, or parameter_marker /AS/i data_type /SCOPE/ ')']<<},
            Parse::RecDescent::_tracefirst($text),
            q{cast_specification},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{cast_specification},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{cast_specification},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{cast_specification},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{cast_specification},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::type
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"type"};

  Parse::RecDescent::_trace(q{Trying rule: [type]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{type},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/UPDATE/i /OF/i <leftop: column_name /,/ column_name>]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{type},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{type});
    %item = (__RULE__ => q{type});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/UPDATE/i]}, Parse::RecDescent::_tracefirst($text),
            q{type},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:UPDATE)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying terminal: [/OF/i]}, Parse::RecDescent::_tracefirst($text),
            q{type},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/OF/i})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:OF)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN2__}=$&;


    Parse::RecDescent::_trace(q{Trying operator: [<leftop: column_name /,/ column_name>]},
          Parse::RecDescent::_tracefirst($text),
          q{type},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{<leftop: column_name /,/ column_name>})->at($text);

    $_tok = undef;
    OPLOOP: while (1)
    {
      $repcount = 0;
      my  @item;

      # MATCH LEFTARG

    Parse::RecDescent::_trace(q{Trying subrule: [column_name]},
          Parse::RecDescent::_tracefirst($text),
          q{type},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{column_name})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::column_name($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [column_name]>>},
              Parse::RecDescent::_tracefirst($text),
              q{type},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [column_name]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{type},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{column_name}} = $_tok;
    push @item, $_tok;

    }


      $repcount++;

      my $savetext = $text;
      my $backtrack;

      # MATCH (OP RIGHTARG)(s)
      while ($repcount < 100000000)
      {
      $backtrack = 0;

    Parse::RecDescent::_trace(q{Trying terminal: [/,/]}, Parse::RecDescent::_tracefirst($text),
            q{type},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/,/})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:,)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN3__}=$&;


      pop @item;
      if (defined $1) {push @item, $item{'column_name(s)'}=$1; $backtrack=1;}

    Parse::RecDescent::_trace(q{Trying subrule: [column_name]},
          Parse::RecDescent::_tracefirst($text),
          q{type},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{column_name})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::column_name($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [column_name]>>},
              Parse::RecDescent::_tracefirst($text),
              q{type},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [column_name]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{type},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{column_name}} = $_tok;
    push @item, $_tok;

    }

      $savetext = $text;
      $repcount++;
      }
      $text = $savetext;
      pop @item if $backtrack;

      unless (@item) { undef $_tok; last }
      $_tok = [ @item ];
      last;
    }

    unless ($repcount>=1)
    {
      Parse::RecDescent::_trace(q{<<Didn't match operator: [<leftop: column_name /,/ column_name>]>>},
              Parse::RecDescent::_tracefirst($text),
              q{type},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched operator: [<leftop: column_name /,/ column_name>]<< (return value: [}
            . qq{@{$_tok||[]}} . q{]},
            Parse::RecDescent::_tracefirst($text),
            q{type},
            $tracelevel)
            if defined $::RD_TRACE;

    push @item, $item{'column_name(s)'}=$_tok||[];


    Parse::RecDescent::_trace(q{Trying action},
            Parse::RecDescent::_tracefirst($text),
            q{type},
            $tracelevel)
            if defined $::RD_TRACE;


    $_tok = ($_noactions) ? 0 : do { $return = { event  => 'update_on',
              fields => $item[3] }
};
    unless (defined $_tok)
    {
      Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
          if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
            . $_tok . q{])},
            Parse::RecDescent::_tracefirst($text))
            if defined $::RD_TRACE;
    push @item, $_tok;
    $item{__ACTION1__}=$_tok;



    Parse::RecDescent::_trace(q{>>Matched production: [/UPDATE/i /OF/i <leftop: column_name /,/ column_name>]<<},
            Parse::RecDescent::_tracefirst($text),
            q{type},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/INSERT/i, or /DELETE/i, or /UPDATE/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{type},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{type});
    %item = (__RULE__ => q{type});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_2_of_rule_type]},
          Parse::RecDescent::_tracefirst($text),
          q{type},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_2_of_rule_type($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_2_of_rule_type]>>},
              Parse::RecDescent::_tracefirst($text),
              q{type},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_2_of_rule_type]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{type},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_2_of_rule_type}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying action},
            Parse::RecDescent::_tracefirst($text),
            q{type},
            $tracelevel)
            if defined $::RD_TRACE;


    $_tok = ($_noactions) ? 0 : do { $return = { event => $item[1] } };
    unless (defined $_tok)
    {
      Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
          if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
            . $_tok . q{])},
            Parse::RecDescent::_tracefirst($text))
            if defined $::RD_TRACE;
    push @item, $_tok;
    $item{__ACTION1__}=$_tok;



    Parse::RecDescent::_trace(q{>>Matched production: [/INSERT/i, or /DELETE/i, or /UPDATE/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{type},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{type},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{type},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{type},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{type},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_12_of_rule_sysibm_function
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_12_of_rule_sysibm_function"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_12_of_rule_sysibm_function]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_12_of_rule_sysibm_function},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/COVARIANCE/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_12_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_12_of_rule_sysibm_function});
    %item = (__RULE__ => q{_alternation_1_of_production_12_of_rule_sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/COVARIANCE/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_12_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:COVARIANCE)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/COVARIANCE/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_12_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/COVAR/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_12_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_12_of_rule_sysibm_function});
    %item = (__RULE__ => q{_alternation_1_of_production_12_of_rule_sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/COVAR/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_12_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:COVAR)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/COVAR/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_12_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_12_of_rule_sysibm_function},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_12_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_12_of_rule_sysibm_function},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_12_of_rule_sysibm_function},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::scalar_fullselect
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"scalar_fullselect"};

  Parse::RecDescent::_trace(q{Trying rule: [scalar_fullselect]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{scalar_fullselect},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: ['(' fullselect ')']},
            Parse::RecDescent::_tracefirst($_[1]),
            q{scalar_fullselect},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{scalar_fullselect});
    %item = (__RULE__ => q{scalar_fullselect});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: ['(']},
            Parse::RecDescent::_tracefirst($text),
            q{scalar_fullselect},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\(//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [fullselect]},
          Parse::RecDescent::_tracefirst($text),
          q{scalar_fullselect},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{fullselect})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::fullselect($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [fullselect]>>},
              Parse::RecDescent::_tracefirst($text),
              q{scalar_fullselect},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [fullselect]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{scalar_fullselect},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{fullselect}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: [')']},
            Parse::RecDescent::_tracefirst($text),
            q{scalar_fullselect},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{')'})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING2__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: ['(' fullselect ')']<<},
            Parse::RecDescent::_tracefirst($text),
            q{scalar_fullselect},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{scalar_fullselect},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{scalar_fullselect},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{scalar_fullselect},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{scalar_fullselect},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_options
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule_options"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule_options]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_1_of_rule_options},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/CASCADED/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule_options},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule_options});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_options});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/CASCADED/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_options},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:CASCADED)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/CASCADED/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_options},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/LOCAL/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule_options},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule_options});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_options});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/LOCAL/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_options},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:LOCAL)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/LOCAL/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_options},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_1_of_rule_options},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_1_of_rule_options},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_1_of_rule_options},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_1_of_rule_options},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::func_args
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"func_args"};

  Parse::RecDescent::_trace(q{Trying rule: [func_args]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{func_args},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [expression]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{func_args},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{func_args});
    %item = (__RULE__ => q{func_args});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [expression]},
          Parse::RecDescent::_tracefirst($text),
          q{func_args},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::expression($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [expression]>>},
              Parse::RecDescent::_tracefirst($text),
              q{func_args},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [expression]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{func_args},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{expression}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [expression]<<},
            Parse::RecDescent::_tracefirst($text),
            q{func_args},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{func_args},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{func_args},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{func_args},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{func_args},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::trigger_name
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"trigger_name"};

  Parse::RecDescent::_trace(q{Trying rule: [trigger_name]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{trigger_name},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [SCHEMA '.' NAME]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{trigger_name},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{trigger_name});
    %item = (__RULE__ => q{trigger_name});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [SCHEMA]},
          Parse::RecDescent::_tracefirst($text),
          q{trigger_name},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::SCHEMA($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [SCHEMA]>>},
              Parse::RecDescent::_tracefirst($text),
              q{trigger_name},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [SCHEMA]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{trigger_name},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{SCHEMA}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: ['.']},
            Parse::RecDescent::_tracefirst($text),
            q{trigger_name},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{'.'})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\.//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [NAME]},
          Parse::RecDescent::_tracefirst($text),
          q{trigger_name},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{NAME})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::NAME($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [NAME]>>},
              Parse::RecDescent::_tracefirst($text),
              q{trigger_name},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [NAME]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{trigger_name},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{NAME}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying action},
            Parse::RecDescent::_tracefirst($text),
            q{trigger_name},
            $tracelevel)
            if defined $::RD_TRACE;


    $_tok = ($_noactions) ? 0 : do { $return = { schema => $item[1], name => $item[3] } };
    unless (defined $_tok)
    {
      Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
          if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
            . $_tok . q{])},
            Parse::RecDescent::_tracefirst($text))
            if defined $::RD_TRACE;
    push @item, $_tok;
    $item{__ACTION1__}=$_tok;



    Parse::RecDescent::_trace(q{>>Matched production: [SCHEMA '.' NAME]<<},
            Parse::RecDescent::_tracefirst($text),
            q{trigger_name},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [NAME]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{trigger_name},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{trigger_name});
    %item = (__RULE__ => q{trigger_name});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [NAME]},
          Parse::RecDescent::_tracefirst($text),
          q{trigger_name},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::NAME($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [NAME]>>},
              Parse::RecDescent::_tracefirst($text),
              q{trigger_name},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [NAME]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{trigger_name},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{NAME}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying action},
            Parse::RecDescent::_tracefirst($text),
            q{trigger_name},
            $tracelevel)
            if defined $::RD_TRACE;


    $_tok = ($_noactions) ? 0 : do { $return = { name => $item[1] } };
    unless (defined $_tok)
    {
      Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
          if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
            . $_tok . q{])},
            Parse::RecDescent::_tracefirst($text))
            if defined $::RD_TRACE;
    push @item, $_tok;
    $item{__ACTION1__}=$_tok;



    Parse::RecDescent::_trace(q{>>Matched production: [NAME]<<},
            Parse::RecDescent::_tracefirst($text),
            q{trigger_name},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{trigger_name},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{trigger_name},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{trigger_name},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{trigger_name},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_2_of_production_1_of_rule_numbering_function
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_2_of_production_1_of_rule_numbering_function"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_2_of_production_1_of_rule_numbering_function]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_2_of_production_1_of_rule_numbering_function},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/RANGE\\s+BETWEEN\\s+UNBOUNDED\\s+PRECEDING\\s+AND\\s+UNBBOUNDED\\s+FOLLOWING/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_2_of_production_1_of_rule_numbering_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_2_of_production_1_of_rule_numbering_function});
    %item = (__RULE__ => q{_alternation_2_of_production_1_of_rule_numbering_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/RANGE\\s+BETWEEN\\s+UNBOUNDED\\s+PRECEDING\\s+AND\\s+UNBBOUNDED\\s+FOLLOWING/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule_numbering_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:RANGE\s+BETWEEN\s+UNBOUNDED\s+PRECEDING\s+AND\s+UNBBOUNDED\s+FOLLOWING)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/RANGE\\s+BETWEEN\\s+UNBOUNDED\\s+PRECEDING\\s+AND\\s+UNBBOUNDED\\s+FOLLOWING/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule_numbering_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [window_aggregation_group_clause]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_2_of_production_1_of_rule_numbering_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_2_of_production_1_of_rule_numbering_function});
    %item = (__RULE__ => q{_alternation_2_of_production_1_of_rule_numbering_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [window_aggregation_group_clause]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_2_of_production_1_of_rule_numbering_function},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::window_aggregation_group_clause($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [window_aggregation_group_clause]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_2_of_production_1_of_rule_numbering_function},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [window_aggregation_group_clause]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule_numbering_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{window_aggregation_group_clause}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [window_aggregation_group_clause]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule_numbering_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_2_of_production_1_of_rule_numbering_function},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_2_of_production_1_of_rule_numbering_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_2_of_production_1_of_rule_numbering_function},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_2_of_production_1_of_rule_numbering_function},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::method_name
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"method_name"};

  Parse::RecDescent::_trace(q{Trying rule: [method_name]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{method_name},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [NAME]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{method_name},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{method_name});
    %item = (__RULE__ => q{method_name});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [NAME]},
          Parse::RecDescent::_tracefirst($text),
          q{method_name},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::NAME($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [NAME]>>},
              Parse::RecDescent::_tracefirst($text),
              q{method_name},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [NAME]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{method_name},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{NAME}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying action},
            Parse::RecDescent::_tracefirst($text),
            q{method_name},
            $tracelevel)
            if defined $::RD_TRACE;


    $_tok = ($_noactions) ? 0 : do { # must be a method of subject_expression
};
    unless (defined $_tok)
    {
      Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
          if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
            . $_tok . q{])},
            Parse::RecDescent::_tracefirst($text))
            if defined $::RD_TRACE;
    push @item, $_tok;
    $item{__ACTION1__}=$_tok;



    Parse::RecDescent::_trace(q{>>Matched production: [NAME]<<},
            Parse::RecDescent::_tracefirst($text),
            q{method_name},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{method_name},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{method_name},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{method_name},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{method_name},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::quantified_p
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"quantified_p"};

  Parse::RecDescent::_trace(q{Trying rule: [quantified_p]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{quantified_p},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [expression1 /(=|<>|<|>|<=|=>|\\^=|\\^<|\\^>|\\!=)/ /SOME|ANY|ALL/i '(' fullselect ')']},
            Parse::RecDescent::_tracefirst($_[1]),
            q{quantified_p},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{quantified_p});
    %item = (__RULE__ => q{quantified_p});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [expression1]},
          Parse::RecDescent::_tracefirst($text),
          q{quantified_p},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::expression1($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [expression1]>>},
              Parse::RecDescent::_tracefirst($text),
              q{quantified_p},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [expression1]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{quantified_p},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{expression1}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: [/(=|<>|<|>|<=|=>|\\^=|\\^<|\\^>|\\!=)/]}, Parse::RecDescent::_tracefirst($text),
            q{quantified_p},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/(=|<>|<|>|<=|=>|\\^=|\\^<|\\^>|\\!=)/})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:(=|<>|<|>|<=|=>|\^=|\^<|\^>|\!=))//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying terminal: [/SOME|ANY|ALL/i]}, Parse::RecDescent::_tracefirst($text),
            q{quantified_p},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/SOME|ANY|ALL/i})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:SOME|ANY|ALL)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN2__}=$&;


    Parse::RecDescent::_trace(q{Trying terminal: ['(']},
            Parse::RecDescent::_tracefirst($text),
            q{quantified_p},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{'('})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\(//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [fullselect]},
          Parse::RecDescent::_tracefirst($text),
          q{quantified_p},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{fullselect})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::fullselect($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [fullselect]>>},
              Parse::RecDescent::_tracefirst($text),
              q{quantified_p},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [fullselect]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{quantified_p},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{fullselect}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: [')']},
            Parse::RecDescent::_tracefirst($text),
            q{quantified_p},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{')'})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING2__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [expression1 /(=|<>|<|>|<=|=>|\\^=|\\^<|\\^>|\\!=)/ /SOME|ANY|ALL/i '(' fullselect ')']<<},
            Parse::RecDescent::_tracefirst($text),
            q{quantified_p},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{quantified_p},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{quantified_p},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{quantified_p},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{quantified_p},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::common_table_expression
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"common_table_expression"};

  Parse::RecDescent::_trace(q{Trying rule: [common_table_expression]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{common_table_expression},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [table_name column_list /AS/i get_bracketed]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{common_table_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{common_table_expression});
    %item = (__RULE__ => q{common_table_expression});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [table_name]},
          Parse::RecDescent::_tracefirst($text),
          q{common_table_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::table_name($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [table_name]>>},
              Parse::RecDescent::_tracefirst($text),
              q{common_table_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [table_name]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{common_table_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{table_name}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying subrule: [column_list]},
          Parse::RecDescent::_tracefirst($text),
          q{common_table_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{column_list})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::column_list($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [column_list]>>},
              Parse::RecDescent::_tracefirst($text),
              q{common_table_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [column_list]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{common_table_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{column_list}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: [/AS/i]}, Parse::RecDescent::_tracefirst($text),
            q{common_table_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/AS/i})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:AS)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [get_bracketed]},
          Parse::RecDescent::_tracefirst($text),
          q{common_table_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{get_bracketed})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::get_bracketed($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [get_bracketed]>>},
              Parse::RecDescent::_tracefirst($text),
              q{common_table_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [get_bracketed]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{common_table_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{get_bracketed}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying action},
            Parse::RecDescent::_tracefirst($text),
            q{common_table_expression},
            $tracelevel)
            if defined $::RD_TRACE;


    $_tok = ($_noactions) ? 0 : do {
    $return = { name  => $item{table_name}{name},
                query => $item[4]
                };
};
    unless (defined $_tok)
    {
      Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
          if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
            . $_tok . q{])},
            Parse::RecDescent::_tracefirst($text))
            if defined $::RD_TRACE;
    push @item, $_tok;
    $item{__ACTION1__}=$_tok;



    Parse::RecDescent::_trace(q{>>Matched production: [table_name column_list /AS/i get_bracketed]<<},
            Parse::RecDescent::_tracefirst($text),
            q{common_table_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [table_name column_list /AS/i '(' fullselect ')']},
            Parse::RecDescent::_tracefirst($_[1]),
            q{common_table_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{common_table_expression});
    %item = (__RULE__ => q{common_table_expression});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [table_name]},
          Parse::RecDescent::_tracefirst($text),
          q{common_table_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::table_name($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [table_name]>>},
              Parse::RecDescent::_tracefirst($text),
              q{common_table_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [table_name]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{common_table_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{table_name}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying subrule: [column_list]},
          Parse::RecDescent::_tracefirst($text),
          q{common_table_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{column_list})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::column_list($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [column_list]>>},
              Parse::RecDescent::_tracefirst($text),
              q{common_table_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [column_list]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{common_table_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{column_list}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: [/AS/i]}, Parse::RecDescent::_tracefirst($text),
            q{common_table_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/AS/i})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:AS)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying terminal: ['(']},
            Parse::RecDescent::_tracefirst($text),
            q{common_table_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{'('})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\(//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [fullselect]},
          Parse::RecDescent::_tracefirst($text),
          q{common_table_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{fullselect})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::fullselect($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [fullselect]>>},
              Parse::RecDescent::_tracefirst($text),
              q{common_table_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [fullselect]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{common_table_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{fullselect}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: [')']},
            Parse::RecDescent::_tracefirst($text),
            q{common_table_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{')'})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING2__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [table_name column_list /AS/i '(' fullselect ')']<<},
            Parse::RecDescent::_tracefirst($text),
            q{common_table_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{common_table_expression},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{common_table_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{common_table_expression},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{common_table_expression},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::after
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"after"};

  Parse::RecDescent::_trace(q{Trying rule: [after]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{after},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/AFTER/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{after},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{after});
    %item = (__RULE__ => q{after});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/AFTER/i]}, Parse::RecDescent::_tracefirst($text),
            q{after},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:AFTER)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/AFTER/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{after},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{after},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{after},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{after},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{after},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::predicate
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"predicate"};

  Parse::RecDescent::_trace(q{Trying rule: [predicate]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{predicate},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [basic_p]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{predicate},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{predicate});
    %item = (__RULE__ => q{predicate});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [basic_p]},
          Parse::RecDescent::_tracefirst($text),
          q{predicate},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::basic_p($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [basic_p]>>},
              Parse::RecDescent::_tracefirst($text),
              q{predicate},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [basic_p]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{predicate},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{basic_p}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [basic_p]<<},
            Parse::RecDescent::_tracefirst($text),
            q{predicate},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [quantified_p]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{predicate},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{predicate});
    %item = (__RULE__ => q{predicate});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [quantified_p]},
          Parse::RecDescent::_tracefirst($text),
          q{predicate},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::quantified_p($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [quantified_p]>>},
              Parse::RecDescent::_tracefirst($text),
              q{predicate},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [quantified_p]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{predicate},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{quantified_p}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [quantified_p]<<},
            Parse::RecDescent::_tracefirst($text),
            q{predicate},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [between_p]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{predicate},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[2];
    $text = $_[1];
    my $_savetext;
    @item = (q{predicate});
    %item = (__RULE__ => q{predicate});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [between_p]},
          Parse::RecDescent::_tracefirst($text),
          q{predicate},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::between_p($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [between_p]>>},
              Parse::RecDescent::_tracefirst($text),
              q{predicate},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [between_p]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{predicate},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{between_p}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [between_p]<<},
            Parse::RecDescent::_tracefirst($text),
            q{predicate},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [exists_p]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{predicate},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[3];
    $text = $_[1];
    my $_savetext;
    @item = (q{predicate});
    %item = (__RULE__ => q{predicate});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [exists_p]},
          Parse::RecDescent::_tracefirst($text),
          q{predicate},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::exists_p($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [exists_p]>>},
              Parse::RecDescent::_tracefirst($text),
              q{predicate},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [exists_p]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{predicate},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{exists_p}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [exists_p]<<},
            Parse::RecDescent::_tracefirst($text),
            q{predicate},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [in_p]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{predicate},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[4];
    $text = $_[1];
    my $_savetext;
    @item = (q{predicate});
    %item = (__RULE__ => q{predicate});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [in_p]},
          Parse::RecDescent::_tracefirst($text),
          q{predicate},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::in_p($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [in_p]>>},
              Parse::RecDescent::_tracefirst($text),
              q{predicate},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [in_p]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{predicate},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{in_p}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [in_p]<<},
            Parse::RecDescent::_tracefirst($text),
            q{predicate},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [like_p]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{predicate},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[5];
    $text = $_[1];
    my $_savetext;
    @item = (q{predicate});
    %item = (__RULE__ => q{predicate});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [like_p]},
          Parse::RecDescent::_tracefirst($text),
          q{predicate},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::like_p($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [like_p]>>},
              Parse::RecDescent::_tracefirst($text),
              q{predicate},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [like_p]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{predicate},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{like_p}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [like_p]<<},
            Parse::RecDescent::_tracefirst($text),
            q{predicate},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [null_p]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{predicate},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[6];
    $text = $_[1];
    my $_savetext;
    @item = (q{predicate});
    %item = (__RULE__ => q{predicate});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [null_p]},
          Parse::RecDescent::_tracefirst($text),
          q{predicate},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::null_p($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [null_p]>>},
              Parse::RecDescent::_tracefirst($text),
              q{predicate},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [null_p]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{predicate},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{null_p}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [null_p]<<},
            Parse::RecDescent::_tracefirst($text),
            q{predicate},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [type_p]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{predicate},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[7];
    $text = $_[1];
    my $_savetext;
    @item = (q{predicate});
    %item = (__RULE__ => q{predicate});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [type_p]},
          Parse::RecDescent::_tracefirst($text),
          q{predicate},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::type_p($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [type_p]>>},
              Parse::RecDescent::_tracefirst($text),
              q{predicate},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [type_p]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{predicate},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{type_p}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [type_p]<<},
            Parse::RecDescent::_tracefirst($text),
            q{predicate},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{predicate},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{predicate},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{predicate},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{predicate},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::column_name
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"column_name"};

  Parse::RecDescent::_trace(q{Trying rule: [column_name]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{column_name},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [NAME]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{column_name},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{column_name});
    %item = (__RULE__ => q{column_name});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [NAME]},
          Parse::RecDescent::_tracefirst($text),
          q{column_name},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::NAME($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [NAME]>>},
              Parse::RecDescent::_tracefirst($text),
              q{column_name},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [NAME]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{column_name},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{NAME}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [NAME]<<},
            Parse::RecDescent::_tracefirst($text),
            q{column_name},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{column_name},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{column_name},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{column_name},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{column_name},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::method_invocation
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"method_invocation"};

  Parse::RecDescent::_trace(q{Trying rule: [method_invocation]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{method_invocation},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [subject_expression '..' method_name '(']},
            Parse::RecDescent::_tracefirst($_[1]),
            q{method_invocation},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{method_invocation});
    %item = (__RULE__ => q{method_invocation});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [subject_expression]},
          Parse::RecDescent::_tracefirst($text),
          q{method_invocation},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::subject_expression($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [subject_expression]>>},
              Parse::RecDescent::_tracefirst($text),
              q{method_invocation},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [subject_expression]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{method_invocation},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{subject_expression}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: ['..']},
            Parse::RecDescent::_tracefirst($text),
            q{method_invocation},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{'..'})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\.\.//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [method_name]},
          Parse::RecDescent::_tracefirst($text),
          q{method_invocation},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{method_name})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::method_name($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [method_name]>>},
              Parse::RecDescent::_tracefirst($text),
              q{method_invocation},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [method_name]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{method_invocation},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{method_name}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying repeated subrule: ['(']},
          Parse::RecDescent::_tracefirst($text),
          q{method_invocation},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{'('})->at($text);

    unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_method_invocation, 0, 1, $_noactions,$expectation,undef)))
    {
      Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: ['(']>>},
              Parse::RecDescent::_tracefirst($text),
              q{method_invocation},
              $tracelevel)
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched repeated subrule: [_alternation_1_of_production_1_of_rule_method_invocation]<< (}
          . @$_tok . q{ times)},

            Parse::RecDescent::_tracefirst($text),
            q{method_invocation},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_1_of_rule_method_invocation(?)}} = $_tok;
    push @item, $_tok;




    Parse::RecDescent::_trace(q{>>Matched production: [subject_expression '..' method_name '(']<<},
            Parse::RecDescent::_tracefirst($text),
            q{method_invocation},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{method_invocation},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{method_invocation},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{method_invocation},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{method_invocation},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_dereference_operation
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule_dereference_operation"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule_dereference_operation]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_1_of_rule_dereference_operation},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: ['(' expression ')']},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule_dereference_operation},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule_dereference_operation});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_dereference_operation});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: ['(']},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_dereference_operation},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\(//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;


    Parse::RecDescent::_trace(q{Trying repeated subrule: [expression]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_1_of_production_1_of_rule_dereference_operation},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{expression})->at($text);

    unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::expression, 1, 100000000, $_noactions,$expectation,undef)))
    {
      Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [expression]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_1_of_production_1_of_rule_dereference_operation},
              $tracelevel)
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched repeated subrule: [expression]<< (}
          . @$_tok . q{ times)},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_dereference_operation},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{expression(s)}} = $_tok;
    push @item, $_tok;



    Parse::RecDescent::_trace(q{Trying terminal: [')']},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_dereference_operation},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{')'})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING2__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: ['(' expression ')']<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_dereference_operation},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_1_of_rule_dereference_operation},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_1_of_rule_dereference_operation},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_1_of_rule_dereference_operation},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_1_of_rule_dereference_operation},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_searched_when_clause
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule_searched_when_clause"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule_searched_when_clause]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_1_of_rule_searched_when_clause},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/WHEN/i search_condition /THEN/i result_expression, or /NULL/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule_searched_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule_searched_when_clause});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_searched_when_clause});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/WHEN/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_searched_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:WHEN)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [search_condition]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_1_of_production_1_of_rule_searched_when_clause},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{search_condition})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::search_condition($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [search_condition]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_1_of_production_1_of_rule_searched_when_clause},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [search_condition]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_searched_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{search_condition}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: [/THEN/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_searched_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/THEN/i})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:THEN)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN2__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_searched_when_clause]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_1_of_production_1_of_rule_searched_when_clause},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{result_expression, or /NULL/i})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_searched_when_clause($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_searched_when_clause]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_1_of_production_1_of_rule_searched_when_clause},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_searched_when_clause]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_searched_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_searched_when_clause}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [/WHEN/i search_condition /THEN/i result_expression, or /NULL/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_searched_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_1_of_rule_searched_when_clause},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_1_of_rule_searched_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_1_of_rule_searched_when_clause},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_1_of_rule_searched_when_clause},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::group_bound2
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"group_bound2"};

  Parse::RecDescent::_trace(q{Trying rule: [group_bound2]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{group_bound2},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/UNBOUNDED\\s+PRECEDING/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{group_bound2},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{group_bound2});
    %item = (__RULE__ => q{group_bound2});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/UNBOUNDED\\s+PRECEDING/i]}, Parse::RecDescent::_tracefirst($text),
            q{group_bound2},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:UNBOUNDED\s+PRECEDING)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/UNBOUNDED\\s+PRECEDING/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{group_bound2},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [unsigned_constant /PRECEDING/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{group_bound2},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{group_bound2});
    %item = (__RULE__ => q{group_bound2});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [unsigned_constant]},
          Parse::RecDescent::_tracefirst($text),
          q{group_bound2},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::unsigned_constant($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [unsigned_constant]>>},
              Parse::RecDescent::_tracefirst($text),
              q{group_bound2},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [unsigned_constant]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{group_bound2},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{unsigned_constant}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: [/PRECEDING/i]}, Parse::RecDescent::_tracefirst($text),
            q{group_bound2},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/PRECEDING/i})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:PRECEDING)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [unsigned_constant /PRECEDING/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{group_bound2},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [unsigned_constant /FOLLOWING/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{group_bound2},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[2];
    $text = $_[1];
    my $_savetext;
    @item = (q{group_bound2});
    %item = (__RULE__ => q{group_bound2});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [unsigned_constant]},
          Parse::RecDescent::_tracefirst($text),
          q{group_bound2},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::unsigned_constant($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [unsigned_constant]>>},
              Parse::RecDescent::_tracefirst($text),
              q{group_bound2},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [unsigned_constant]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{group_bound2},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{unsigned_constant}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: [/FOLLOWING/i]}, Parse::RecDescent::_tracefirst($text),
            q{group_bound2},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/FOLLOWING/i})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:FOLLOWING)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [unsigned_constant /FOLLOWING/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{group_bound2},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/CURRENT\\s+ROW/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{group_bound2},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[3];
    $text = $_[1];
    my $_savetext;
    @item = (q{group_bound2});
    %item = (__RULE__ => q{group_bound2});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/CURRENT\\s+ROW/i]}, Parse::RecDescent::_tracefirst($text),
            q{group_bound2},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:CURRENT\s+ROW)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/CURRENT\\s+ROW/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{group_bound2},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{group_bound2},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{group_bound2},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{group_bound2},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{group_bound2},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::searched_when_clause
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"searched_when_clause"};

  Parse::RecDescent::_trace(q{Trying rule: [searched_when_clause]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{searched_when_clause},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/WHEN/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{searched_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{searched_when_clause});
    %item = (__RULE__ => q{searched_when_clause});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying repeated subrule: [/WHEN/i]},
          Parse::RecDescent::_tracefirst($text),
          q{searched_when_clause},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{})->at($text);

    unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_searched_when_clause, 1, 100000000, $_noactions,$expectation,undef)))
    {
      Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [/WHEN/i]>>},
              Parse::RecDescent::_tracefirst($text),
              q{searched_when_clause},
              $tracelevel)
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched repeated subrule: [_alternation_1_of_production_1_of_rule_searched_when_clause]<< (}
          . @$_tok . q{ times)},

            Parse::RecDescent::_tracefirst($text),
            q{searched_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_1_of_rule_searched_when_clause(s)}} = $_tok;
    push @item, $_tok;




    Parse::RecDescent::_trace(q{>>Matched production: [/WHEN/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{searched_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{searched_when_clause},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{searched_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{searched_when_clause},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{searched_when_clause},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::basic_p
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"basic_p"};

  Parse::RecDescent::_trace(q{Trying rule: [basic_p]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{basic_p},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [expression /(=|<>|<|>|<=|=>|\\^=|\\^<|\\^>|\\!=)/ expression]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{basic_p},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{basic_p});
    %item = (__RULE__ => q{basic_p});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [expression]},
          Parse::RecDescent::_tracefirst($text),
          q{basic_p},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::expression($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [expression]>>},
              Parse::RecDescent::_tracefirst($text),
              q{basic_p},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [expression]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{basic_p},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{expression}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: [/(=|<>|<|>|<=|=>|\\^=|\\^<|\\^>|\\!=)/]}, Parse::RecDescent::_tracefirst($text),
            q{basic_p},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/(=|<>|<|>|<=|=>|\\^=|\\^<|\\^>|\\!=)/})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:(=|<>|<|>|<=|=>|\^=|\^<|\^>|\!=))//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [expression]},
          Parse::RecDescent::_tracefirst($text),
          q{basic_p},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{expression})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::expression($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [expression]>>},
              Parse::RecDescent::_tracefirst($text),
              q{basic_p},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [expression]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{basic_p},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{expression}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [expression /(=|<>|<|>|<=|=>|\\^=|\\^<|\\^>|\\!=)/ expression]<<},
            Parse::RecDescent::_tracefirst($text),
            q{basic_p},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{basic_p},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{basic_p},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{basic_p},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{basic_p},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::asc_option
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"asc_option"};

  Parse::RecDescent::_trace(q{Trying rule: [asc_option]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{asc_option},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/ASC/i /NULLS\\s+FIRST/i, or /NULLS\\s+LAST/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{asc_option},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{asc_option});
    %item = (__RULE__ => q{asc_option});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/ASC/i]}, Parse::RecDescent::_tracefirst($text),
            q{asc_option},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:ASC)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying repeated subrule: [/NULLS\\s+FIRST/i, or /NULLS\\s+LAST/i]},
          Parse::RecDescent::_tracefirst($text),
          q{asc_option},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{/NULLS\\s+FIRST/i, or /NULLS\\s+LAST/i})->at($text);

    unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_asc_option, 0, 1, $_noactions,$expectation,undef)))
    {
      Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [/NULLS\\s+FIRST/i, or /NULLS\\s+LAST/i]>>},
              Parse::RecDescent::_tracefirst($text),
              q{asc_option},
              $tracelevel)
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched repeated subrule: [_alternation_1_of_production_1_of_rule_asc_option]<< (}
          . @$_tok . q{ times)},

            Parse::RecDescent::_tracefirst($text),
            q{asc_option},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_1_of_rule_asc_option(?)}} = $_tok;
    push @item, $_tok;




    Parse::RecDescent::_trace(q{>>Matched production: [/ASC/i /NULLS\\s+FIRST/i, or /NULLS\\s+LAST/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{asc_option},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{asc_option},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{asc_option},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{asc_option},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{asc_option},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::search_condition
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"search_condition"};

  Parse::RecDescent::_trace(q{Trying rule: [search_condition]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{search_condition},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/[^)]+/]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{search_condition},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{search_condition});
    %item = (__RULE__ => q{search_condition});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/[^)]+/]}, Parse::RecDescent::_tracefirst($text),
            q{search_condition},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:[^)]+)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/[^)]+/]<<},
            Parse::RecDescent::_tracefirst($text),
            q{search_condition},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/NOT|/i predicate, or '(' cond]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{search_condition},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{search_condition});
    %item = (__RULE__ => q{search_condition});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/NOT|/i]}, Parse::RecDescent::_tracefirst($text),
            q{search_condition},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:NOT|)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_2_of_rule_search_condition]},
          Parse::RecDescent::_tracefirst($text),
          q{search_condition},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{predicate, or '('})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_2_of_rule_search_condition($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_2_of_rule_search_condition]>>},
              Parse::RecDescent::_tracefirst($text),
              q{search_condition},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_2_of_rule_search_condition]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{search_condition},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_2_of_rule_search_condition}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying repeated subrule: [cond]},
          Parse::RecDescent::_tracefirst($text),
          q{search_condition},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{cond})->at($text);

    unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::cond, 0, 100000000, $_noactions,$expectation,undef)))
    {
      Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [cond]>>},
              Parse::RecDescent::_tracefirst($text),
              q{search_condition},
              $tracelevel)
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched repeated subrule: [cond]<< (}
          . @$_tok . q{ times)},

            Parse::RecDescent::_tracefirst($text),
            q{search_condition},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{cond(s?)}} = $_tok;
    push @item, $_tok;




    Parse::RecDescent::_trace(q{>>Matched production: [/NOT|/i predicate, or '(' cond]<<},
            Parse::RecDescent::_tracefirst($text),
            q{search_condition},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{search_condition},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{search_condition},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{search_condition},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{search_condition},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_operator
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule_operator"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule_operator]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_1_of_rule_operator},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/CONCAT/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule_operator},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule_operator});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_operator});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/CONCAT/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_operator},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:CONCAT)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/CONCAT/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_operator},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: ['||']},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule_operator},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule_operator});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_operator});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: ['||']},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_operator},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\|\|//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: ['||']<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_operator},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_1_of_rule_operator},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_1_of_rule_operator},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_1_of_rule_operator},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_1_of_rule_operator},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::simple_when_clause
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"simple_when_clause"};

  Parse::RecDescent::_trace(q{Trying rule: [simple_when_clause]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{simple_when_clause},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [expression /WHEN/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{simple_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{simple_when_clause});
    %item = (__RULE__ => q{simple_when_clause});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [expression]},
          Parse::RecDescent::_tracefirst($text),
          q{simple_when_clause},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::expression($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [expression]>>},
              Parse::RecDescent::_tracefirst($text),
              q{simple_when_clause},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [expression]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{simple_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{expression}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying repeated subrule: [/WHEN/i]},
          Parse::RecDescent::_tracefirst($text),
          q{simple_when_clause},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{/WHEN/i})->at($text);

    unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_simple_when_clause, 1, 100000000, $_noactions,$expectation,undef)))
    {
      Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [/WHEN/i]>>},
              Parse::RecDescent::_tracefirst($text),
              q{simple_when_clause},
              $tracelevel)
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched repeated subrule: [_alternation_1_of_production_1_of_rule_simple_when_clause]<< (}
          . @$_tok . q{ times)},

            Parse::RecDescent::_tracefirst($text),
            q{simple_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_1_of_rule_simple_when_clause(s)}} = $_tok;
    push @item, $_tok;




    Parse::RecDescent::_trace(q{>>Matched production: [expression /WHEN/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{simple_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{simple_when_clause},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{simple_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{simple_when_clause},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{simple_when_clause},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::INNER
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"INNER"};

  Parse::RecDescent::_trace(q{Trying rule: [INNER]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{INNER},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/inner/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{INNER},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{INNER});
    %item = (__RULE__ => q{INNER});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/inner/i]}, Parse::RecDescent::_tracefirst($text),
            q{INNER},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:inner)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/inner/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{INNER},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{INNER},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{INNER},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{INNER},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{INNER},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::eofile
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"eofile"};

  Parse::RecDescent::_trace(q{Trying rule: [eofile]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{eofile},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/^\\Z/]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{eofile},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{eofile});
    %item = (__RULE__ => q{eofile});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/^\\Z/]}, Parse::RecDescent::_tracefirst($text),
            q{eofile},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:^\Z)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/^\\Z/]<<},
            Parse::RecDescent::_tracefirst($text),
            q{eofile},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{eofile},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{eofile},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{eofile},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{eofile},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::cond
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"cond"};

  Parse::RecDescent::_trace(q{Trying rule: [cond]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{cond},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/AND/i, or /OR/i /NOT|/i predicate, or '(']},
            Parse::RecDescent::_tracefirst($_[1]),
            q{cond},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{cond});
    %item = (__RULE__ => q{cond});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_1_of_rule_cond]},
          Parse::RecDescent::_tracefirst($text),
          q{cond},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_cond($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_1_of_rule_cond]>>},
              Parse::RecDescent::_tracefirst($text),
              q{cond},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_1_of_rule_cond]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{cond},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_1_of_rule_cond}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: [/NOT|/i]}, Parse::RecDescent::_tracefirst($text),
            q{cond},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/NOT|/i})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:NOT|)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_2_of_production_1_of_rule_cond]},
          Parse::RecDescent::_tracefirst($text),
          q{cond},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{predicate, or '('})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_2_of_production_1_of_rule_cond($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_2_of_production_1_of_rule_cond]>>},
              Parse::RecDescent::_tracefirst($text),
              q{cond},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_2_of_production_1_of_rule_cond]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{cond},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_2_of_production_1_of_rule_cond}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [/AND/i, or /OR/i /NOT|/i predicate, or '(']<<},
            Parse::RecDescent::_tracefirst($text),
            q{cond},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{cond},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{cond},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{cond},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{cond},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::ld_type
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"ld_type"};

  Parse::RecDescent::_trace(q{Trying rule: [ld_type]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{ld_type},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [function]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{ld_type},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{ld_type});
    %item = (__RULE__ => q{ld_type});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [function]},
          Parse::RecDescent::_tracefirst($text),
          q{ld_type},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::function($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [function]>>},
              Parse::RecDescent::_tracefirst($text),
              q{ld_type},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [function]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{ld_type},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{function}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [function]<<},
            Parse::RecDescent::_tracefirst($text),
            q{ld_type},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: ['(' expression ')']},
            Parse::RecDescent::_tracefirst($_[1]),
            q{ld_type},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{ld_type});
    %item = (__RULE__ => q{ld_type});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: ['(']},
            Parse::RecDescent::_tracefirst($text),
            q{ld_type},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\(//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [expression]},
          Parse::RecDescent::_tracefirst($text),
          q{ld_type},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{expression})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::expression($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [expression]>>},
              Parse::RecDescent::_tracefirst($text),
              q{ld_type},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [expression]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{ld_type},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{expression}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: [')']},
            Parse::RecDescent::_tracefirst($text),
            q{ld_type},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{')'})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING2__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: ['(' expression ')']<<},
            Parse::RecDescent::_tracefirst($text),
            q{ld_type},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [constant]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{ld_type},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[2];
    $text = $_[1];
    my $_savetext;
    @item = (q{ld_type});
    %item = (__RULE__ => q{ld_type});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [constant]},
          Parse::RecDescent::_tracefirst($text),
          q{ld_type},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::constant($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [constant]>>},
              Parse::RecDescent::_tracefirst($text),
              q{ld_type},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [constant]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{ld_type},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{constant}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [constant]<<},
            Parse::RecDescent::_tracefirst($text),
            q{ld_type},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [column_name]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{ld_type},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[3];
    $text = $_[1];
    my $_savetext;
    @item = (q{ld_type});
    %item = (__RULE__ => q{ld_type});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [column_name]},
          Parse::RecDescent::_tracefirst($text),
          q{ld_type},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::column_name($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [column_name]>>},
              Parse::RecDescent::_tracefirst($text),
              q{ld_type},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [column_name]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{ld_type},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{column_name}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [column_name]<<},
            Parse::RecDescent::_tracefirst($text),
            q{ld_type},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [host_variable]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{ld_type},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[4];
    $text = $_[1];
    my $_savetext;
    @item = (q{ld_type});
    %item = (__RULE__ => q{ld_type});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [host_variable]},
          Parse::RecDescent::_tracefirst($text),
          q{ld_type},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::host_variable($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [host_variable]>>},
              Parse::RecDescent::_tracefirst($text),
              q{ld_type},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [host_variable]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{ld_type},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{host_variable}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [host_variable]<<},
            Parse::RecDescent::_tracefirst($text),
            q{ld_type},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{ld_type},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{ld_type},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{ld_type},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{ld_type},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::RIGHT
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"RIGHT"};

  Parse::RecDescent::_trace(q{Trying rule: [RIGHT]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{RIGHT},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/right/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{RIGHT},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{RIGHT});
    %item = (__RULE__ => q{RIGHT});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/right/i]}, Parse::RecDescent::_tracefirst($text),
            q{RIGHT},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:right)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/right/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{RIGHT},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{RIGHT},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{RIGHT},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{RIGHT},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{RIGHT},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_method_invocation
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule_method_invocation"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule_method_invocation]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_1_of_rule_method_invocation},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: ['(' expression ')']},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule_method_invocation},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule_method_invocation});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_method_invocation});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: ['(']},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_method_invocation},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\(//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;


    Parse::RecDescent::_trace(q{Trying repeated subrule: [expression]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_1_of_production_1_of_rule_method_invocation},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{expression})->at($text);

    unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::expression, 1, 100000000, $_noactions,$expectation,undef)))
    {
      Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [expression]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_1_of_production_1_of_rule_method_invocation},
              $tracelevel)
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched repeated subrule: [expression]<< (}
          . @$_tok . q{ times)},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_method_invocation},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{expression(s)}} = $_tok;
    push @item, $_tok;



    Parse::RecDescent::_trace(q{Trying terminal: [')']},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_method_invocation},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{')'})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING2__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: ['(' expression ')']<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_method_invocation},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_1_of_rule_method_invocation},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_1_of_rule_method_invocation},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_1_of_rule_method_invocation},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_1_of_rule_method_invocation},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::LEFT
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"LEFT"};

  Parse::RecDescent::_trace(q{Trying rule: [LEFT]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{LEFT},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/left/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{LEFT},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{LEFT});
    %item = (__RULE__ => q{LEFT});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/left/i]}, Parse::RecDescent::_tracefirst($text),
            q{LEFT},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:left)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/left/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{LEFT},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{LEFT},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{LEFT},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{LEFT},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{LEFT},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::table_name
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"table_name"};

  Parse::RecDescent::_trace(q{Trying rule: [table_name]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{table_name},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [SCHEMA '.' NAME]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{table_name},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{table_name});
    %item = (__RULE__ => q{table_name});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [SCHEMA]},
          Parse::RecDescent::_tracefirst($text),
          q{table_name},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::SCHEMA($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [SCHEMA]>>},
              Parse::RecDescent::_tracefirst($text),
              q{table_name},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [SCHEMA]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{table_name},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{SCHEMA}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: ['.']},
            Parse::RecDescent::_tracefirst($text),
            q{table_name},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{'.'})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\.//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [NAME]},
          Parse::RecDescent::_tracefirst($text),
          q{table_name},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{NAME})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::NAME($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [NAME]>>},
              Parse::RecDescent::_tracefirst($text),
              q{table_name},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [NAME]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{table_name},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{NAME}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying action},
            Parse::RecDescent::_tracefirst($text),
            q{table_name},
            $tracelevel)
            if defined $::RD_TRACE;


    $_tok = ($_noactions) ? 0 : do { $return = { schema => $item[1], name => $item[3] } };
    unless (defined $_tok)
    {
      Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
          if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
            . $_tok . q{])},
            Parse::RecDescent::_tracefirst($text))
            if defined $::RD_TRACE;
    push @item, $_tok;
    $item{__ACTION1__}=$_tok;



    Parse::RecDescent::_trace(q{>>Matched production: [SCHEMA '.' NAME]<<},
            Parse::RecDescent::_tracefirst($text),
            q{table_name},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [NAME]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{table_name},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{table_name});
    %item = (__RULE__ => q{table_name});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [NAME]},
          Parse::RecDescent::_tracefirst($text),
          q{table_name},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::NAME($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [NAME]>>},
              Parse::RecDescent::_tracefirst($text),
              q{table_name},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [NAME]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{table_name},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{NAME}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying action},
            Parse::RecDescent::_tracefirst($text),
            q{table_name},
            $tracelevel)
            if defined $::RD_TRACE;


    $_tok = ($_noactions) ? 0 : do { $return = { name => $item[1] } };
    unless (defined $_tok)
    {
      Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
          if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
            . $_tok . q{])},
            Parse::RecDescent::_tracefirst($text))
            if defined $::RD_TRACE;
    push @item, $_tok;
    $item{__ACTION1__}=$_tok;



    Parse::RecDescent::_trace(q{>>Matched production: [NAME]<<},
            Parse::RecDescent::_tracefirst($text),
            q{table_name},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{table_name},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{table_name},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{table_name},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{table_name},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_53_of_rule_sysfun
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_53_of_rule_sysfun"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_53_of_rule_sysfun]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_53_of_rule_sysfun},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/TRUNCATE/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_53_of_rule_sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_53_of_rule_sysfun});
    %item = (__RULE__ => q{_alternation_1_of_production_53_of_rule_sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/TRUNCATE/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_53_of_rule_sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:TRUNCATE)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/TRUNCATE/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_53_of_rule_sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/TRUNC/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_53_of_rule_sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_53_of_rule_sysfun});
    %item = (__RULE__ => q{_alternation_1_of_production_53_of_rule_sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/TRUNC/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_53_of_rule_sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:TRUNC)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/TRUNC/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_53_of_rule_sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_53_of_rule_sysfun},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_53_of_rule_sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_53_of_rule_sysfun},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_53_of_rule_sysfun},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::options
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"options"};

  Parse::RecDescent::_trace(q{Trying rule: [options]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{options},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/WITH/i /CASCADED/i, or /LOCAL/i /CHECK\\s+OPTION/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{options},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{options});
    %item = (__RULE__ => q{options});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/WITH/i]}, Parse::RecDescent::_tracefirst($text),
            q{options},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:WITH)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_1_of_rule_options]},
          Parse::RecDescent::_tracefirst($text),
          q{options},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{/CASCADED/i, or /LOCAL/i})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_options($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_1_of_rule_options]>>},
              Parse::RecDescent::_tracefirst($text),
              q{options},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_1_of_rule_options]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{options},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_1_of_rule_options}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: [/CHECK\\s+OPTION/i]}, Parse::RecDescent::_tracefirst($text),
            q{options},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/CHECK\\s+OPTION/i})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:CHECK\s+OPTION)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN2__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/WITH/i /CASCADED/i, or /LOCAL/i /CHECK\\s+OPTION/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{options},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{options},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{options},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{options},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{options},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::function
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"function"};

  Parse::RecDescent::_trace(q{Trying rule: [function]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{function},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/SYSIBM\\.|/i, or /SYSFUN\\.|/i, or userdefined_function '(' <leftop: func_args /,/ func_args> ')']},
            Parse::RecDescent::_tracefirst($_[1]),
            q{function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{function});
    %item = (__RULE__ => q{function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_1_of_rule_function]},
          Parse::RecDescent::_tracefirst($text),
          q{function},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_function($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_1_of_rule_function]>>},
              Parse::RecDescent::_tracefirst($text),
              q{function},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_1_of_rule_function]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{function},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_1_of_rule_function}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: ['(']},
            Parse::RecDescent::_tracefirst($text),
            q{function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{'('})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\(//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;


    Parse::RecDescent::_trace(q{Trying operator: [<leftop: func_args /,/ func_args>]},
          Parse::RecDescent::_tracefirst($text),
          q{function},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{<leftop: func_args /,/ func_args>})->at($text);

    $_tok = undef;
    OPLOOP: while (1)
    {
      $repcount = 0;
      my  @item;

      # MATCH LEFTARG

    Parse::RecDescent::_trace(q{Trying subrule: [func_args]},
          Parse::RecDescent::_tracefirst($text),
          q{function},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{func_args})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::func_args($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [func_args]>>},
              Parse::RecDescent::_tracefirst($text),
              q{function},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [func_args]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{function},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{func_args}} = $_tok;
    push @item, $_tok;

    }


      $repcount++;

      my $savetext = $text;
      my $backtrack;

      # MATCH (OP RIGHTARG)(s)
      while ($repcount < 100000000)
      {
      $backtrack = 0;

    Parse::RecDescent::_trace(q{Trying terminal: [/,/]}, Parse::RecDescent::_tracefirst($text),
            q{function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/,/})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:,)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


      pop @item;
      if (defined $1) {push @item, $item{'func_args(s)'}=$1; $backtrack=1;}

    Parse::RecDescent::_trace(q{Trying subrule: [func_args]},
          Parse::RecDescent::_tracefirst($text),
          q{function},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{func_args})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::func_args($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [func_args]>>},
              Parse::RecDescent::_tracefirst($text),
              q{function},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [func_args]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{function},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{func_args}} = $_tok;
    push @item, $_tok;

    }

      $savetext = $text;
      $repcount++;
      }
      $text = $savetext;
      pop @item if $backtrack;

      unless (@item) { undef $_tok; last }
      $_tok = [ @item ];
      last;
    }

    unless ($repcount>=1)
    {
      Parse::RecDescent::_trace(q{<<Didn't match operator: [<leftop: func_args /,/ func_args>]>>},
              Parse::RecDescent::_tracefirst($text),
              q{function},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched operator: [<leftop: func_args /,/ func_args>]<< (return value: [}
            . qq{@{$_tok||[]}} . q{]},
            Parse::RecDescent::_tracefirst($text),
            q{function},
            $tracelevel)
            if defined $::RD_TRACE;

    push @item, $item{'func_args(s)'}=$_tok||[];


    Parse::RecDescent::_trace(q{Trying terminal: [')']},
            Parse::RecDescent::_tracefirst($text),
            q{function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{')'})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING2__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/SYSIBM\\.|/i, or /SYSFUN\\.|/i, or userdefined_function '(' <leftop: func_args /,/ func_args> ')']<<},
            Parse::RecDescent::_tracefirst($text),
            q{function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{function},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{function},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{function},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{function},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_41_of_rule_sysibm_function
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_41_of_rule_sysibm_function"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_41_of_rule_sysibm_function]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_41_of_rule_sysibm_function},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/INTEGER/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_41_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_41_of_rule_sysibm_function});
    %item = (__RULE__ => q{_alternation_1_of_production_41_of_rule_sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/INTEGER/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_41_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:INTEGER)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/INTEGER/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_41_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/INT/]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_41_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_41_of_rule_sysibm_function});
    %item = (__RULE__ => q{_alternation_1_of_production_41_of_rule_sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/INT/]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_41_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:INT)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/INT/]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_41_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_41_of_rule_sysibm_function},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_41_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_41_of_rule_sysibm_function},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_41_of_rule_sysibm_function},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_case_expression
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule_case_expression"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule_case_expression]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_1_of_rule_case_expression},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [searched_when_clause]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule_case_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule_case_expression});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_case_expression});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [searched_when_clause]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_1_of_production_1_of_rule_case_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::searched_when_clause($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [searched_when_clause]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_1_of_production_1_of_rule_case_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [searched_when_clause]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_case_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{searched_when_clause}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [searched_when_clause]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_case_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [simple_when_clause]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule_case_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule_case_expression});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_case_expression});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [simple_when_clause]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_1_of_production_1_of_rule_case_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::simple_when_clause($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [simple_when_clause]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_1_of_production_1_of_rule_case_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [simple_when_clause]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_case_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{simple_when_clause}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [simple_when_clause]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_case_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_1_of_rule_case_expression},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_1_of_rule_case_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_1_of_rule_case_expression},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_1_of_rule_case_expression},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_window_order_clause
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule_window_order_clause"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule_window_order_clause]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_1_of_rule_window_order_clause},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [sort_key_expression asc_option, or desc_option]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule_window_order_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule_window_order_clause});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_window_order_clause});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [sort_key_expression]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_1_of_production_1_of_rule_window_order_clause},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::sort_key_expression($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [sort_key_expression]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_1_of_production_1_of_rule_window_order_clause},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [sort_key_expression]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_window_order_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{sort_key_expression}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying repeated subrule: [asc_option, or desc_option]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_1_of_production_1_of_rule_window_order_clause},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{asc_option, or desc_option})->at($text);

    unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_window_order_clause, 0, 1, $_noactions,$expectation,undef)))
    {
      Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [asc_option, or desc_option]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_1_of_production_1_of_rule_window_order_clause},
              $tracelevel)
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched repeated subrule: [_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_window_order_clause]<< (}
          . @$_tok . q{ times)},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_window_order_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_window_order_clause(?)}} = $_tok;
    push @item, $_tok;




    Parse::RecDescent::_trace(q{>>Matched production: [sort_key_expression asc_option, or desc_option]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_window_order_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_1_of_rule_window_order_clause},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_1_of_rule_window_order_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_1_of_rule_window_order_clause},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_1_of_rule_window_order_clause},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::create
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"create"};

  Parse::RecDescent::_trace(q{Trying rule: [create]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{create},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [CREATE TRIGGER trigger_name before type /ON/i table_name reference_b /FOR EACH ROW/i 'MODE DB2SQL' triggered_action]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{create});
    %item = (__RULE__ => q{create});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [CREATE]},
          Parse::RecDescent::_tracefirst($text),
          q{create},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::CREATE($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [CREATE]>>},
              Parse::RecDescent::_tracefirst($text),
              q{create},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [CREATE]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{CREATE}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying subrule: [TRIGGER]},
          Parse::RecDescent::_tracefirst($text),
          q{create},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{TRIGGER})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::TRIGGER($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [TRIGGER]>>},
              Parse::RecDescent::_tracefirst($text),
              q{create},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [TRIGGER]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{TRIGGER}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying subrule: [trigger_name]},
          Parse::RecDescent::_tracefirst($text),
          q{create},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{trigger_name})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::trigger_name($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [trigger_name]>>},
              Parse::RecDescent::_tracefirst($text),
              q{create},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [trigger_name]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{trigger_name}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying subrule: [before]},
          Parse::RecDescent::_tracefirst($text),
          q{create},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{before})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::before($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [before]>>},
              Parse::RecDescent::_tracefirst($text),
              q{create},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [before]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{before}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying subrule: [type]},
          Parse::RecDescent::_tracefirst($text),
          q{create},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{type})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::type($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [type]>>},
              Parse::RecDescent::_tracefirst($text),
              q{create},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [type]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{type}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: [/ON/i]}, Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/ON/i})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:ON)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [table_name]},
          Parse::RecDescent::_tracefirst($text),
          q{create},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{table_name})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::table_name($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [table_name]>>},
              Parse::RecDescent::_tracefirst($text),
              q{create},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [table_name]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{table_name}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying repeated subrule: [reference_b]},
          Parse::RecDescent::_tracefirst($text),
          q{create},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{reference_b})->at($text);

    unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::reference_b, 0, 1, $_noactions,$expectation,undef)))
    {
      Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [reference_b]>>},
              Parse::RecDescent::_tracefirst($text),
              q{create},
              $tracelevel)
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched repeated subrule: [reference_b]<< (}
          . @$_tok . q{ times)},

            Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{reference_b(?)}} = $_tok;
    push @item, $_tok;



    Parse::RecDescent::_trace(q{Trying terminal: [/FOR EACH ROW/i]}, Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/FOR EACH ROW/i})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:FOR EACH ROW)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN2__}=$&;


    Parse::RecDescent::_trace(q{Trying terminal: ['MODE DB2SQL']},
            Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{'MODE DB2SQL'})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\AMODE\ DB2SQL//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [triggered_action]},
          Parse::RecDescent::_tracefirst($text),
          q{create},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{triggered_action})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::triggered_action($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [triggered_action]>>},
              Parse::RecDescent::_tracefirst($text),
              q{create},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [triggered_action]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{triggered_action}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying action},
            Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;


    $_tok = ($_noactions) ? 0 : do {
    my $table_name = $item{'table_name'}{'name'};
    $return =  {
        table      => $table_name,
        schema     => $item{'trigger_name'}{'schema'},
        name       => $item{'trigger_name'}{'name'},
        when       => 'before',
        db_event   => $item{'type'}->{'event'},
        fields     => $item{'type'}{'fields'},
        condition  => $item{'triggered_action'}{'condition'},
        reference  => $item{'reference_b'},
        granularity => $item[9],
        action     => $item{'triggered_action'}{'statement'}
    };

    push @triggers, $return;
};
    unless (defined $_tok)
    {
      Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
          if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
            . $_tok . q{])},
            Parse::RecDescent::_tracefirst($text))
            if defined $::RD_TRACE;
    push @item, $_tok;
    $item{__ACTION1__}=$_tok;



    Parse::RecDescent::_trace(q{>>Matched production: [CREATE TRIGGER trigger_name before type /ON/i table_name reference_b /FOR EACH ROW/i 'MODE DB2SQL' triggered_action]<<},
            Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [CREATE TRIGGER trigger_name after type /ON/i table_name reference_a /FOR EACH ROW|FOR EACH STATEMENT/i 'MODE DB2SQL' triggered_action]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{create});
    %item = (__RULE__ => q{create});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [CREATE]},
          Parse::RecDescent::_tracefirst($text),
          q{create},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::CREATE($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [CREATE]>>},
              Parse::RecDescent::_tracefirst($text),
              q{create},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [CREATE]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{CREATE}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying subrule: [TRIGGER]},
          Parse::RecDescent::_tracefirst($text),
          q{create},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{TRIGGER})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::TRIGGER($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [TRIGGER]>>},
              Parse::RecDescent::_tracefirst($text),
              q{create},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [TRIGGER]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{TRIGGER}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying subrule: [trigger_name]},
          Parse::RecDescent::_tracefirst($text),
          q{create},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{trigger_name})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::trigger_name($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [trigger_name]>>},
              Parse::RecDescent::_tracefirst($text),
              q{create},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [trigger_name]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{trigger_name}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying subrule: [after]},
          Parse::RecDescent::_tracefirst($text),
          q{create},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{after})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::after($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [after]>>},
              Parse::RecDescent::_tracefirst($text),
              q{create},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [after]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{after}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying subrule: [type]},
          Parse::RecDescent::_tracefirst($text),
          q{create},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{type})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::type($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [type]>>},
              Parse::RecDescent::_tracefirst($text),
              q{create},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [type]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{type}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: [/ON/i]}, Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/ON/i})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:ON)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [table_name]},
          Parse::RecDescent::_tracefirst($text),
          q{create},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{table_name})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::table_name($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [table_name]>>},
              Parse::RecDescent::_tracefirst($text),
              q{create},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [table_name]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{table_name}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying repeated subrule: [reference_a]},
          Parse::RecDescent::_tracefirst($text),
          q{create},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{reference_a})->at($text);

    unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::reference_a, 0, 1, $_noactions,$expectation,undef)))
    {
      Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [reference_a]>>},
              Parse::RecDescent::_tracefirst($text),
              q{create},
              $tracelevel)
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched repeated subrule: [reference_a]<< (}
          . @$_tok . q{ times)},

            Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{reference_a(?)}} = $_tok;
    push @item, $_tok;



    Parse::RecDescent::_trace(q{Trying terminal: [/FOR EACH ROW|FOR EACH STATEMENT/i]}, Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/FOR EACH ROW|FOR EACH STATEMENT/i})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:FOR EACH ROW|FOR EACH STATEMENT)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN2__}=$&;


    Parse::RecDescent::_trace(q{Trying terminal: ['MODE DB2SQL']},
            Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{'MODE DB2SQL'})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\AMODE\ DB2SQL//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [triggered_action]},
          Parse::RecDescent::_tracefirst($text),
          q{create},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{triggered_action})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::triggered_action($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [triggered_action]>>},
              Parse::RecDescent::_tracefirst($text),
              q{create},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [triggered_action]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{triggered_action}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying action},
            Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;


    $_tok = ($_noactions) ? 0 : do {
    my $table_name = $item{'table_name'}{'name'};
    $return = {
        table      => $table_name,
        schema     => $item{'trigger_name'}{'schema'},
        name       => $item{'trigger_name'}{'name'},
        when       => 'after',
        db_event   => $item{'type'}{'event'},
        fields     => $item{'type'}{'fields'},
        condition  => $item{'triggered_action'}{'condition'},
        reference  => $item{'reference_a'},
        granularity => $item[9],
        action     => $item{'triggered_action'}{'statement'}
    };

    push @triggers, $return;
};
    unless (defined $_tok)
    {
      Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
          if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
            . $_tok . q{])},
            Parse::RecDescent::_tracefirst($text))
            if defined $::RD_TRACE;
    push @item, $_tok;
    $item{__ACTION1__}=$_tok;



    Parse::RecDescent::_trace(q{>>Matched production: [CREATE TRIGGER trigger_name after type /ON/i table_name reference_a /FOR EACH ROW|FOR EACH STATEMENT/i 'MODE DB2SQL' triggered_action]<<},
            Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [CREATE /FEDERATED|/i VIEW view_name column_list /AS/i with_expression SQL_procedure_statement]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[2];
    $text = $_[1];
    my $_savetext;
    @item = (q{create});
    %item = (__RULE__ => q{create});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [CREATE]},
          Parse::RecDescent::_tracefirst($text),
          q{create},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::CREATE($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [CREATE]>>},
              Parse::RecDescent::_tracefirst($text),
              q{create},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [CREATE]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{CREATE}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: [/FEDERATED|/i]}, Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/FEDERATED|/i})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:FEDERATED|)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [VIEW]},
          Parse::RecDescent::_tracefirst($text),
          q{create},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{VIEW})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::VIEW($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [VIEW]>>},
              Parse::RecDescent::_tracefirst($text),
              q{create},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [VIEW]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{VIEW}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying subrule: [view_name]},
          Parse::RecDescent::_tracefirst($text),
          q{create},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{view_name})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::view_name($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [view_name]>>},
              Parse::RecDescent::_tracefirst($text),
              q{create},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [view_name]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{view_name}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying repeated subrule: [column_list]},
          Parse::RecDescent::_tracefirst($text),
          q{create},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{column_list})->at($text);

    unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::column_list, 0, 1, $_noactions,$expectation,undef)))
    {
      Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [column_list]>>},
              Parse::RecDescent::_tracefirst($text),
              q{create},
              $tracelevel)
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched repeated subrule: [column_list]<< (}
          . @$_tok . q{ times)},

            Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{column_list(?)}} = $_tok;
    push @item, $_tok;



    Parse::RecDescent::_trace(q{Trying terminal: [/AS/i]}, Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/AS/i})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:AS)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN2__}=$&;


    Parse::RecDescent::_trace(q{Trying repeated subrule: [with_expression]},
          Parse::RecDescent::_tracefirst($text),
          q{create},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{with_expression})->at($text);

    unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::with_expression, 0, 1, $_noactions,$expectation,undef)))
    {
      Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [with_expression]>>},
              Parse::RecDescent::_tracefirst($text),
              q{create},
              $tracelevel)
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched repeated subrule: [with_expression]<< (}
          . @$_tok . q{ times)},

            Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{with_expression(?)}} = $_tok;
    push @item, $_tok;



    Parse::RecDescent::_trace(q{Trying subrule: [SQL_procedure_statement]},
          Parse::RecDescent::_tracefirst($text),
          q{create},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{SQL_procedure_statement})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::SQL_procedure_statement($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [SQL_procedure_statement]>>},
              Parse::RecDescent::_tracefirst($text),
              q{create},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [SQL_procedure_statement]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{SQL_procedure_statement}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying action},
            Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;


    $_tok = ($_noactions) ? 0 : do {
    $return = {
        name   => $item{view_name}{name},
        sql    => $item{SQL_procedure_statement},
        with   => $item{'with_expression(?)'},
        fields => $item{'column_list(?)'}
    };
    push @views, $return;
};
    unless (defined $_tok)
    {
      Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
          if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
            . $_tok . q{])},
            Parse::RecDescent::_tracefirst($text))
            if defined $::RD_TRACE;
    push @item, $_tok;
    $item{__ACTION1__}=$_tok;



    Parse::RecDescent::_trace(q{>>Matched production: [CREATE /FEDERATED|/i VIEW view_name column_list /AS/i with_expression SQL_procedure_statement]<<},
            Parse::RecDescent::_tracefirst($text),
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{create},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{create},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{create},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{create},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::sysfun
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"sysfun"};

  Parse::RecDescent::_trace(q{Trying rule: [sysfun]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{sysfun},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/ABS/i, or /ABSVAL/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_1_of_rule_sysfun]},
          Parse::RecDescent::_tracefirst($text),
          q{sysfun},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_sysfun($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_1_of_rule_sysfun]>>},
              Parse::RecDescent::_tracefirst($text),
              q{sysfun},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_1_of_rule_sysfun]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_1_of_rule_sysfun}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [/ABS/i, or /ABSVAL/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/ACOS/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/ACOS/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:ACOS)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/ACOS/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/ASCII/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[2];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/ASCII/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:ASCII)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/ASCII/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/ASIN/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[3];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/ASIN/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:ASIN)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/ASIN/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/ATAN/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[4];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/ATAN/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:ATAN)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/ATAN/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/ATAN2/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[5];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/ATAN2/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:ATAN2)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/ATAN2/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/CEIL/i, or /CEILING/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[6];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_7_of_rule_sysfun]},
          Parse::RecDescent::_tracefirst($text),
          q{sysfun},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_7_of_rule_sysfun($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_7_of_rule_sysfun]>>},
              Parse::RecDescent::_tracefirst($text),
              q{sysfun},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_7_of_rule_sysfun]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_7_of_rule_sysfun}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [/CEIL/i, or /CEILING/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/CHAR/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[7];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/CHAR/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:CHAR)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/CHAR/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/CHR/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[8];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/CHR/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:CHR)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/CHR/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/COS/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[9];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/COS/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:COS)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/COS/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/COT/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[10];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/COT/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:COT)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/COT/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/DAYNAME/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[11];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/DAYNAME/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:DAYNAME)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/DAYNAME/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/DAYOFWEEK/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[12];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/DAYOFWEEK/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:DAYOFWEEK)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/DAYOFWEEK/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/DAYOFWEEK_ISO/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[13];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/DAYOFWEEK_ISO/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:DAYOFWEEK_ISO)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/DAYOFWEEK_ISO/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/DAYOFYEAR/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[14];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/DAYOFYEAR/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:DAYOFYEAR)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/DAYOFYEAR/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/DEGREES/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[15];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/DEGREES/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:DEGREES)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/DEGREES/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/DIFFERENCE/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[16];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/DIFFERENCE/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:DIFFERENCE)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/DIFFERENCE/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/DOUBLE/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[17];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/DOUBLE/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:DOUBLE)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/DOUBLE/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/EXP/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[18];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/EXP/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:EXP)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/EXP/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/FLOOR/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[19];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/FLOOR/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:FLOOR)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/FLOOR/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/GET_ROUTINE_SAR/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[20];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/GET_ROUTINE_SAR/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:GET_ROUTINE_SAR)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/GET_ROUTINE_SAR/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/INSERT/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[21];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/INSERT/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:INSERT)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/INSERT/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/JULIAN_DAY/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[22];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/JULIAN_DAY/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:JULIAN_DAY)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/JULIAN_DAY/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/LCASE/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[23];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/LCASE/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:LCASE)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/LCASE/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/LEFT/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[24];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/LEFT/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:LEFT)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/LEFT/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/LN/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[25];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/LN/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:LN)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/LN/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/LOCATE/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[26];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/LOCATE/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:LOCATE)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/LOCATE/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/LOG/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[27];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/LOG/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:LOG)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/LOG/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/LOG10/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[28];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/LOG10/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:LOG10)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/LOG10/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/LTRIM/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[29];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/LTRIM/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:LTRIM)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/LTRIM/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/MIDNIGHT_SECONDS/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[30];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/MIDNIGHT_SECONDS/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:MIDNIGHT_SECONDS)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/MIDNIGHT_SECONDS/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/MOD/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[31];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/MOD/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:MOD)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/MOD/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/MONTHNAME/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[32];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/MONTHNAME/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:MONTHNAME)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/MONTHNAME/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/POWER/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[33];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/POWER/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:POWER)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/POWER/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/PUT_ROUTINE_SAR/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[34];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/PUT_ROUTINE_SAR/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:PUT_ROUTINE_SAR)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/PUT_ROUTINE_SAR/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/QUARTER/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[35];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/QUARTER/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:QUARTER)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/QUARTER/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/RADIANS/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[36];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/RADIANS/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:RADIANS)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/RADIANS/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/RAND/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[37];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/RAND/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:RAND)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/RAND/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/REPEAT/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[38];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/REPEAT/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:REPEAT)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/REPEAT/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/REPLACE/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[39];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/REPLACE/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:REPLACE)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/REPLACE/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/RIGHT/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[40];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/RIGHT/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:RIGHT)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/RIGHT/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/ROUND/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[41];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/ROUND/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:ROUND)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/ROUND/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/RTRIM/ I]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[42];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/RTRIM/]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:RTRIM)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [I]},
          Parse::RecDescent::_tracefirst($text),
          q{sysfun},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{I})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::I($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [I]>>},
              Parse::RecDescent::_tracefirst($text),
              q{sysfun},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [I]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{I}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [/RTRIM/ I]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/SIGN/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[43];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/SIGN/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:SIGN)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/SIGN/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/SIN/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[44];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/SIN/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:SIN)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/SIN/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/SOUNDEX/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[45];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/SOUNDEX/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:SOUNDEX)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/SOUNDEX/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/SPACE/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[46];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/SPACE/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:SPACE)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/SPACE/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/SQLCACHE_SNAPSHOT/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[47];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/SQLCACHE_SNAPSHOT/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:SQLCACHE_SNAPSHOT)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/SQLCACHE_SNAPSHOT/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/SQRT/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[48];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/SQRT/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:SQRT)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/SQRT/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/TAN/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[49];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/TAN/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:TAN)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/TAN/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/TIMESTAMP_ISO/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[50];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/TIMESTAMP_ISO/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:TIMESTAMP_ISO)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/TIMESTAMP_ISO/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/TIMESTAMPDIFF/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[51];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/TIMESTAMPDIFF/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:TIMESTAMPDIFF)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/TIMESTAMPDIFF/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/TRUNCATE/i, or /TRUNC/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[52];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_53_of_rule_sysfun]},
          Parse::RecDescent::_tracefirst($text),
          q{sysfun},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_53_of_rule_sysfun($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_53_of_rule_sysfun]>>},
              Parse::RecDescent::_tracefirst($text),
              q{sysfun},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_53_of_rule_sysfun]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_53_of_rule_sysfun}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [/TRUNCATE/i, or /TRUNC/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/UCASE/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[53];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/UCASE/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:UCASE)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/UCASE/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/WEEK/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[54];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/WEEK/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:WEEK)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/WEEK/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/WEEK_ISO/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[55];
    $text = $_[1];
    my $_savetext;
    @item = (q{sysfun});
    %item = (__RULE__ => q{sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/WEEK_ISO/i]}, Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:WEEK_ISO)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/WEEK_ISO/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{sysfun},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{sysfun},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{sysfun},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cond
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cond"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cond]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cond},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/SELECTIVITY/i numeric_constant]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cond},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cond});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cond});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/SELECTIVITY/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cond},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:SELECTIVITY)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [numeric_constant]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cond},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{numeric_constant})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::numeric_constant($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [numeric_constant]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cond},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [numeric_constant]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cond},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{numeric_constant}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [/SELECTIVITY/i numeric_constant]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cond},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cond},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cond},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cond},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cond},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::NAME
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"NAME"};

  Parse::RecDescent::_trace(q{Trying rule: [NAME]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{NAME},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/\\w+/]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{NAME},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{NAME});
    %item = (__RULE__ => q{NAME});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/\\w+/]}, Parse::RecDescent::_tracefirst($text),
            q{NAME},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:\w+)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/\\w+/]<<},
            Parse::RecDescent::_tracefirst($text),
            q{NAME},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/\\w\{1,18\}/]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{NAME},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{NAME});
    %item = (__RULE__ => q{NAME});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/\\w\{1,18\}/]}, Parse::RecDescent::_tracefirst($text),
            q{NAME},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:\w{1,18})//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/\\w\{1,18\}/]<<},
            Parse::RecDescent::_tracefirst($text),
            q{NAME},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{NAME},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{NAME},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{NAME},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{NAME},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::constant
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"constant"};

  Parse::RecDescent::_trace(q{Trying rule: [constant]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{constant},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [int_const]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{constant},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{constant});
    %item = (__RULE__ => q{constant});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [int_const]},
          Parse::RecDescent::_tracefirst($text),
          q{constant},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::int_const($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [int_const]>>},
              Parse::RecDescent::_tracefirst($text),
              q{constant},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [int_const]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{constant},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{int_const}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [int_const]<<},
            Parse::RecDescent::_tracefirst($text),
            q{constant},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [float_const]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{constant},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{constant});
    %item = (__RULE__ => q{constant});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [float_const]},
          Parse::RecDescent::_tracefirst($text),
          q{constant},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::float_const($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [float_const]>>},
              Parse::RecDescent::_tracefirst($text),
              q{constant},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [float_const]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{constant},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{float_const}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [float_const]<<},
            Parse::RecDescent::_tracefirst($text),
            q{constant},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [dec_const]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{constant},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[2];
    $text = $_[1];
    my $_savetext;
    @item = (q{constant});
    %item = (__RULE__ => q{constant});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [dec_const]},
          Parse::RecDescent::_tracefirst($text),
          q{constant},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::dec_const($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [dec_const]>>},
              Parse::RecDescent::_tracefirst($text),
              q{constant},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [dec_const]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{constant},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{dec_const}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [dec_const]<<},
            Parse::RecDescent::_tracefirst($text),
            q{constant},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [char_const]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{constant},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[3];
    $text = $_[1];
    my $_savetext;
    @item = (q{constant});
    %item = (__RULE__ => q{constant});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [char_const]},
          Parse::RecDescent::_tracefirst($text),
          q{constant},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::char_const($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [char_const]>>},
              Parse::RecDescent::_tracefirst($text),
              q{constant},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [char_const]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{constant},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{char_const}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [char_const]<<},
            Parse::RecDescent::_tracefirst($text),
            q{constant},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [hex_const]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{constant},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[4];
    $text = $_[1];
    my $_savetext;
    @item = (q{constant});
    %item = (__RULE__ => q{constant});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [hex_const]},
          Parse::RecDescent::_tracefirst($text),
          q{constant},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::hex_const($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [hex_const]>>},
              Parse::RecDescent::_tracefirst($text),
              q{constant},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [hex_const]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{constant},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{hex_const}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [hex_const]<<},
            Parse::RecDescent::_tracefirst($text),
            q{constant},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [grastr_const]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{constant},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[5];
    $text = $_[1];
    my $_savetext;
    @item = (q{constant});
    %item = (__RULE__ => q{constant});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [grastr_const]},
          Parse::RecDescent::_tracefirst($text),
          q{constant},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::grastr_const($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [grastr_const]>>},
              Parse::RecDescent::_tracefirst($text),
              q{constant},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [grastr_const]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{constant},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{grastr_const}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [grastr_const]<<},
            Parse::RecDescent::_tracefirst($text),
            q{constant},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{constant},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{constant},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{constant},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{constant},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_ranking_function
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule_ranking_function"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule_ranking_function]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_1_of_rule_ranking_function},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/RANK/ '()']},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule_ranking_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule_ranking_function});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_ranking_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/RANK/]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_ranking_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:RANK)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying terminal: ['()']},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_ranking_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{'()'})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\(\)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/RANK/ '()']<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_ranking_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/DENSE_RANK|DENSERANK/i '()']},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule_ranking_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule_ranking_function});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_ranking_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/DENSE_RANK|DENSERANK/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_ranking_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:DENSE_RANK|DENSERANK)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying terminal: ['()']},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_ranking_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{'()'})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\(\)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/DENSE_RANK|DENSERANK/i '()']<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_ranking_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_1_of_rule_ranking_function},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_1_of_rule_ranking_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_1_of_rule_ranking_function},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_1_of_rule_ranking_function},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::window_aggregation_group_clause
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"window_aggregation_group_clause"};

  Parse::RecDescent::_trace(q{Trying rule: [window_aggregation_group_clause]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{window_aggregation_group_clause},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/ROWS/i, or /RANGE/i group_start, or group_between, or group_end]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{window_aggregation_group_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{window_aggregation_group_clause});
    %item = (__RULE__ => q{window_aggregation_group_clause});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_1_of_rule_window_aggregation_group_clause]},
          Parse::RecDescent::_tracefirst($text),
          q{window_aggregation_group_clause},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_window_aggregation_group_clause($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_1_of_rule_window_aggregation_group_clause]>>},
              Parse::RecDescent::_tracefirst($text),
              q{window_aggregation_group_clause},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_1_of_rule_window_aggregation_group_clause]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{window_aggregation_group_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_1_of_rule_window_aggregation_group_clause}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_2_of_production_1_of_rule_window_aggregation_group_clause]},
          Parse::RecDescent::_tracefirst($text),
          q{window_aggregation_group_clause},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{group_start, or group_between, or group_end})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_2_of_production_1_of_rule_window_aggregation_group_clause($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_2_of_production_1_of_rule_window_aggregation_group_clause]>>},
              Parse::RecDescent::_tracefirst($text),
              q{window_aggregation_group_clause},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_2_of_production_1_of_rule_window_aggregation_group_clause]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{window_aggregation_group_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_2_of_production_1_of_rule_window_aggregation_group_clause}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [/ROWS/i, or /RANGE/i group_start, or group_between, or group_end]<<},
            Parse::RecDescent::_tracefirst($text),
            q{window_aggregation_group_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{window_aggregation_group_clause},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{window_aggregation_group_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{window_aggregation_group_clause},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{window_aggregation_group_clause},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_2_of_production_1_of_rule_window_aggregation_group_clause
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_2_of_production_1_of_rule_window_aggregation_group_clause"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_2_of_production_1_of_rule_window_aggregation_group_clause]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_2_of_production_1_of_rule_window_aggregation_group_clause},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [group_start]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_2_of_production_1_of_rule_window_aggregation_group_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_2_of_production_1_of_rule_window_aggregation_group_clause});
    %item = (__RULE__ => q{_alternation_2_of_production_1_of_rule_window_aggregation_group_clause});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [group_start]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_2_of_production_1_of_rule_window_aggregation_group_clause},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::group_start($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [group_start]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_2_of_production_1_of_rule_window_aggregation_group_clause},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [group_start]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule_window_aggregation_group_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{group_start}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [group_start]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule_window_aggregation_group_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [group_between]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_2_of_production_1_of_rule_window_aggregation_group_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_2_of_production_1_of_rule_window_aggregation_group_clause});
    %item = (__RULE__ => q{_alternation_2_of_production_1_of_rule_window_aggregation_group_clause});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [group_between]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_2_of_production_1_of_rule_window_aggregation_group_clause},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::group_between($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [group_between]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_2_of_production_1_of_rule_window_aggregation_group_clause},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [group_between]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule_window_aggregation_group_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{group_between}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [group_between]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule_window_aggregation_group_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [group_end]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_2_of_production_1_of_rule_window_aggregation_group_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[2];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_2_of_production_1_of_rule_window_aggregation_group_clause});
    %item = (__RULE__ => q{_alternation_2_of_production_1_of_rule_window_aggregation_group_clause});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [group_end]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_2_of_production_1_of_rule_window_aggregation_group_clause},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::group_end($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [group_end]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_2_of_production_1_of_rule_window_aggregation_group_clause},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [group_end]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule_window_aggregation_group_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{group_end}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [group_end]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule_window_aggregation_group_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_2_of_production_1_of_rule_window_aggregation_group_clause},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_2_of_production_1_of_rule_window_aggregation_group_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_2_of_production_1_of_rule_window_aggregation_group_clause},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_2_of_production_1_of_rule_window_aggregation_group_clause},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::VIEW
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"VIEW"};

  Parse::RecDescent::_trace(q{Trying rule: [VIEW]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{VIEW},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/view/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{VIEW},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{VIEW});
    %item = (__RULE__ => q{VIEW});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/view/i]}, Parse::RecDescent::_tracefirst($text),
            q{VIEW},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:view)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/view/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{VIEW},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{VIEW},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{VIEW},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{VIEW},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{VIEW},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::with_expression
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"with_expression"};

  Parse::RecDescent::_trace(q{Trying rule: [with_expression]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{with_expression},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/WITH/i <leftop: common_table_expression /,/ common_table_expression>]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{with_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{with_expression});
    %item = (__RULE__ => q{with_expression});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/WITH/i]}, Parse::RecDescent::_tracefirst($text),
            q{with_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:WITH)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying operator: [<leftop: common_table_expression /,/ common_table_expression>]},
          Parse::RecDescent::_tracefirst($text),
          q{with_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{<leftop: common_table_expression /,/ common_table_expression>})->at($text);

    $_tok = undef;
    OPLOOP: while (1)
    {
      $repcount = 0;
      my  @item;

      # MATCH LEFTARG

    Parse::RecDescent::_trace(q{Trying subrule: [common_table_expression]},
          Parse::RecDescent::_tracefirst($text),
          q{with_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{common_table_expression})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::common_table_expression($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [common_table_expression]>>},
              Parse::RecDescent::_tracefirst($text),
              q{with_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [common_table_expression]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{with_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{common_table_expression}} = $_tok;
    push @item, $_tok;

    }


      $repcount++;

      my $savetext = $text;
      my $backtrack;

      # MATCH (OP RIGHTARG)(s)
      while ($repcount < 100000000)
      {
      $backtrack = 0;

    Parse::RecDescent::_trace(q{Trying terminal: [/,/]}, Parse::RecDescent::_tracefirst($text),
            q{with_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/,/})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:,)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN2__}=$&;


      pop @item;
      if (defined $1) {push @item, $item{'common_table_expression(s)'}=$1; $backtrack=1;}

    Parse::RecDescent::_trace(q{Trying subrule: [common_table_expression]},
          Parse::RecDescent::_tracefirst($text),
          q{with_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{common_table_expression})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::common_table_expression($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [common_table_expression]>>},
              Parse::RecDescent::_tracefirst($text),
              q{with_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [common_table_expression]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{with_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{common_table_expression}} = $_tok;
    push @item, $_tok;

    }

      $savetext = $text;
      $repcount++;
      }
      $text = $savetext;
      pop @item if $backtrack;

      unless (@item) { undef $_tok; last }
      $_tok = [ @item ];
      last;
    }

    unless ($repcount>=1)
    {
      Parse::RecDescent::_trace(q{<<Didn't match operator: [<leftop: common_table_expression /,/ common_table_expression>]>>},
              Parse::RecDescent::_tracefirst($text),
              q{with_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched operator: [<leftop: common_table_expression /,/ common_table_expression>]<< (return value: [}
            . qq{@{$_tok||[]}} . q{]},
            Parse::RecDescent::_tracefirst($text),
            q{with_expression},
            $tracelevel)
            if defined $::RD_TRACE;

    push @item, $item{'common_table_expression(s)'}=$_tok||[];


    Parse::RecDescent::_trace(q{Trying action},
            Parse::RecDescent::_tracefirst($text),
            q{with_expression},
            $tracelevel)
            if defined $::RD_TRACE;


    $_tok = ($_noactions) ? 0 : do {
    $return = $item{'common_table_expression'};
};
    unless (defined $_tok)
    {
      Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
          if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
            . $_tok . q{])},
            Parse::RecDescent::_tracefirst($text))
            if defined $::RD_TRACE;
    push @item, $_tok;
    $item{__ACTION1__}=$_tok;



    Parse::RecDescent::_trace(q{>>Matched production: [/WITH/i <leftop: common_table_expression /,/ common_table_expression>]<<},
            Parse::RecDescent::_tracefirst($text),
            q{with_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{with_expression},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{with_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{with_expression},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{with_expression},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::numeric_constant
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"numeric_constant"};

  Parse::RecDescent::_trace(q{Trying rule: [numeric_constant]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{numeric_constant},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/\\d+/]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{numeric_constant},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{numeric_constant});
    %item = (__RULE__ => q{numeric_constant});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/\\d+/]}, Parse::RecDescent::_tracefirst($text),
            q{numeric_constant},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:\d+)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/\\d+/]<<},
            Parse::RecDescent::_tracefirst($text),
            q{numeric_constant},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{numeric_constant},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{numeric_constant},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{numeric_constant},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{numeric_constant},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::old_new_table
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"old_new_table"};

  Parse::RecDescent::_trace(q{Trying rule: [old_new_table]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{old_new_table},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/OLD_TABLE/i /(AS)?/i identifier]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{old_new_table},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{old_new_table});
    %item = (__RULE__ => q{old_new_table});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/OLD_TABLE/i]}, Parse::RecDescent::_tracefirst($text),
            q{old_new_table},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:OLD_TABLE)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying terminal: [/(AS)?/i]}, Parse::RecDescent::_tracefirst($text),
            q{old_new_table},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/(AS)?/i})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:(AS)?)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN2__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [identifier]},
          Parse::RecDescent::_tracefirst($text),
          q{old_new_table},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{identifier})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::identifier($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [identifier]>>},
              Parse::RecDescent::_tracefirst($text),
              q{old_new_table},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [identifier]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{old_new_table},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{identifier}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying action},
            Parse::RecDescent::_tracefirst($text),
            q{old_new_table},
            $tracelevel)
            if defined $::RD_TRACE;


    $_tok = ($_noactions) ? 0 : do { $return = join(' ', @item[1..3] ) };
    unless (defined $_tok)
    {
      Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
          if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
            . $_tok . q{])},
            Parse::RecDescent::_tracefirst($text))
            if defined $::RD_TRACE;
    push @item, $_tok;
    $item{__ACTION1__}=$_tok;



    Parse::RecDescent::_trace(q{>>Matched production: [/OLD_TABLE/i /(AS)?/i identifier]<<},
            Parse::RecDescent::_tracefirst($text),
            q{old_new_table},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/NEW_TABLE/i /(AS)?/i identifier]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{old_new_table},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{old_new_table});
    %item = (__RULE__ => q{old_new_table});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/NEW_TABLE/i]}, Parse::RecDescent::_tracefirst($text),
            q{old_new_table},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:NEW_TABLE)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying terminal: [/(AS)?/i]}, Parse::RecDescent::_tracefirst($text),
            q{old_new_table},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/(AS)?/i})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:(AS)?)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN2__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [identifier]},
          Parse::RecDescent::_tracefirst($text),
          q{old_new_table},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{identifier})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::identifier($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [identifier]>>},
              Parse::RecDescent::_tracefirst($text),
              q{old_new_table},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [identifier]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{old_new_table},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{identifier}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying action},
            Parse::RecDescent::_tracefirst($text),
            q{old_new_table},
            $tracelevel)
            if defined $::RD_TRACE;


    $_tok = ($_noactions) ? 0 : do { $return = join(' ', @item[1..3] ) };
    unless (defined $_tok)
    {
      Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
          if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
            . $_tok . q{])},
            Parse::RecDescent::_tracefirst($text))
            if defined $::RD_TRACE;
    push @item, $_tok;
    $item{__ACTION1__}=$_tok;



    Parse::RecDescent::_trace(q{>>Matched production: [/NEW_TABLE/i /(AS)?/i identifier]<<},
            Parse::RecDescent::_tracefirst($text),
            q{old_new_table},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{old_new_table},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{old_new_table},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{old_new_table},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{old_new_table},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_numbering_function
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule_numbering_function"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule_numbering_function]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_1_of_rule_numbering_function},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [window_order_clause window_aggregation_group_clause]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule_numbering_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule_numbering_function});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_numbering_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [window_order_clause]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_1_of_production_1_of_rule_numbering_function},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::window_order_clause($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [window_order_clause]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_1_of_production_1_of_rule_numbering_function},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [window_order_clause]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_numbering_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{window_order_clause}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying repeated subrule: [window_aggregation_group_clause]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_1_of_production_1_of_rule_numbering_function},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{window_aggregation_group_clause})->at($text);

    unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::window_aggregation_group_clause, 0, 1, $_noactions,$expectation,undef)))
    {
      Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [window_aggregation_group_clause]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_1_of_production_1_of_rule_numbering_function},
              $tracelevel)
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched repeated subrule: [window_aggregation_group_clause]<< (}
          . @$_tok . q{ times)},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_numbering_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{window_aggregation_group_clause(?)}} = $_tok;
    push @item, $_tok;




    Parse::RecDescent::_trace(q{>>Matched production: [window_order_clause window_aggregation_group_clause]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_numbering_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_1_of_rule_numbering_function},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_1_of_rule_numbering_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_1_of_rule_numbering_function},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_1_of_rule_numbering_function},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_searched_when_clause
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_searched_when_clause"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_searched_when_clause]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_searched_when_clause},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [result_expression]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_searched_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_searched_when_clause});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_searched_when_clause});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [result_expression]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_searched_when_clause},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::result_expression($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [result_expression]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_searched_when_clause},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [result_expression]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_searched_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{result_expression}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [result_expression]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_searched_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/NULL/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_searched_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_searched_when_clause});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_searched_when_clause});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/NULL/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_searched_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:NULL)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/NULL/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_searched_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_searched_when_clause},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_searched_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_searched_when_clause},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_searched_when_clause},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::old_new_corr
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"old_new_corr"};

  Parse::RecDescent::_trace(q{Trying rule: [old_new_corr]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{old_new_corr},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/OLD/i /(AS)?/i correlation_name]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{old_new_corr},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{old_new_corr});
    %item = (__RULE__ => q{old_new_corr});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/OLD/i]}, Parse::RecDescent::_tracefirst($text),
            q{old_new_corr},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:OLD)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying terminal: [/(AS)?/i]}, Parse::RecDescent::_tracefirst($text),
            q{old_new_corr},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/(AS)?/i})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:(AS)?)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN2__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [correlation_name]},
          Parse::RecDescent::_tracefirst($text),
          q{old_new_corr},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{correlation_name})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::correlation_name($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [correlation_name]>>},
              Parse::RecDescent::_tracefirst($text),
              q{old_new_corr},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [correlation_name]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{old_new_corr},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{correlation_name}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying action},
            Parse::RecDescent::_tracefirst($text),
            q{old_new_corr},
            $tracelevel)
            if defined $::RD_TRACE;


    $_tok = ($_noactions) ? 0 : do { $return = join(' ', @item[1..3] ) };
    unless (defined $_tok)
    {
      Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
          if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
            . $_tok . q{])},
            Parse::RecDescent::_tracefirst($text))
            if defined $::RD_TRACE;
    push @item, $_tok;
    $item{__ACTION1__}=$_tok;



    Parse::RecDescent::_trace(q{>>Matched production: [/OLD/i /(AS)?/i correlation_name]<<},
            Parse::RecDescent::_tracefirst($text),
            q{old_new_corr},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/NEW/i /(AS)?/i correlation_name]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{old_new_corr},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{old_new_corr});
    %item = (__RULE__ => q{old_new_corr});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/NEW/i]}, Parse::RecDescent::_tracefirst($text),
            q{old_new_corr},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:NEW)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying terminal: [/(AS)?/i]}, Parse::RecDescent::_tracefirst($text),
            q{old_new_corr},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/(AS)?/i})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:(AS)?)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN2__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [correlation_name]},
          Parse::RecDescent::_tracefirst($text),
          q{old_new_corr},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{correlation_name})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::correlation_name($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [correlation_name]>>},
              Parse::RecDescent::_tracefirst($text),
              q{old_new_corr},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [correlation_name]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{old_new_corr},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{correlation_name}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying action},
            Parse::RecDescent::_tracefirst($text),
            q{old_new_corr},
            $tracelevel)
            if defined $::RD_TRACE;


    $_tok = ($_noactions) ? 0 : do { $return = join(' ', @item[1..3] ) };
    unless (defined $_tok)
    {
      Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
          if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
            . $_tok . q{])},
            Parse::RecDescent::_tracefirst($text))
            if defined $::RD_TRACE;
    push @item, $_tok;
    $item{__ACTION1__}=$_tok;



    Parse::RecDescent::_trace(q{>>Matched production: [/NEW/i /(AS)?/i correlation_name]<<},
            Parse::RecDescent::_tracefirst($text),
            q{old_new_corr},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{old_new_corr},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{old_new_corr},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{old_new_corr},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{old_new_corr},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_42_of_rule_sysibm_function
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_42_of_rule_sysibm_function"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_42_of_rule_sysibm_function]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_42_of_rule_sysibm_function},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/LCASE/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_42_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_42_of_rule_sysibm_function});
    %item = (__RULE__ => q{_alternation_1_of_production_42_of_rule_sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/LCASE/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_42_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:LCASE)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/LCASE/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_42_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/LOWER/]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_42_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_42_of_rule_sysibm_function});
    %item = (__RULE__ => q{_alternation_1_of_production_42_of_rule_sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/LOWER/]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_42_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:LOWER)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/LOWER/]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_42_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_42_of_rule_sysibm_function},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_42_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_42_of_rule_sysibm_function},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_42_of_rule_sysibm_function},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::subtype_treatment
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"subtype_treatment"};

  Parse::RecDescent::_trace(q{Trying rule: [subtype_treatment]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{subtype_treatment},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/TREAT/i '(' expression /AS/i data_type ')']},
            Parse::RecDescent::_tracefirst($_[1]),
            q{subtype_treatment},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{subtype_treatment});
    %item = (__RULE__ => q{subtype_treatment});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/TREAT/i]}, Parse::RecDescent::_tracefirst($text),
            q{subtype_treatment},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:TREAT)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying terminal: ['(']},
            Parse::RecDescent::_tracefirst($text),
            q{subtype_treatment},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{'('})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\(//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [expression]},
          Parse::RecDescent::_tracefirst($text),
          q{subtype_treatment},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{expression})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::expression($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [expression]>>},
              Parse::RecDescent::_tracefirst($text),
              q{subtype_treatment},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [expression]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{subtype_treatment},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{expression}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: [/AS/i]}, Parse::RecDescent::_tracefirst($text),
            q{subtype_treatment},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/AS/i})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:AS)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN2__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [data_type]},
          Parse::RecDescent::_tracefirst($text),
          q{subtype_treatment},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{data_type})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::data_type($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [data_type]>>},
              Parse::RecDescent::_tracefirst($text),
              q{subtype_treatment},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [data_type]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{subtype_treatment},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{data_type}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: [')']},
            Parse::RecDescent::_tracefirst($text),
            q{subtype_treatment},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{')'})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING2__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/TREAT/i '(' expression /AS/i data_type ')']<<},
            Parse::RecDescent::_tracefirst($text),
            q{subtype_treatment},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{subtype_treatment},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{subtype_treatment},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{subtype_treatment},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{subtype_treatment},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::expression
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"expression"};

  Parse::RecDescent::_trace(q{Trying rule: [expression]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{expression},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [<leftop: '+', or '-' /operator/ '+', or '-'>]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{expression},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{expression});
    %item = (__RULE__ => q{expression});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying operator: [<leftop: '+', or '-' /operator/ '+', or '-'>]},
          Parse::RecDescent::_tracefirst($text),
          q{expression},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{})->at($text);

    $_tok = undef;
    OPLOOP: while (1)
    {
      $repcount = 0;
      my  @item;

      # MATCH LEFTARG

    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_1_of_rule_expression]},
          Parse::RecDescent::_tracefirst($text),
          q{expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{'+', or '-'})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_expression($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_1_of_rule_expression]>>},
              Parse::RecDescent::_tracefirst($text),
              q{expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_1_of_rule_expression]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_1_of_rule_expression}} = $_tok;
    push @item, $_tok;

    }


      $repcount++;

      my $savetext = $text;
      my $backtrack;

      # MATCH (OP RIGHTARG)(s)
      while ($repcount < 100000000)
      {
      $backtrack = 0;

    Parse::RecDescent::_trace(q{Trying terminal: [/operator/]}, Parse::RecDescent::_tracefirst($text),
            q{expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/operator/})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:operator)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


      pop @item;
      if (defined $1) {push @item, $item{'_alternation_1_of_production_1_of_rule_expression(s)'}=$1; $backtrack=1;}

    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_1_of_rule_expression]},
          Parse::RecDescent::_tracefirst($text),
          q{expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{'+', or '-'})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_expression($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_1_of_rule_expression]>>},
              Parse::RecDescent::_tracefirst($text),
              q{expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_1_of_rule_expression]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_1_of_rule_expression}} = $_tok;
    push @item, $_tok;

    }

      $savetext = $text;
      $repcount++;
      }
      $text = $savetext;
      pop @item if $backtrack;

      unless (@item) { undef $_tok; last }
      $_tok = [ @item ];
      last;
    }

    unless ($repcount>=1)
    {
      Parse::RecDescent::_trace(q{<<Didn't match operator: [<leftop: '+', or '-' /operator/ '+', or '-'>]>>},
              Parse::RecDescent::_tracefirst($text),
              q{expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched operator: [<leftop: '+', or '-' /operator/ '+', or '-'>]<< (return value: [}
            . qq{@{$_tok||[]}} . q{]},
            Parse::RecDescent::_tracefirst($text),
            q{expression},
            $tracelevel)
            if defined $::RD_TRACE;

    push @item, $item{'_alternation_1_of_production_1_of_rule_expression(s)'}=$_tok||[];



    Parse::RecDescent::_trace(q{>>Matched production: [<leftop: '+', or '-' /operator/ '+', or '-'>]<<},
            Parse::RecDescent::_tracefirst($text),
            q{expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{expression},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{expression},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{expression},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [function]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression});
    %item = (__RULE__ => q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [function]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::function($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [function]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [function]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{function}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [function]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: ['(' expression ')']},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression});
    %item = (__RULE__ => q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: ['(']},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\(//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [expression]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{expression})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::expression($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [expression]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [expression]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{expression}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: [')']},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{')'})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING2__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: ['(' expression ')']<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [constant]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[2];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression});
    %item = (__RULE__ => q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [constant]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::constant($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [constant]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [constant]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{constant}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [constant]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [column_name]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[3];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression});
    %item = (__RULE__ => q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [column_name]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::column_name($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [column_name]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [column_name]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{column_name}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [column_name]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [host_variable]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[4];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression});
    %item = (__RULE__ => q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [host_variable]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::host_variable($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [host_variable]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [host_variable]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{host_variable}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [host_variable]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [special_register]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[5];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression});
    %item = (__RULE__ => q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [special_register]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::special_register($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [special_register]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [special_register]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{special_register}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [special_register]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: ['(' scalar_fullselect ')']},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[6];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression});
    %item = (__RULE__ => q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: ['(']},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\(//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [scalar_fullselect]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{scalar_fullselect})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::scalar_fullselect($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [scalar_fullselect]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [scalar_fullselect]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{scalar_fullselect}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: [')']},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{')'})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING2__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: ['(' scalar_fullselect ')']<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [labeled_duration]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[7];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression});
    %item = (__RULE__ => q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [labeled_duration]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::labeled_duration($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [labeled_duration]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [labeled_duration]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{labeled_duration}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [labeled_duration]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [case_expression]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[8];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression});
    %item = (__RULE__ => q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [case_expression]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::case_expression($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [case_expression]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [case_expression]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{case_expression}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [case_expression]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [cast_specification]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[9];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression});
    %item = (__RULE__ => q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [cast_specification]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::cast_specification($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [cast_specification]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [cast_specification]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{cast_specification}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [cast_specification]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [OLAP_function]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[10];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression});
    %item = (__RULE__ => q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [OLAP_function]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::OLAP_function($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [OLAP_function]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [OLAP_function]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{OLAP_function}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [OLAP_function]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [method_invocation]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[11];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression});
    %item = (__RULE__ => q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [method_invocation]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::method_invocation($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [method_invocation]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [method_invocation]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{method_invocation}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [method_invocation]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [subtype_treatment]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[12];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression});
    %item = (__RULE__ => q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [subtype_treatment]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::subtype_treatment($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [subtype_treatment]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [subtype_treatment]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{subtype_treatment}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [subtype_treatment]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [sequence_reference]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[13];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression});
    %item = (__RULE__ => q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [sequence_reference]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::sequence_reference($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [sequence_reference]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [sequence_reference]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{sequence_reference}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [sequence_reference]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::startrule
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"startrule"};

  Parse::RecDescent::_trace(q{Trying rule: [startrule]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{startrule},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [statement eofile]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{startrule},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{startrule});
    %item = (__RULE__ => q{startrule});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying repeated subrule: [statement]},
          Parse::RecDescent::_tracefirst($text),
          q{startrule},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{})->at($text);

    unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::statement, 1, 100000000, $_noactions,$expectation,undef)))
    {
      Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [statement]>>},
              Parse::RecDescent::_tracefirst($text),
              q{startrule},
              $tracelevel)
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched repeated subrule: [statement]<< (}
          . @$_tok . q{ times)},

            Parse::RecDescent::_tracefirst($text),
            q{startrule},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{statement(s)}} = $_tok;
    push @item, $_tok;



    Parse::RecDescent::_trace(q{Trying subrule: [eofile]},
          Parse::RecDescent::_tracefirst($text),
          q{startrule},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{eofile})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::eofile($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [eofile]>>},
              Parse::RecDescent::_tracefirst($text),
              q{startrule},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [eofile]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{startrule},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{eofile}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying action},
            Parse::RecDescent::_tracefirst($text),
            q{startrule},
            $tracelevel)
            if defined $::RD_TRACE;


    $_tok = ($_noactions) ? 0 : do {
    $return      = {
        tables   => \%tables,
        views    => \@views,
        triggers => \@triggers,
    }
};
    unless (defined $_tok)
    {
      Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
          if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
            . $_tok . q{])},
            Parse::RecDescent::_tracefirst($text))
            if defined $::RD_TRACE;
    push @item, $_tok;
    $item{__ACTION1__}=$_tok;



    Parse::RecDescent::_trace(q{>>Matched production: [statement eofile]<<},
            Parse::RecDescent::_tracefirst($text),
            q{startrule},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{startrule},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{startrule},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{startrule},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{startrule},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_cast_specification
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule_cast_specification"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule_cast_specification]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_1_of_rule_cast_specification},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [expression]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule_cast_specification},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule_cast_specification});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_cast_specification});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [expression]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_1_of_production_1_of_rule_cast_specification},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::expression($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [expression]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_1_of_production_1_of_rule_cast_specification},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [expression]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_cast_specification},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{expression}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [expression]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_cast_specification},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/NULL/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule_cast_specification},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule_cast_specification});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_cast_specification});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/NULL/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_cast_specification},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:NULL)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/NULL/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_cast_specification},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [parameter_marker]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule_cast_specification},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[2];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule_cast_specification});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_cast_specification});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [parameter_marker]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_1_of_production_1_of_rule_cast_specification},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::parameter_marker($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [parameter_marker]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_1_of_production_1_of_rule_cast_specification},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [parameter_marker]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_cast_specification},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{parameter_marker}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [parameter_marker]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_cast_specification},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_1_of_rule_cast_specification},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_1_of_rule_cast_specification},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_1_of_rule_cast_specification},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_1_of_rule_cast_specification},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::before
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"before"};

  Parse::RecDescent::_trace(q{Trying rule: [before]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{before},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/NO CASCADE BEFORE/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{before},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{before});
    %item = (__RULE__ => q{before});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/NO CASCADE BEFORE/i]}, Parse::RecDescent::_tracefirst($text),
            q{before},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:NO CASCADE BEFORE)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/NO CASCADE BEFORE/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{before},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{before},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{before},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{before},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{before},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_83_of_rule_sysibm_function
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_83_of_rule_sysibm_function"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_83_of_rule_sysibm_function]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_83_of_rule_sysibm_function},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/UCASE/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_83_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_83_of_rule_sysibm_function});
    %item = (__RULE__ => q{_alternation_1_of_production_83_of_rule_sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/UCASE/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_83_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:UCASE)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/UCASE/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_83_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/UPPER/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_83_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_83_of_rule_sysibm_function});
    %item = (__RULE__ => q{_alternation_1_of_production_83_of_rule_sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/UPPER/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_83_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:UPPER)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/UPPER/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_83_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_83_of_rule_sysibm_function},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_83_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_83_of_rule_sysibm_function},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_83_of_rule_sysibm_function},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::ranking_function
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"ranking_function"};

  Parse::RecDescent::_trace(q{Trying rule: [ranking_function]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{ranking_function},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/RANK/, or /DENSE_RANK|DENSERANK/i /OVER/i '(' window_partition_clause window_order_clause ')']},
            Parse::RecDescent::_tracefirst($_[1]),
            q{ranking_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{ranking_function});
    %item = (__RULE__ => q{ranking_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_1_of_rule_ranking_function]},
          Parse::RecDescent::_tracefirst($text),
          q{ranking_function},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_ranking_function($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_1_of_rule_ranking_function]>>},
              Parse::RecDescent::_tracefirst($text),
              q{ranking_function},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_1_of_rule_ranking_function]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{ranking_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_1_of_rule_ranking_function}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: [/OVER/i]}, Parse::RecDescent::_tracefirst($text),
            q{ranking_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/OVER/i})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:OVER)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying terminal: ['(']},
            Parse::RecDescent::_tracefirst($text),
            q{ranking_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{'('})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\(//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;


    Parse::RecDescent::_trace(q{Trying repeated subrule: [window_partition_clause]},
          Parse::RecDescent::_tracefirst($text),
          q{ranking_function},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{window_partition_clause})->at($text);

    unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::window_partition_clause, 0, 1, $_noactions,$expectation,undef)))
    {
      Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [window_partition_clause]>>},
              Parse::RecDescent::_tracefirst($text),
              q{ranking_function},
              $tracelevel)
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched repeated subrule: [window_partition_clause]<< (}
          . @$_tok . q{ times)},

            Parse::RecDescent::_tracefirst($text),
            q{ranking_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{window_partition_clause(?)}} = $_tok;
    push @item, $_tok;



    Parse::RecDescent::_trace(q{Trying subrule: [window_order_clause]},
          Parse::RecDescent::_tracefirst($text),
          q{ranking_function},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{window_order_clause})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::window_order_clause($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [window_order_clause]>>},
              Parse::RecDescent::_tracefirst($text),
              q{ranking_function},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [window_order_clause]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{ranking_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{window_order_clause}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: [')']},
            Parse::RecDescent::_tracefirst($text),
            q{ranking_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{')'})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING2__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/RANK/, or /DENSE_RANK|DENSERANK/i /OVER/i '(' window_partition_clause window_order_clause ')']<<},
            Parse::RecDescent::_tracefirst($text),
            q{ranking_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{ranking_function},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{ranking_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{ranking_function},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{ranking_function},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule__alternation_1_of_production_2_of_rule_search_condition
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule__alternation_1_of_production_2_of_rule_search_condition"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule__alternation_1_of_production_2_of_rule_search_condition]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_2_of_rule_search_condition},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/SELECTIVITY/i numeric_constant]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_2_of_rule_search_condition},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_2_of_rule_search_condition});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_2_of_rule_search_condition});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/SELECTIVITY/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_2_of_rule_search_condition},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:SELECTIVITY)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [numeric_constant]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_2_of_rule_search_condition},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{numeric_constant})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::numeric_constant($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [numeric_constant]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_2_of_rule_search_condition},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [numeric_constant]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_2_of_rule_search_condition},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{numeric_constant}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [/SELECTIVITY/i numeric_constant]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_2_of_rule_search_condition},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_2_of_rule_search_condition},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_2_of_rule_search_condition},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_2_of_rule_search_condition},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_2_of_rule_search_condition},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_sysibm_function
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule_sysibm_function"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule_sysibm_function]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_1_of_rule_sysibm_function},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/ABS/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule_sysibm_function});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/ABS/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:ABS)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/ABS/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/ABSVAL/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule_sysibm_function});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/ABSVAL/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:ABSVAL)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/ABSVAL/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_1_of_rule_sysibm_function},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_1_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_1_of_rule_sysibm_function},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_1_of_rule_sysibm_function},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::reference_b
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"reference_b"};

  Parse::RecDescent::_trace(q{Trying rule: [reference_b]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{reference_b},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/REFERENCING/i old_new_corr]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{reference_b},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{reference_b});
    %item = (__RULE__ => q{reference_b});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/REFERENCING/i]}, Parse::RecDescent::_tracefirst($text),
            q{reference_b},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:REFERENCING)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying repeated subrule: [old_new_corr]},
          Parse::RecDescent::_tracefirst($text),
          q{reference_b},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{old_new_corr})->at($text);

    unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::old_new_corr, 0, 2, $_noactions,$expectation,undef)))
    {
      Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [old_new_corr]>>},
              Parse::RecDescent::_tracefirst($text),
              q{reference_b},
              $tracelevel)
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched repeated subrule: [old_new_corr]<< (}
          . @$_tok . q{ times)},

            Parse::RecDescent::_tracefirst($text),
            q{reference_b},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{old_new_corr(0..2)}} = $_tok;
    push @item, $_tok;



    Parse::RecDescent::_trace(q{Trying action},
            Parse::RecDescent::_tracefirst($text),
            q{reference_b},
            $tracelevel)
            if defined $::RD_TRACE;


    $_tok = ($_noactions) ? 0 : do { $return = join(' ', $item[1], join(' ', @{$item[2]}) ) };
    unless (defined $_tok)
    {
      Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
          if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
            . $_tok . q{])},
            Parse::RecDescent::_tracefirst($text))
            if defined $::RD_TRACE;
    push @item, $_tok;
    $item{__ACTION1__}=$_tok;



    Parse::RecDescent::_trace(q{>>Matched production: [/REFERENCING/i old_new_corr]<<},
            Parse::RecDescent::_tracefirst($text),
            q{reference_b},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{reference_b},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{reference_b},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{reference_b},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{reference_b},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_simple_when_clause
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_1_of_rule_simple_when_clause"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_1_of_rule_simple_when_clause]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_1_of_rule_simple_when_clause},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/WHEN/i search_condition /THEN/i result_expression, or /NULL/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_1_of_rule_simple_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_1_of_rule_simple_when_clause});
    %item = (__RULE__ => q{_alternation_1_of_production_1_of_rule_simple_when_clause});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/WHEN/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_simple_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:WHEN)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [search_condition]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_1_of_production_1_of_rule_simple_when_clause},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{search_condition})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::search_condition($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [search_condition]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_1_of_production_1_of_rule_simple_when_clause},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [search_condition]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_simple_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{search_condition}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: [/THEN/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_simple_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/THEN/i})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:THEN)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN2__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_simple_when_clause]},
          Parse::RecDescent::_tracefirst($text),
          q{_alternation_1_of_production_1_of_rule_simple_when_clause},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{result_expression, or /NULL/i})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_simple_when_clause($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_simple_when_clause]>>},
              Parse::RecDescent::_tracefirst($text),
              q{_alternation_1_of_production_1_of_rule_simple_when_clause},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_simple_when_clause]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_simple_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_simple_when_clause}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [/WHEN/i search_condition /THEN/i result_expression, or /NULL/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_1_of_rule_simple_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_1_of_rule_simple_when_clause},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_1_of_rule_simple_when_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_1_of_rule_simple_when_clause},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_1_of_rule_simple_when_clause},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_9_of_rule_sysibm_function
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_9_of_rule_sysibm_function"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_9_of_rule_sysibm_function]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_9_of_rule_sysibm_function},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/CORRELATION/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_9_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_9_of_rule_sysibm_function});
    %item = (__RULE__ => q{_alternation_1_of_production_9_of_rule_sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/CORRELATION/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_9_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:CORRELATION)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/CORRELATION/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_9_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/CORR/]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_9_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_9_of_rule_sysibm_function});
    %item = (__RULE__ => q{_alternation_1_of_production_9_of_rule_sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/CORR/]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_9_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:CORR)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/CORR/]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_9_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_9_of_rule_sysibm_function},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_9_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_9_of_rule_sysibm_function},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_9_of_rule_sysibm_function},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_7_of_rule_sysfun
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_7_of_rule_sysfun"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_7_of_rule_sysfun]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_7_of_rule_sysfun},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/CEIL/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_7_of_rule_sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_7_of_rule_sysfun});
    %item = (__RULE__ => q{_alternation_1_of_production_7_of_rule_sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/CEIL/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_7_of_rule_sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:CEIL)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/CEIL/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_7_of_rule_sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/CEILING/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_7_of_rule_sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_7_of_rule_sysfun});
    %item = (__RULE__ => q{_alternation_1_of_production_7_of_rule_sysfun});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/CEILING/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_7_of_rule_sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:CEILING)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/CEILING/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_7_of_rule_sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_7_of_rule_sysfun},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_7_of_rule_sysfun},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_7_of_rule_sysfun},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_7_of_rule_sysfun},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::prevval_expression
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"prevval_expression"};

  Parse::RecDescent::_trace(q{Trying rule: [prevval_expression]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{prevval_expression},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/PREVVAL\\s+FOR/i sequence_name]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{prevval_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{prevval_expression});
    %item = (__RULE__ => q{prevval_expression});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/PREVVAL\\s+FOR/i]}, Parse::RecDescent::_tracefirst($text),
            q{prevval_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:PREVVAL\s+FOR)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [sequence_name]},
          Parse::RecDescent::_tracefirst($text),
          q{prevval_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{sequence_name})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::sequence_name($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [sequence_name]>>},
              Parse::RecDescent::_tracefirst($text),
              q{prevval_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [sequence_name]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{prevval_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{sequence_name}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [/PREVVAL\\s+FOR/i sequence_name]<<},
            Parse::RecDescent::_tracefirst($text),
            q{prevval_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{prevval_expression},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{prevval_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{prevval_expression},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{prevval_expression},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::where_clause
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"where_clause"};

  Parse::RecDescent::_trace(q{Trying rule: [where_clause]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{where_clause},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [WHERE search_condition]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{where_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{where_clause});
    %item = (__RULE__ => q{where_clause});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [WHERE]},
          Parse::RecDescent::_tracefirst($text),
          q{where_clause},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::WHERE($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [WHERE]>>},
              Parse::RecDescent::_tracefirst($text),
              q{where_clause},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [WHERE]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{where_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{WHERE}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying subrule: [search_condition]},
          Parse::RecDescent::_tracefirst($text),
          q{where_clause},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{search_condition})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::search_condition($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [search_condition]>>},
              Parse::RecDescent::_tracefirst($text),
              q{where_clause},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [search_condition]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{where_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{search_condition}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [WHERE search_condition]<<},
            Parse::RecDescent::_tracefirst($text),
            q{where_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{where_clause},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{where_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{where_clause},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{where_clause},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::group_start
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"group_start"};

  Parse::RecDescent::_trace(q{Trying rule: [group_start]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{group_start},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/UNBOUNDED\\s+PRECEDING/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{group_start},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{group_start});
    %item = (__RULE__ => q{group_start});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/UNBOUNDED\\s+PRECEDING/i]}, Parse::RecDescent::_tracefirst($text),
            q{group_start},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:UNBOUNDED\s+PRECEDING)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/UNBOUNDED\\s+PRECEDING/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{group_start},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [unsigned_constant /PRECEDING/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{group_start},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{group_start});
    %item = (__RULE__ => q{group_start});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [unsigned_constant]},
          Parse::RecDescent::_tracefirst($text),
          q{group_start},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::unsigned_constant($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [unsigned_constant]>>},
              Parse::RecDescent::_tracefirst($text),
              q{group_start},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [unsigned_constant]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{group_start},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{unsigned_constant}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: [/PRECEDING/i]}, Parse::RecDescent::_tracefirst($text),
            q{group_start},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/PRECEDING/i})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:PRECEDING)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [unsigned_constant /PRECEDING/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{group_start},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/CURRENT\\s+ROW/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{group_start},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[2];
    $text = $_[1];
    my $_savetext;
    @item = (q{group_start});
    %item = (__RULE__ => q{group_start});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/CURRENT\\s+ROW/i]}, Parse::RecDescent::_tracefirst($text),
            q{group_start},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:CURRENT\s+ROW)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/CURRENT\\s+ROW/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{group_start},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{group_start},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{group_start},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{group_start},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{group_start},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::correlation_name
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"correlation_name"};

  Parse::RecDescent::_trace(q{Trying rule: [correlation_name]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{correlation_name},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [NAME]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{correlation_name},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{correlation_name});
    %item = (__RULE__ => q{correlation_name});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [NAME]},
          Parse::RecDescent::_tracefirst($text),
          q{correlation_name},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::NAME($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [NAME]>>},
              Parse::RecDescent::_tracefirst($text),
              q{correlation_name},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [NAME]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{correlation_name},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{NAME}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [NAME]<<},
            Parse::RecDescent::_tracefirst($text),
            q{correlation_name},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{correlation_name},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{correlation_name},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{correlation_name},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{correlation_name},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::SQL_procedure_statement
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"SQL_procedure_statement"};

  Parse::RecDescent::_trace(q{Trying rule: [SQL_procedure_statement]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{SQL_procedure_statement},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/[^;]*/ /(;|\\z)/]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{SQL_procedure_statement},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{SQL_procedure_statement});
    %item = (__RULE__ => q{SQL_procedure_statement});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/[^;]*/]}, Parse::RecDescent::_tracefirst($text),
            q{SQL_procedure_statement},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:[^;]*)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying terminal: [/(;|\\z)/]}, Parse::RecDescent::_tracefirst($text),
            q{SQL_procedure_statement},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/(;|\\z)/})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:(;|\z))//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN2__}=$&;


    Parse::RecDescent::_trace(q{Trying action},
            Parse::RecDescent::_tracefirst($text),
            q{SQL_procedure_statement},
            $tracelevel)
            if defined $::RD_TRACE;


    $_tok = ($_noactions) ? 0 : do { $return = $item[1] . $item[2] };
    unless (defined $_tok)
    {
      Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
          if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
            . $_tok . q{])},
            Parse::RecDescent::_tracefirst($text))
            if defined $::RD_TRACE;
    push @item, $_tok;
    $item{__ACTION1__}=$_tok;



    Parse::RecDescent::_trace(q{>>Matched production: [/[^;]*/ /(;|\\z)/]<<},
            Parse::RecDescent::_tracefirst($text),
            q{SQL_procedure_statement},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{SQL_procedure_statement},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{SQL_procedure_statement},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{SQL_procedure_statement},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{SQL_procedure_statement},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::group_between
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"group_between"};

  Parse::RecDescent::_trace(q{Trying rule: [group_between]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{group_between},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/BETWEEN/i group_bound1 /AND/i group_bound2]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{group_between},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{group_between});
    %item = (__RULE__ => q{group_between});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/BETWEEN/i]}, Parse::RecDescent::_tracefirst($text),
            q{group_between},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:BETWEEN)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [group_bound1]},
          Parse::RecDescent::_tracefirst($text),
          q{group_between},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{group_bound1})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::group_bound1($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [group_bound1]>>},
              Parse::RecDescent::_tracefirst($text),
              q{group_between},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [group_bound1]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{group_between},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{group_bound1}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: [/AND/i]}, Parse::RecDescent::_tracefirst($text),
            q{group_between},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/AND/i})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:AND)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN2__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [group_bound2]},
          Parse::RecDescent::_tracefirst($text),
          q{group_between},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{group_bound2})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::group_bound2($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [group_bound2]>>},
              Parse::RecDescent::_tracefirst($text),
              q{group_between},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [group_bound2]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{group_between},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{group_bound2}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [/BETWEEN/i group_bound1 /AND/i group_bound2]<<},
            Parse::RecDescent::_tracefirst($text),
            q{group_between},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{group_between},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{group_between},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{group_between},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{group_between},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::nextval_expression
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"nextval_expression"};

  Parse::RecDescent::_trace(q{Trying rule: [nextval_expression]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{nextval_expression},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/NEXTVAL\\s+FOR/i sequence_name]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{nextval_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{nextval_expression});
    %item = (__RULE__ => q{nextval_expression});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/NEXTVAL\\s+FOR/i]}, Parse::RecDescent::_tracefirst($text),
            q{nextval_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:NEXTVAL\s+FOR)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [sequence_name]},
          Parse::RecDescent::_tracefirst($text),
          q{nextval_expression},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{sequence_name})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::sequence_name($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [sequence_name]>>},
              Parse::RecDescent::_tracefirst($text),
              q{nextval_expression},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [sequence_name]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{nextval_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{sequence_name}} = $_tok;
    push @item, $_tok;

    }


    Parse::RecDescent::_trace(q{>>Matched production: [/NEXTVAL\\s+FOR/i sequence_name]<<},
            Parse::RecDescent::_tracefirst($text),
            q{nextval_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{nextval_expression},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{nextval_expression},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{nextval_expression},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{nextval_expression},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::desc_option
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"desc_option"};

  Parse::RecDescent::_trace(q{Trying rule: [desc_option]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{desc_option},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/DESC/i /NULLS\\s+FIRST/i, or /NULLS\\s+LAST/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{desc_option},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{desc_option});
    %item = (__RULE__ => q{desc_option});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/DESC/i]}, Parse::RecDescent::_tracefirst($text),
            q{desc_option},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:DESC)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying repeated subrule: [/NULLS\\s+FIRST/i, or /NULLS\\s+LAST/i]},
          Parse::RecDescent::_tracefirst($text),
          q{desc_option},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{/NULLS\\s+FIRST/i, or /NULLS\\s+LAST/i})->at($text);

    unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_desc_option, 0, 1, $_noactions,$expectation,undef)))
    {
      Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: [/NULLS\\s+FIRST/i, or /NULLS\\s+LAST/i]>>},
              Parse::RecDescent::_tracefirst($text),
              q{desc_option},
              $tracelevel)
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched repeated subrule: [_alternation_1_of_production_1_of_rule_desc_option]<< (}
          . @$_tok . q{ times)},

            Parse::RecDescent::_tracefirst($text),
            q{desc_option},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_1_of_rule_desc_option(?)}} = $_tok;
    push @item, $_tok;




    Parse::RecDescent::_trace(q{>>Matched production: [/DESC/i /NULLS\\s+FIRST/i, or /NULLS\\s+LAST/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{desc_option},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{desc_option},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{desc_option},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{desc_option},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{desc_option},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::column_list
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"column_list"};

  Parse::RecDescent::_trace(q{Trying rule: [column_list]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{column_list},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: ['(' <leftop: column_name /,/ column_name> ')']},
            Parse::RecDescent::_tracefirst($_[1]),
            q{column_list},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{column_list});
    %item = (__RULE__ => q{column_list});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: ['(']},
            Parse::RecDescent::_tracefirst($text),
            q{column_list},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\(//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;


    Parse::RecDescent::_trace(q{Trying operator: [<leftop: column_name /,/ column_name>]},
          Parse::RecDescent::_tracefirst($text),
          q{column_list},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{<leftop: column_name /,/ column_name>})->at($text);

    $_tok = undef;
    OPLOOP: while (1)
    {
      $repcount = 0;
      my  @item;

      # MATCH LEFTARG

    Parse::RecDescent::_trace(q{Trying subrule: [column_name]},
          Parse::RecDescent::_tracefirst($text),
          q{column_list},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{column_name})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::column_name($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [column_name]>>},
              Parse::RecDescent::_tracefirst($text),
              q{column_list},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [column_name]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{column_list},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{column_name}} = $_tok;
    push @item, $_tok;

    }


      $repcount++;

      my $savetext = $text;
      my $backtrack;

      # MATCH (OP RIGHTARG)(s)
      while ($repcount < 100000000)
      {
      $backtrack = 0;

    Parse::RecDescent::_trace(q{Trying terminal: [/,/]}, Parse::RecDescent::_tracefirst($text),
            q{column_list},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/,/})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:,)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


      pop @item;
      if (defined $1) {push @item, $item{'column_name(s)'}=$1; $backtrack=1;}

    Parse::RecDescent::_trace(q{Trying subrule: [column_name]},
          Parse::RecDescent::_tracefirst($text),
          q{column_list},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{column_name})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::column_name($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [column_name]>>},
              Parse::RecDescent::_tracefirst($text),
              q{column_list},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [column_name]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{column_list},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{column_name}} = $_tok;
    push @item, $_tok;

    }

      $savetext = $text;
      $repcount++;
      }
      $text = $savetext;
      pop @item if $backtrack;

      unless (@item) { undef $_tok; last }
      $_tok = [ @item ];
      last;
    }

    unless ($repcount>=1)
    {
      Parse::RecDescent::_trace(q{<<Didn't match operator: [<leftop: column_name /,/ column_name>]>>},
              Parse::RecDescent::_tracefirst($text),
              q{column_list},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched operator: [<leftop: column_name /,/ column_name>]<< (return value: [}
            . qq{@{$_tok||[]}} . q{]},
            Parse::RecDescent::_tracefirst($text),
            q{column_list},
            $tracelevel)
            if defined $::RD_TRACE;

    push @item, $item{'column_name(s)'}=$_tok||[];


    Parse::RecDescent::_trace(q{Trying terminal: [')']},
            Parse::RecDescent::_tracefirst($text),
            q{column_list},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{')'})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING2__}=$&;


    Parse::RecDescent::_trace(q{Trying action},
            Parse::RecDescent::_tracefirst($text),
            q{column_list},
            $tracelevel)
            if defined $::RD_TRACE;


    $_tok = ($_noactions) ? 0 : do {
    $return = join(' ', '(', @{$item[2]}, ')');
};
    unless (defined $_tok)
    {
      Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
          if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
            . $_tok . q{])},
            Parse::RecDescent::_tracefirst($text))
            if defined $::RD_TRACE;
    push @item, $_tok;
    $item{__ACTION1__}=$_tok;



    Parse::RecDescent::_trace(q{>>Matched production: ['(' <leftop: column_name /,/ column_name> ')']<<},
            Parse::RecDescent::_tracefirst($text),
            q{column_list},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{column_list},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{column_list},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{column_list},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{column_list},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_63_of_rule_sysibm_function
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"_alternation_1_of_production_63_of_rule_sysibm_function"};

  Parse::RecDescent::_trace(q{Trying rule: [_alternation_1_of_production_63_of_rule_sysibm_function]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{_alternation_1_of_production_63_of_rule_sysibm_function},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/REGR_INTERCEPT/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_63_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_63_of_rule_sysibm_function});
    %item = (__RULE__ => q{_alternation_1_of_production_63_of_rule_sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/REGR_INTERCEPT/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_63_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:REGR_INTERCEPT)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/REGR_INTERCEPT/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_63_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/REGR_ICPT/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{_alternation_1_of_production_63_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[1];
    $text = $_[1];
    my $_savetext;
    @item = (q{_alternation_1_of_production_63_of_rule_sysibm_function});
    %item = (__RULE__ => q{_alternation_1_of_production_63_of_rule_sysibm_function});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/REGR_ICPT/i]}, Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_63_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:REGR_ICPT)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/REGR_ICPT/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{_alternation_1_of_production_63_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{_alternation_1_of_production_63_of_rule_sysibm_function},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{_alternation_1_of_production_63_of_rule_sysibm_function},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{_alternation_1_of_production_63_of_rule_sysibm_function},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{_alternation_1_of_production_63_of_rule_sysibm_function},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::dereference_operation
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"dereference_operation"};

  Parse::RecDescent::_trace(q{Trying rule: [dereference_operation]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{dereference_operation},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [scoped_reference_expression '->' name1 '(']},
            Parse::RecDescent::_tracefirst($_[1]),
            q{dereference_operation},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{dereference_operation});
    %item = (__RULE__ => q{dereference_operation});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying subrule: [scoped_reference_expression]},
          Parse::RecDescent::_tracefirst($text),
          q{dereference_operation},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::scoped_reference_expression($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [scoped_reference_expression]>>},
              Parse::RecDescent::_tracefirst($text),
              q{dereference_operation},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [scoped_reference_expression]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{dereference_operation},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{scoped_reference_expression}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying terminal: ['->']},
            Parse::RecDescent::_tracefirst($text),
            q{dereference_operation},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{'->'})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A\-\>//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(qq{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
              if defined $::RD_TRACE;
    push @item, $item{__STRING1__}=$&;


    Parse::RecDescent::_trace(q{Trying subrule: [name1]},
          Parse::RecDescent::_tracefirst($text),
          q{dereference_operation},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{name1})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::name1($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [name1]>>},
              Parse::RecDescent::_tracefirst($text),
              q{dereference_operation},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [name1]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{dereference_operation},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{name1}} = $_tok;
    push @item, $_tok;

    }

    Parse::RecDescent::_trace(q{Trying repeated subrule: ['(']},
          Parse::RecDescent::_tracefirst($text),
          q{dereference_operation},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{'('})->at($text);

    unless (defined ($_tok = $thisparser->_parserepeat($text, \&Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_dereference_operation, 0, 1, $_noactions,$expectation,undef)))
    {
      Parse::RecDescent::_trace(q{<<Didn't match repeated subrule: ['(']>>},
              Parse::RecDescent::_tracefirst($text),
              q{dereference_operation},
              $tracelevel)
              if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched repeated subrule: [_alternation_1_of_production_1_of_rule_dereference_operation]<< (}
          . @$_tok . q{ times)},

            Parse::RecDescent::_tracefirst($text),
            q{dereference_operation},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_1_of_rule_dereference_operation(?)}} = $_tok;
    push @item, $_tok;




    Parse::RecDescent::_trace(q{>>Matched production: [scoped_reference_expression '->' name1 '(']<<},
            Parse::RecDescent::_tracefirst($text),
            q{dereference_operation},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{dereference_operation},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{dereference_operation},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{dereference_operation},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{dereference_operation},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::OUTER
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"OUTER"};

  Parse::RecDescent::_trace(q{Trying rule: [OUTER]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{OUTER},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/outer/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{OUTER},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{OUTER});
    %item = (__RULE__ => q{OUTER});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/outer/i]}, Parse::RecDescent::_tracefirst($text),
            q{OUTER},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:outer)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/outer/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{OUTER},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{OUTER},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{OUTER},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{OUTER},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{OUTER},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::window_order_clause
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"window_order_clause"};

  Parse::RecDescent::_trace(q{Trying rule: [window_order_clause]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{window_order_clause},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/ORDER\\s+BY/i <leftop: sort_key_expression /,/ sort_key_expression>]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{window_order_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{window_order_clause});
    %item = (__RULE__ => q{window_order_clause});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/ORDER\\s+BY/i]}, Parse::RecDescent::_tracefirst($text),
            q{window_order_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:ORDER\s+BY)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying operator: [<leftop: sort_key_expression /,/ sort_key_expression>]},
          Parse::RecDescent::_tracefirst($text),
          q{window_order_clause},
          $tracelevel)
          if defined $::RD_TRACE;
    $expectation->is(q{<leftop: sort_key_expression /,/ sort_key_expression>})->at($text);

    $_tok = undef;
    OPLOOP: while (1)
    {
      $repcount = 0;
      my  @item;

      # MATCH LEFTARG

    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_1_of_rule_window_order_clause]},
          Parse::RecDescent::_tracefirst($text),
          q{window_order_clause},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{sort_key_expression})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_window_order_clause($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_1_of_rule_window_order_clause]>>},
              Parse::RecDescent::_tracefirst($text),
              q{window_order_clause},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_1_of_rule_window_order_clause]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{window_order_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_1_of_rule_window_order_clause}} = $_tok;
    push @item, $_tok;

    }


      $repcount++;

      my $savetext = $text;
      my $backtrack;

      # MATCH (OP RIGHTARG)(s)
      while ($repcount < 100000000)
      {
      $backtrack = 0;

    Parse::RecDescent::_trace(q{Trying terminal: [/,/]}, Parse::RecDescent::_tracefirst($text),
            q{window_order_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{/,/})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:,)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN2__}=$&;


      pop @item;
      if (defined $1) {push @item, $item{'_alternation_1_of_production_1_of_rule_window_order_clause(s)'}=$1; $backtrack=1;}

    Parse::RecDescent::_trace(q{Trying subrule: [_alternation_1_of_production_1_of_rule_window_order_clause]},
          Parse::RecDescent::_tracefirst($text),
          q{window_order_clause},
          $tracelevel)
          if defined $::RD_TRACE;
    if (1) { no strict qw{refs};
    $expectation->is(q{sort_key_expression})->at($text);
    unless (defined ($_tok = Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::_alternation_1_of_production_1_of_rule_window_order_clause($thisparser,$text,$repeating,$_noactions,sub { \@arg })))
    {

      Parse::RecDescent::_trace(q{<<Didn't match subrule: [_alternation_1_of_production_1_of_rule_window_order_clause]>>},
              Parse::RecDescent::_tracefirst($text),
              q{window_order_clause},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched subrule: [_alternation_1_of_production_1_of_rule_window_order_clause]<< (return value: [}
          . $_tok . q{]},

            Parse::RecDescent::_tracefirst($text),
            q{window_order_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $item{q{_alternation_1_of_production_1_of_rule_window_order_clause}} = $_tok;
    push @item, $_tok;

    }

      $savetext = $text;
      $repcount++;
      }
      $text = $savetext;
      pop @item if $backtrack;

      unless (@item) { undef $_tok; last }
      $_tok = [ @item ];
      last;
    }

    unless ($repcount>=1)
    {
      Parse::RecDescent::_trace(q{<<Didn't match operator: [<leftop: sort_key_expression /,/ sort_key_expression>]>>},
              Parse::RecDescent::_tracefirst($text),
              q{window_order_clause},
              $tracelevel)
              if defined $::RD_TRACE;
      $expectation->failed();
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched operator: [<leftop: sort_key_expression /,/ sort_key_expression>]<< (return value: [}
            . qq{@{$_tok||[]}} . q{]},
            Parse::RecDescent::_tracefirst($text),
            q{window_order_clause},
            $tracelevel)
            if defined $::RD_TRACE;

    push @item, $item{'_alternation_1_of_production_1_of_rule_window_order_clause(s)'}=$_tok||[];



    Parse::RecDescent::_trace(q{>>Matched production: [/ORDER\\s+BY/i <leftop: sort_key_expression /,/ sort_key_expression>]<<},
            Parse::RecDescent::_tracefirst($text),
            q{window_order_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{window_order_clause},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{window_order_clause},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{window_order_clause},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{window_order_clause},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::TRIGGER
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"TRIGGER"};

  Parse::RecDescent::_trace(q{Trying rule: [TRIGGER]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{TRIGGER},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/trigger/i]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{TRIGGER},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{TRIGGER});
    %item = (__RULE__ => q{TRIGGER});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/trigger/i]}, Parse::RecDescent::_tracefirst($text),
            q{TRIGGER},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:trigger)//i)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;



    Parse::RecDescent::_trace(q{>>Matched production: [/trigger/i]<<},
            Parse::RecDescent::_tracefirst($text),
            q{TRIGGER},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{TRIGGER},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{TRIGGER},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{TRIGGER},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{TRIGGER},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}

# ARGS ARE: ($parser, $text; $repeating, $_noactions, \@args)
sub Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar::comment
{
  my $thisparser = $_[0];
  use vars q{$tracelevel};
  local $tracelevel = ($tracelevel||0)+1;
  $ERRORS = 0;
  my $thisrule = $thisparser->{"rules"}{"comment"};

  Parse::RecDescent::_trace(q{Trying rule: [comment]},
          Parse::RecDescent::_tracefirst($_[1]),
          q{comment},
          $tracelevel)
          if defined $::RD_TRACE;


  my $err_at = @{$thisparser->{errors}};

  my $score;
  my $score_return;
  my $_tok;
  my $return = undef;
  my $_matched=0;
  my $commit=0;
  my @item = ();
  my %item = ();
  my $repeating =  defined($_[2]) && $_[2];
  my $_noactions = defined($_[3]) && $_[3];
   my @arg =        defined $_[4] ? @{ &{$_[4]} } : ();
  my %arg =        ($#arg & 01) ? @arg : (@arg, undef);
  my $text;
  my $lastsep="";
  my $expectation = new Parse::RecDescent::Expectation($thisrule->expected());
  $expectation->at($_[1]);

  my $thisline;
  tie $thisline, q{Parse::RecDescent::LineCounter}, \$text, $thisparser;



  while (!$_matched && !$commit)
  {

    Parse::RecDescent::_trace(q{Trying production: [/^\\s*-\{2\}.*\\n/]},
            Parse::RecDescent::_tracefirst($_[1]),
            q{comment},
            $tracelevel)
            if defined $::RD_TRACE;
    my $thisprod = $thisrule->{"prods"}[0];
    $text = $_[1];
    my $_savetext;
    @item = (q{comment});
    %item = (__RULE__ => q{comment});
    my $repcount = 0;


    Parse::RecDescent::_trace(q{Trying terminal: [/^\\s*-\{2\}.*\\n/]}, Parse::RecDescent::_tracefirst($text),
            q{comment},
            $tracelevel)
            if defined $::RD_TRACE;
    $lastsep = "";
    $expectation->is(q{})->at($text);


    unless ($text =~ s/\A($skip)/$lastsep=$1 and ""/e and   $text =~ s/\A(?:^\s*-{2}.*\n)//)
    {

      $expectation->failed();
      Parse::RecDescent::_trace(q{<<Didn't match terminal>>},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;

      last;
    }
    Parse::RecDescent::_trace(q{>>Matched terminal<< (return value: [}
            . $& . q{])},
              Parse::RecDescent::_tracefirst($text))
          if defined $::RD_TRACE;
    push @item, $item{__PATTERN1__}=$&;


    Parse::RecDescent::_trace(q{Trying action},
            Parse::RecDescent::_tracefirst($text),
            q{comment},
            $tracelevel)
            if defined $::RD_TRACE;


    $_tok = ($_noactions) ? 0 : do {
        my $comment =  $item[1];
        $comment    =~ s/^\s*(-{2})\s*//;
        $comment    =~ s/\s*$//;
        $return     = $comment;
    };
    unless (defined $_tok)
    {
      Parse::RecDescent::_trace(q{<<Didn't match action>> (return value: [undef])})
          if defined $::RD_TRACE;
      last;
    }
    Parse::RecDescent::_trace(q{>>Matched action<< (return value: [}
            . $_tok . q{])},
            Parse::RecDescent::_tracefirst($text))
            if defined $::RD_TRACE;
    push @item, $_tok;
    $item{__ACTION1__}=$_tok;



    Parse::RecDescent::_trace(q{>>Matched production: [/^\\s*-\{2\}.*\\n/]<<},
            Parse::RecDescent::_tracefirst($text),
            q{comment},
            $tracelevel)
            if defined $::RD_TRACE;
    $_matched = 1;
    last;
  }


        unless ( $_matched || defined($return) || defined($score) )
  {


    $_[1] = $text;  # NOT SURE THIS IS NEEDED
    Parse::RecDescent::_trace(q{<<Didn't match rule>>},
           Parse::RecDescent::_tracefirst($_[1]),
           q{comment},
           $tracelevel)
          if defined $::RD_TRACE;
    return undef;
  }
  if (!defined($return) && defined($score))
  {
    Parse::RecDescent::_trace(q{>>Accepted scored production<<}, "",
            q{comment},
            $tracelevel)
            if defined $::RD_TRACE;
    $return = $score_return;
  }
  splice @{$thisparser->{errors}}, $err_at;
  $return = $item[$#item] unless defined $return;
  if (defined $::RD_TRACE)
  {
    Parse::RecDescent::_trace(q{>>Matched rule<< (return value: [} .
            $return . q{])}, "",
            q{comment},
            $tracelevel);
    Parse::RecDescent::_trace(q{(consumed: [} .
            Parse::RecDescent::_tracemax(substr($_[1],0,-length($text))) . q{])},
            Parse::RecDescent::_tracefirst($text),
            , q{comment},
            $tracelevel)
  }
  $_[1] = $text;
  return $return;
}
}
package SQL::Translator::Parser::DB2::Grammar; sub new { my $self = bless( {
                 '_AUTOTREE' => undef,
                 'localvars' => '',
                 'startcode' => '',
                 '_check' => {
                               'thisoffset' => '',
                               'itempos' => '',
                               'prevoffset' => '',
                               'prevline' => '',
                               'prevcolumn' => '',
                               'thiscolumn' => ''
                             },
                 'namespace' => 'Parse::RecDescent::SQL::Translator::Parser::DB2::Grammar',
                 '_AUTOACTION' => undef,
                 'rules' => {
                              '_alternation_1_of_production_17_of_rule_sysibm_function' => bless( {
                                                                                                    'impcount' => 0,
                                                                                                    'calls' => [],
                                                                                                    'changed' => 0,
                                                                                                    'opcount' => 0,
                                                                                                    'prods' => [
                                                                                                                 bless( {
                                                                                                                          'number' => '0',
                                                                                                                          'strcount' => 0,
                                                                                                                          'dircount' => 0,
                                                                                                                          'uncommit' => undef,
                                                                                                                          'error' => undef,
                                                                                                                          'patcount' => 1,
                                                                                                                          'actcount' => 0,
                                                                                                                          'items' => [
                                                                                                                                       bless( {
                                                                                                                                                'pattern' => 'DECIMAL',
                                                                                                                                                'hashname' => '__PATTERN1__',
                                                                                                                                                'description' => '/DECIMAL/i',
                                                                                                                                                'lookahead' => 0,
                                                                                                                                                'rdelim' => '/',
                                                                                                                                                'line' => 628,
                                                                                                                                                'mod' => 'i',
                                                                                                                                                'ldelim' => '/'
                                                                                                                                              }, 'Parse::RecDescent::Token' )
                                                                                                                                     ],
                                                                                                                          'line' => undef
                                                                                                                        }, 'Parse::RecDescent::Production' ),
                                                                                                                 bless( {
                                                                                                                          'number' => '1',
                                                                                                                          'strcount' => 0,
                                                                                                                          'dircount' => 0,
                                                                                                                          'uncommit' => undef,
                                                                                                                          'error' => undef,
                                                                                                                          'patcount' => 1,
                                                                                                                          'actcount' => 0,
                                                                                                                          'items' => [
                                                                                                                                       bless( {
                                                                                                                                                'pattern' => 'DEC',
                                                                                                                                                'hashname' => '__PATTERN1__',
                                                                                                                                                'description' => '/DEC/i',
                                                                                                                                                'lookahead' => 0,
                                                                                                                                                'rdelim' => '/',
                                                                                                                                                'line' => 628,
                                                                                                                                                'mod' => 'i',
                                                                                                                                                'ldelim' => '/'
                                                                                                                                              }, 'Parse::RecDescent::Token' )
                                                                                                                                     ],
                                                                                                                          'line' => 628
                                                                                                                        }, 'Parse::RecDescent::Production' )
                                                                                                               ],
                                                                                                    'name' => '_alternation_1_of_production_17_of_rule_sysibm_function',
                                                                                                    'vars' => '',
                                                                                                    'line' => 628
                                                                                                  }, 'Parse::RecDescent::Rule' ),
                              'triggered_action' => bless( {
                                                             'impcount' => 0,
                                                             'calls' => [
                                                                          'when_clause',
                                                                          'SQL_procedure_statement'
                                                                        ],
                                                             'changed' => 0,
                                                             'opcount' => 0,
                                                             'prods' => [
                                                                          bless( {
                                                                                   'number' => '0',
                                                                                   'strcount' => 0,
                                                                                   'dircount' => 0,
                                                                                   'uncommit' => undef,
                                                                                   'error' => undef,
                                                                                   'patcount' => 0,
                                                                                   'actcount' => 1,
                                                                                   'items' => [
                                                                                                bless( {
                                                                                                         'subrule' => 'when_clause',
                                                                                                         'expected' => undef,
                                                                                                         'min' => 0,
                                                                                                         'argcode' => undef,
                                                                                                         'max' => 1,
                                                                                                         'matchrule' => 0,
                                                                                                         'repspec' => '?',
                                                                                                         'lookahead' => 0,
                                                                                                         'line' => 263
                                                                                                       }, 'Parse::RecDescent::Repetition' ),
                                                                                                bless( {
                                                                                                         'subrule' => 'SQL_procedure_statement',
                                                                                                         'matchrule' => 0,
                                                                                                         'implicit' => undef,
                                                                                                         'argcode' => undef,
                                                                                                         'lookahead' => 0,
                                                                                                         'line' => 263
                                                                                                       }, 'Parse::RecDescent::Subrule' ),
                                                                                                bless( {
                                                                                                         'hashname' => '__ACTION1__',
                                                                                                         'lookahead' => 0,
                                                                                                         'line' => 264,
                                                                                                         'code' => '{ $return = { \'condition\' => $item[1][0],
              \'statement\' => $item{\'SQL_procedure_statement\'} };
}'
                                                                                                       }, 'Parse::RecDescent::Action' )
                                                                                              ],
                                                                                   'line' => undef
                                                                                 }, 'Parse::RecDescent::Production' )
                                                                        ],
                                                             'name' => 'triggered_action',
                                                             'vars' => '',
                                                             'line' => 263
                                                           }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_2_of_rule_search_condition' => bless( {
                                                                                                    'impcount' => 0,
                                                                                                    'calls' => [
                                                                                                                 'predicate',
                                                                                                                 '_alternation_1_of_production_1_of_rule__alternation_1_of_production_2_of_rule_search_condition',
                                                                                                                 'search_condition'
                                                                                                               ],
                                                                                                    'changed' => 0,
                                                                                                    'opcount' => 0,
                                                                                                    'prods' => [
                                                                                                                 bless( {
                                                                                                                          'number' => '0',
                                                                                                                          'strcount' => 0,
                                                                                                                          'dircount' => 0,
                                                                                                                          'uncommit' => undef,
                                                                                                                          'error' => undef,
                                                                                                                          'patcount' => 0,
                                                                                                                          'actcount' => 0,
                                                                                                                          'items' => [
                                                                                                                                       bless( {
                                                                                                                                                'subrule' => 'predicate',
                                                                                                                                                'matchrule' => 0,
                                                                                                                                                'implicit' => undef,
                                                                                                                                                'argcode' => undef,
                                                                                                                                                'lookahead' => 0,
                                                                                                                                                'line' => 628
                                                                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                                                                       bless( {
                                                                                                                                                'subrule' => '_alternation_1_of_production_1_of_rule__alternation_1_of_production_2_of_rule_search_condition',
                                                                                                                                                'expected' => '/SELECTIVITY/i',
                                                                                                                                                'min' => 0,
                                                                                                                                                'argcode' => undef,
                                                                                                                                                'max' => 1,
                                                                                                                                                'matchrule' => 0,
                                                                                                                                                'repspec' => '?',
                                                                                                                                                'lookahead' => 0,
                                                                                                                                                'line' => 628
                                                                                                                                              }, 'Parse::RecDescent::Repetition' )
                                                                                                                                     ],
                                                                                                                          'line' => undef
                                                                                                                        }, 'Parse::RecDescent::Production' ),
                                                                                                                 bless( {
                                                                                                                          'number' => '1',
                                                                                                                          'strcount' => 2,
                                                                                                                          'dircount' => 0,
                                                                                                                          'uncommit' => undef,
                                                                                                                          'error' => undef,
                                                                                                                          'patcount' => 0,
                                                                                                                          'actcount' => 0,
                                                                                                                          'items' => [
                                                                                                                                       bless( {
                                                                                                                                                'pattern' => '(',
                                                                                                                                                'hashname' => '__STRING1__',
                                                                                                                                                'description' => '\'(\'',
                                                                                                                                                'lookahead' => 0,
                                                                                                                                                'line' => 628
                                                                                                                                              }, 'Parse::RecDescent::Literal' ),
                                                                                                                                       bless( {
                                                                                                                                                'subrule' => 'search_condition',
                                                                                                                                                'matchrule' => 0,
                                                                                                                                                'implicit' => undef,
                                                                                                                                                'argcode' => undef,
                                                                                                                                                'lookahead' => 0,
                                                                                                                                                'line' => 628
                                                                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                                                                       bless( {
                                                                                                                                                'pattern' => ')',
                                                                                                                                                'hashname' => '__STRING2__',
                                                                                                                                                'description' => '\')\'',
                                                                                                                                                'lookahead' => 0,
                                                                                                                                                'line' => 628
                                                                                                                                              }, 'Parse::RecDescent::Literal' )
                                                                                                                                     ],
                                                                                                                          'line' => 628
                                                                                                                        }, 'Parse::RecDescent::Production' )
                                                                                                               ],
                                                                                                    'name' => '_alternation_1_of_production_2_of_rule_search_condition',
                                                                                                    'vars' => '',
                                                                                                    'line' => 628
                                                                                                  }, 'Parse::RecDescent::Rule' ),
                              'name1' => bless( {
                                                  'impcount' => 0,
                                                  'calls' => [
                                                               'NAME'
                                                             ],
                                                  'changed' => 0,
                                                  'opcount' => 0,
                                                  'prods' => [
                                                               bless( {
                                                                        'number' => '0',
                                                                        'strcount' => 0,
                                                                        'dircount' => 0,
                                                                        'uncommit' => undef,
                                                                        'error' => undef,
                                                                        'patcount' => 0,
                                                                        'actcount' => 0,
                                                                        'items' => [
                                                                                     bless( {
                                                                                              'subrule' => 'NAME',
                                                                                              'matchrule' => 0,
                                                                                              'implicit' => undef,
                                                                                              'argcode' => undef,
                                                                                              'lookahead' => 0,
                                                                                              'line' => 536
                                                                                            }, 'Parse::RecDescent::Subrule' )
                                                                                   ],
                                                                        'line' => undef
                                                                      }, 'Parse::RecDescent::Production' )
                                                             ],
                                                  'name' => 'name1',
                                                  'vars' => '',
                                                  'line' => 536
                                                }, 'Parse::RecDescent::Rule' ),
                              '_alternation_2_of_production_1_of_rule_cond' => bless( {
                                                                                        'impcount' => 0,
                                                                                        'calls' => [
                                                                                                     'predicate',
                                                                                                     '_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cond',
                                                                                                     'search_condition'
                                                                                                   ],
                                                                                        'changed' => 0,
                                                                                        'opcount' => 0,
                                                                                        'prods' => [
                                                                                                     bless( {
                                                                                                              'number' => '0',
                                                                                                              'strcount' => 0,
                                                                                                              'dircount' => 0,
                                                                                                              'uncommit' => undef,
                                                                                                              'error' => undef,
                                                                                                              'patcount' => 0,
                                                                                                              'actcount' => 0,
                                                                                                              'items' => [
                                                                                                                           bless( {
                                                                                                                                    'subrule' => 'predicate',
                                                                                                                                    'matchrule' => 0,
                                                                                                                                    'implicit' => undef,
                                                                                                                                    'argcode' => undef,
                                                                                                                                    'lookahead' => 0,
                                                                                                                                    'line' => 628
                                                                                                                                  }, 'Parse::RecDescent::Subrule' ),
                                                                                                                           bless( {
                                                                                                                                    'subrule' => '_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cond',
                                                                                                                                    'expected' => '/SELECTIVITY/i',
                                                                                                                                    'min' => 0,
                                                                                                                                    'argcode' => undef,
                                                                                                                                    'max' => 1,
                                                                                                                                    'matchrule' => 0,
                                                                                                                                    'repspec' => '?',
                                                                                                                                    'lookahead' => 0,
                                                                                                                                    'line' => 628
                                                                                                                                  }, 'Parse::RecDescent::Repetition' )
                                                                                                                         ],
                                                                                                              'line' => undef
                                                                                                            }, 'Parse::RecDescent::Production' ),
                                                                                                     bless( {
                                                                                                              'number' => '1',
                                                                                                              'strcount' => 2,
                                                                                                              'dircount' => 0,
                                                                                                              'uncommit' => undef,
                                                                                                              'error' => undef,
                                                                                                              'patcount' => 0,
                                                                                                              'actcount' => 0,
                                                                                                              'items' => [
                                                                                                                           bless( {
                                                                                                                                    'pattern' => '(',
                                                                                                                                    'hashname' => '__STRING1__',
                                                                                                                                    'description' => '\'(\'',
                                                                                                                                    'lookahead' => 0,
                                                                                                                                    'line' => 628
                                                                                                                                  }, 'Parse::RecDescent::Literal' ),
                                                                                                                           bless( {
                                                                                                                                    'subrule' => 'search_condition',
                                                                                                                                    'matchrule' => 0,
                                                                                                                                    'implicit' => undef,
                                                                                                                                    'argcode' => undef,
                                                                                                                                    'lookahead' => 0,
                                                                                                                                    'line' => 628
                                                                                                                                  }, 'Parse::RecDescent::Subrule' ),
                                                                                                                           bless( {
                                                                                                                                    'pattern' => ')',
                                                                                                                                    'hashname' => '__STRING2__',
                                                                                                                                    'description' => '\')\'',
                                                                                                                                    'lookahead' => 0,
                                                                                                                                    'line' => 628
                                                                                                                                  }, 'Parse::RecDescent::Literal' )
                                                                                                                         ],
                                                                                                              'line' => 628
                                                                                                            }, 'Parse::RecDescent::Production' )
                                                                                                   ],
                                                                                        'name' => '_alternation_2_of_production_1_of_rule_cond',
                                                                                        'vars' => '',
                                                                                        'line' => 628
                                                                                      }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule_expression' => bless( {
                                                                                              'impcount' => 2,
                                                                                              'calls' => [
                                                                                                           '_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression',
                                                                                                           '_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression'
                                                                                                         ],
                                                                                              'changed' => 0,
                                                                                              'opcount' => 0,
                                                                                              'prods' => [
                                                                                                           bless( {
                                                                                                                    'number' => '0',
                                                                                                                    'strcount' => 0,
                                                                                                                    'dircount' => 0,
                                                                                                                    'uncommit' => undef,
                                                                                                                    'error' => undef,
                                                                                                                    'patcount' => 0,
                                                                                                                    'actcount' => 0,
                                                                                                                    'items' => [
                                                                                                                                 bless( {
                                                                                                                                          'subrule' => '_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression',
                                                                                                                                          'expected' => '\'+\', or \'-\'',
                                                                                                                                          'min' => 0,
                                                                                                                                          'argcode' => undef,
                                                                                                                                          'max' => 1,
                                                                                                                                          'matchrule' => 0,
                                                                                                                                          'repspec' => '?',
                                                                                                                                          'lookahead' => 0,
                                                                                                                                          'line' => 611
                                                                                                                                        }, 'Parse::RecDescent::Repetition' ),
                                                                                                                                 bless( {
                                                                                                                                          'subrule' => '_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression',
                                                                                                                                          'matchrule' => 0,
                                                                                                                                          'implicit' => 'function, or \'(\', or constant, or column_name, or host_variable, or special_register, or labeled_duration, or case_expression, or cast_specification, or OLAP_function, or method_invocation, or subtype_treatment, or sequence_reference',
                                                                                                                                          'argcode' => undef,
                                                                                                                                          'lookahead' => 0,
                                                                                                                                          'line' => 627
                                                                                                                                        }, 'Parse::RecDescent::Subrule' )
                                                                                                                               ],
                                                                                                                    'line' => undef
                                                                                                                  }, 'Parse::RecDescent::Production' )
                                                                                                         ],
                                                                                              'name' => '_alternation_1_of_production_1_of_rule_expression',
                                                                                              'vars' => '',
                                                                                              'line' => 608
                                                                                            }, 'Parse::RecDescent::Rule' ),
                              'SCHEMA' => bless( {
                                                   'impcount' => 0,
                                                   'calls' => [],
                                                   'changed' => 0,
                                                   'opcount' => 0,
                                                   'prods' => [
                                                                bless( {
                                                                         'number' => '0',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => '\\w+',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/\\\\w+/',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 142,
                                                                                               'mod' => '',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => undef
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '1',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => '\\w{1,128}',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/\\\\w\\{1,128\\}/',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 144,
                                                                                               'mod' => '',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => undef
                                                                       }, 'Parse::RecDescent::Production' )
                                                              ],
                                                   'name' => 'SCHEMA',
                                                   'vars' => '',
                                                   'line' => 142
                                                 }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_87_of_rule_sysibm_function' => bless( {
                                                                                                    'impcount' => 0,
                                                                                                    'calls' => [],
                                                                                                    'changed' => 0,
                                                                                                    'opcount' => 0,
                                                                                                    'prods' => [
                                                                                                                 bless( {
                                                                                                                          'number' => '0',
                                                                                                                          'strcount' => 0,
                                                                                                                          'dircount' => 0,
                                                                                                                          'uncommit' => undef,
                                                                                                                          'error' => undef,
                                                                                                                          'patcount' => 1,
                                                                                                                          'actcount' => 0,
                                                                                                                          'items' => [
                                                                                                                                       bless( {
                                                                                                                                                'pattern' => 'VARIANCE',
                                                                                                                                                'hashname' => '__PATTERN1__',
                                                                                                                                                'description' => '/VARIANCE/i',
                                                                                                                                                'lookahead' => 0,
                                                                                                                                                'rdelim' => '/',
                                                                                                                                                'line' => 628,
                                                                                                                                                'mod' => 'i',
                                                                                                                                                'ldelim' => '/'
                                                                                                                                              }, 'Parse::RecDescent::Token' )
                                                                                                                                     ],
                                                                                                                          'line' => undef
                                                                                                                        }, 'Parse::RecDescent::Production' ),
                                                                                                                 bless( {
                                                                                                                          'number' => '1',
                                                                                                                          'strcount' => 0,
                                                                                                                          'dircount' => 0,
                                                                                                                          'uncommit' => undef,
                                                                                                                          'error' => undef,
                                                                                                                          'patcount' => 1,
                                                                                                                          'actcount' => 0,
                                                                                                                          'items' => [
                                                                                                                                       bless( {
                                                                                                                                                'pattern' => 'VAR',
                                                                                                                                                'hashname' => '__PATTERN1__',
                                                                                                                                                'description' => '/VAR/i',
                                                                                                                                                'lookahead' => 0,
                                                                                                                                                'rdelim' => '/',
                                                                                                                                                'line' => 628,
                                                                                                                                                'mod' => 'i',
                                                                                                                                                'ldelim' => '/'
                                                                                                                                              }, 'Parse::RecDescent::Token' )
                                                                                                                                     ],
                                                                                                                          'line' => 628
                                                                                                                        }, 'Parse::RecDescent::Production' )
                                                                                                               ],
                                                                                                    'name' => '_alternation_1_of_production_87_of_rule_sysibm_function',
                                                                                                    'vars' => '',
                                                                                                    'line' => 628
                                                                                                  }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression' => bless( {
                                                                                                                                     'impcount' => 0,
                                                                                                                                     'calls' => [],
                                                                                                                                     'changed' => 0,
                                                                                                                                     'opcount' => 0,
                                                                                                                                     'prods' => [
                                                                                                                                                  bless( {
                                                                                                                                                           'number' => '0',
                                                                                                                                                           'strcount' => 1,
                                                                                                                                                           'dircount' => 0,
                                                                                                                                                           'uncommit' => undef,
                                                                                                                                                           'error' => undef,
                                                                                                                                                           'patcount' => 0,
                                                                                                                                                           'actcount' => 0,
                                                                                                                                                           'items' => [
                                                                                                                                                                        bless( {
                                                                                                                                                                                 'pattern' => '+',
                                                                                                                                                                                 'hashname' => '__STRING1__',
                                                                                                                                                                                 'description' => '\'+\'',
                                                                                                                                                                                 'lookahead' => 0,
                                                                                                                                                                                 'line' => 626
                                                                                                                                                                               }, 'Parse::RecDescent::Literal' )
                                                                                                                                                                      ],
                                                                                                                                                           'line' => undef
                                                                                                                                                         }, 'Parse::RecDescent::Production' ),
                                                                                                                                                  bless( {
                                                                                                                                                           'number' => '1',
                                                                                                                                                           'strcount' => 1,
                                                                                                                                                           'dircount' => 0,
                                                                                                                                                           'uncommit' => undef,
                                                                                                                                                           'error' => undef,
                                                                                                                                                           'patcount' => 0,
                                                                                                                                                           'actcount' => 0,
                                                                                                                                                           'items' => [
                                                                                                                                                                        bless( {
                                                                                                                                                                                 'pattern' => '-',
                                                                                                                                                                                 'hashname' => '__STRING1__',
                                                                                                                                                                                 'description' => '\'-\'',
                                                                                                                                                                                 'lookahead' => 0,
                                                                                                                                                                                 'line' => 627
                                                                                                                                                                               }, 'Parse::RecDescent::Literal' )
                                                                                                                                                                      ],
                                                                                                                                                           'line' => 627
                                                                                                                                                         }, 'Parse::RecDescent::Production' )
                                                                                                                                                ],
                                                                                                                                     'name' => '_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression',
                                                                                                                                     'vars' => '',
                                                                                                                                     'line' => 626
                                                                                                                                   }, 'Parse::RecDescent::Rule' ),
                              'get_bracketed' => bless( {
                                                          'impcount' => 0,
                                                          'calls' => [],
                                                          'changed' => 0,
                                                          'opcount' => 0,
                                                          'prods' => [
                                                                       bless( {
                                                                                'number' => '0',
                                                                                'strcount' => 0,
                                                                                'dircount' => 0,
                                                                                'uncommit' => undef,
                                                                                'error' => undef,
                                                                                'patcount' => 0,
                                                                                'actcount' => 1,
                                                                                'items' => [
                                                                                             bless( {
                                                                                                      'hashname' => '__ACTION1__',
                                                                                                      'lookahead' => 0,
                                                                                                      'line' => 170,
                                                                                                      'code' => '{
    extract_bracketed($text, \'(\');
}'
                                                                                                    }, 'Parse::RecDescent::Action' )
                                                                                           ],
                                                                                'line' => undef
                                                                              }, 'Parse::RecDescent::Production' )
                                                                     ],
                                                          'name' => 'get_bracketed',
                                                          'vars' => '',
                                                          'line' => 169
                                                        }, 'Parse::RecDescent::Rule' ),
                              'labeled_duration' => bless( {
                                                             'impcount' => 0,
                                                             'calls' => [
                                                                          'ld_type',
                                                                          'ld_duration'
                                                                        ],
                                                             'changed' => 0,
                                                             'opcount' => 0,
                                                             'prods' => [
                                                                          bless( {
                                                                                   'number' => '0',
                                                                                   'strcount' => 0,
                                                                                   'dircount' => 0,
                                                                                   'uncommit' => undef,
                                                                                   'error' => undef,
                                                                                   'patcount' => 0,
                                                                                   'actcount' => 0,
                                                                                   'items' => [
                                                                                                bless( {
                                                                                                         'subrule' => 'ld_type',
                                                                                                         'matchrule' => 0,
                                                                                                         'implicit' => undef,
                                                                                                         'argcode' => undef,
                                                                                                         'lookahead' => 0,
                                                                                                         'line' => 480
                                                                                                       }, 'Parse::RecDescent::Subrule' ),
                                                                                                bless( {
                                                                                                         'subrule' => 'ld_duration',
                                                                                                         'matchrule' => 0,
                                                                                                         'implicit' => undef,
                                                                                                         'argcode' => undef,
                                                                                                         'lookahead' => 0,
                                                                                                         'line' => 480
                                                                                                       }, 'Parse::RecDescent::Subrule' )
                                                                                              ],
                                                                                   'line' => undef
                                                                                 }, 'Parse::RecDescent::Production' )
                                                                        ],
                                                             'name' => 'labeled_duration',
                                                             'vars' => '',
                                                             'line' => 480
                                                           }, 'Parse::RecDescent::Rule' ),
                              'group_end' => bless( {
                                                      'impcount' => 0,
                                                      'calls' => [
                                                                   'unsigned_constant'
                                                                 ],
                                                      'changed' => 0,
                                                      'opcount' => 0,
                                                      'prods' => [
                                                                   bless( {
                                                                            'number' => '0',
                                                                            'strcount' => 0,
                                                                            'dircount' => 0,
                                                                            'uncommit' => undef,
                                                                            'error' => undef,
                                                                            'patcount' => 1,
                                                                            'actcount' => 0,
                                                                            'items' => [
                                                                                         bless( {
                                                                                                  'pattern' => 'UNBOUNDED\\s+PRECEDING',
                                                                                                  'hashname' => '__PATTERN1__',
                                                                                                  'description' => '/UNBOUNDED\\\\s+PRECEDING/i',
                                                                                                  'lookahead' => 0,
                                                                                                  'rdelim' => '/',
                                                                                                  'line' => 590,
                                                                                                  'mod' => 'i',
                                                                                                  'ldelim' => '/'
                                                                                                }, 'Parse::RecDescent::Token' )
                                                                                       ],
                                                                            'line' => undef
                                                                          }, 'Parse::RecDescent::Production' ),
                                                                   bless( {
                                                                            'number' => '1',
                                                                            'strcount' => 0,
                                                                            'dircount' => 0,
                                                                            'uncommit' => undef,
                                                                            'error' => undef,
                                                                            'patcount' => 1,
                                                                            'actcount' => 0,
                                                                            'items' => [
                                                                                         bless( {
                                                                                                  'subrule' => 'unsigned_constant',
                                                                                                  'matchrule' => 0,
                                                                                                  'implicit' => undef,
                                                                                                  'argcode' => undef,
                                                                                                  'lookahead' => 0,
                                                                                                  'line' => 591
                                                                                                }, 'Parse::RecDescent::Subrule' ),
                                                                                         bless( {
                                                                                                  'pattern' => 'FOLLOWING',
                                                                                                  'hashname' => '__PATTERN1__',
                                                                                                  'description' => '/FOLLOWING/i',
                                                                                                  'lookahead' => 0,
                                                                                                  'rdelim' => '/',
                                                                                                  'line' => 591,
                                                                                                  'mod' => 'i',
                                                                                                  'ldelim' => '/'
                                                                                                }, 'Parse::RecDescent::Token' )
                                                                                       ],
                                                                            'line' => 591
                                                                          }, 'Parse::RecDescent::Production' )
                                                                 ],
                                                      'name' => 'group_end',
                                                      'vars' => '',
                                                      'line' => 590
                                                    }, 'Parse::RecDescent::Rule' ),
                              'statement' => bless( {
                                                      'impcount' => 0,
                                                      'calls' => [
                                                                   'comment',
                                                                   'create'
                                                                 ],
                                                      'changed' => 0,
                                                      'opcount' => 0,
                                                      'prods' => [
                                                                   bless( {
                                                                            'number' => '0',
                                                                            'strcount' => 0,
                                                                            'dircount' => 0,
                                                                            'uncommit' => undef,
                                                                            'error' => undef,
                                                                            'patcount' => 0,
                                                                            'actcount' => 0,
                                                                            'items' => [
                                                                                         bless( {
                                                                                                  'subrule' => 'comment',
                                                                                                  'matchrule' => 0,
                                                                                                  'implicit' => undef,
                                                                                                  'argcode' => undef,
                                                                                                  'lookahead' => 0,
                                                                                                  'line' => 23
                                                                                                }, 'Parse::RecDescent::Subrule' )
                                                                                       ],
                                                                            'line' => undef
                                                                          }, 'Parse::RecDescent::Production' ),
                                                                   bless( {
                                                                            'number' => '1',
                                                                            'strcount' => 0,
                                                                            'dircount' => 0,
                                                                            'uncommit' => undef,
                                                                            'error' => undef,
                                                                            'patcount' => 0,
                                                                            'actcount' => 0,
                                                                            'items' => [
                                                                                         bless( {
                                                                                                  'subrule' => 'create',
                                                                                                  'matchrule' => 0,
                                                                                                  'implicit' => undef,
                                                                                                  'argcode' => undef,
                                                                                                  'lookahead' => 0,
                                                                                                  'line' => 24
                                                                                                }, 'Parse::RecDescent::Subrule' )
                                                                                       ],
                                                                            'line' => 24
                                                                          }, 'Parse::RecDescent::Production' ),
                                                                   bless( {
                                                                            'number' => '2',
                                                                            'strcount' => 0,
                                                                            'dircount' => 1,
                                                                            'uncommit' => 0,
                                                                            'error' => 1,
                                                                            'patcount' => 0,
                                                                            'actcount' => 0,
                                                                            'items' => [
                                                                                         bless( {
                                                                                                  'msg' => '',
                                                                                                  'hashname' => '__DIRECTIVE1__',
                                                                                                  'commitonly' => '',
                                                                                                  'lookahead' => 0,
                                                                                                  'line' => 25
                                                                                                }, 'Parse::RecDescent::Error' )
                                                                                       ],
                                                                            'line' => 25
                                                                          }, 'Parse::RecDescent::Production' )
                                                                 ],
                                                      'name' => 'statement',
                                                      'vars' => '',
                                                      'line' => 22
                                                    }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_simple_when_clause' => bless( {
                                                                                                                                             'impcount' => 0,
                                                                                                                                             'calls' => [
                                                                                                                                                          'result_expression'
                                                                                                                                                        ],
                                                                                                                                             'changed' => 0,
                                                                                                                                             'opcount' => 0,
                                                                                                                                             'prods' => [
                                                                                                                                                          bless( {
                                                                                                                                                                   'number' => '0',
                                                                                                                                                                   'strcount' => 0,
                                                                                                                                                                   'dircount' => 0,
                                                                                                                                                                   'uncommit' => undef,
                                                                                                                                                                   'error' => undef,
                                                                                                                                                                   'patcount' => 0,
                                                                                                                                                                   'actcount' => 0,
                                                                                                                                                                   'items' => [
                                                                                                                                                                                bless( {
                                                                                                                                                                                         'subrule' => 'result_expression',
                                                                                                                                                                                         'matchrule' => 0,
                                                                                                                                                                                         'implicit' => undef,
                                                                                                                                                                                         'argcode' => undef,
                                                                                                                                                                                         'lookahead' => 0,
                                                                                                                                                                                         'line' => 626
                                                                                                                                                                                       }, 'Parse::RecDescent::Subrule' )
                                                                                                                                                                              ],
                                                                                                                                                                   'line' => undef
                                                                                                                                                                 }, 'Parse::RecDescent::Production' ),
                                                                                                                                                          bless( {
                                                                                                                                                                   'number' => '1',
                                                                                                                                                                   'strcount' => 0,
                                                                                                                                                                   'dircount' => 0,
                                                                                                                                                                   'uncommit' => undef,
                                                                                                                                                                   'error' => undef,
                                                                                                                                                                   'patcount' => 1,
                                                                                                                                                                   'actcount' => 0,
                                                                                                                                                                   'items' => [
                                                                                                                                                                                bless( {
                                                                                                                                                                                         'pattern' => 'NULL',
                                                                                                                                                                                         'hashname' => '__PATTERN1__',
                                                                                                                                                                                         'description' => '/NULL/i',
                                                                                                                                                                                         'lookahead' => 0,
                                                                                                                                                                                         'rdelim' => '/',
                                                                                                                                                                                         'line' => 627,
                                                                                                                                                                                         'mod' => 'i',
                                                                                                                                                                                         'ldelim' => '/'
                                                                                                                                                                                       }, 'Parse::RecDescent::Token' )
                                                                                                                                                                              ],
                                                                                                                                                                   'line' => 627
                                                                                                                                                                 }, 'Parse::RecDescent::Production' )
                                                                                                                                                        ],
                                                                                                                                             'name' => '_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_simple_when_clause',
                                                                                                                                             'vars' => '',
                                                                                                                                             'line' => 626
                                                                                                                                           }, 'Parse::RecDescent::Rule' ),
                              '_alternation_2_of_production_1_of_rule_case_expression' => bless( {
                                                                                                   'impcount' => 0,
                                                                                                   'calls' => [
                                                                                                                'result_expression'
                                                                                                              ],
                                                                                                   'changed' => 0,
                                                                                                   'opcount' => 0,
                                                                                                   'prods' => [
                                                                                                                bless( {
                                                                                                                         'number' => '0',
                                                                                                                         'strcount' => 0,
                                                                                                                         'dircount' => 0,
                                                                                                                         'uncommit' => undef,
                                                                                                                         'error' => undef,
                                                                                                                         'patcount' => 1,
                                                                                                                         'actcount' => 0,
                                                                                                                         'items' => [
                                                                                                                                      bless( {
                                                                                                                                               'pattern' => 'ELSE\\s+NULL',
                                                                                                                                               'hashname' => '__PATTERN1__',
                                                                                                                                               'description' => '/ELSE\\\\s+NULL/i',
                                                                                                                                               'lookahead' => 0,
                                                                                                                                               'rdelim' => '/',
                                                                                                                                               'line' => 626,
                                                                                                                                               'mod' => 'i',
                                                                                                                                               'ldelim' => '/'
                                                                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                                                                    ],
                                                                                                                         'line' => undef
                                                                                                                       }, 'Parse::RecDescent::Production' ),
                                                                                                                bless( {
                                                                                                                         'number' => '1',
                                                                                                                         'strcount' => 0,
                                                                                                                         'dircount' => 0,
                                                                                                                         'uncommit' => undef,
                                                                                                                         'error' => undef,
                                                                                                                         'patcount' => 1,
                                                                                                                         'actcount' => 0,
                                                                                                                         'items' => [
                                                                                                                                      bless( {
                                                                                                                                               'pattern' => 'ELSE',
                                                                                                                                               'hashname' => '__PATTERN1__',
                                                                                                                                               'description' => '/ELSE/i',
                                                                                                                                               'lookahead' => 0,
                                                                                                                                               'rdelim' => '/',
                                                                                                                                               'line' => 627,
                                                                                                                                               'mod' => 'i',
                                                                                                                                               'ldelim' => '/'
                                                                                                                                             }, 'Parse::RecDescent::Token' ),
                                                                                                                                      bless( {
                                                                                                                                               'subrule' => 'result_expression',
                                                                                                                                               'matchrule' => 0,
                                                                                                                                               'implicit' => undef,
                                                                                                                                               'argcode' => undef,
                                                                                                                                               'lookahead' => 0,
                                                                                                                                               'line' => 627
                                                                                                                                             }, 'Parse::RecDescent::Subrule' )
                                                                                                                                    ],
                                                                                                                         'line' => 627
                                                                                                                       }, 'Parse::RecDescent::Production' )
                                                                                                              ],
                                                                                                   'name' => '_alternation_2_of_production_1_of_rule_case_expression',
                                                                                                   'vars' => '',
                                                                                                   'line' => 626
                                                                                                 }, 'Parse::RecDescent::Rule' ),
                              'subject_expression' => bless( {
                                                               'impcount' => 0,
                                                               'calls' => [
                                                                            'expression'
                                                                          ],
                                                               'changed' => 0,
                                                               'opcount' => 0,
                                                               'prods' => [
                                                                            bless( {
                                                                                     'number' => '0',
                                                                                     'strcount' => 0,
                                                                                     'dircount' => 0,
                                                                                     'uncommit' => undef,
                                                                                     'error' => undef,
                                                                                     'patcount' => 0,
                                                                                     'actcount' => 1,
                                                                                     'items' => [
                                                                                                  bless( {
                                                                                                           'subrule' => 'expression',
                                                                                                           'matchrule' => 0,
                                                                                                           'implicit' => undef,
                                                                                                           'argcode' => undef,
                                                                                                           'lookahead' => 0,
                                                                                                           'line' => 598
                                                                                                         }, 'Parse::RecDescent::Subrule' ),
                                                                                                  bless( {
                                                                                                           'hashname' => '__ACTION1__',
                                                                                                           'lookahead' => 0,
                                                                                                           'line' => 599,
                                                                                                           'code' => '{ # with static result type that is a used-defined struct type
}'
                                                                                                         }, 'Parse::RecDescent::Action' )
                                                                                                ],
                                                                                     'line' => undef
                                                                                   }, 'Parse::RecDescent::Production' )
                                                                          ],
                                                               'name' => 'subject_expression',
                                                               'vars' => '',
                                                               'line' => 598
                                                             }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule_desc_option' => bless( {
                                                                                               'impcount' => 0,
                                                                                               'calls' => [],
                                                                                               'changed' => 0,
                                                                                               'opcount' => 0,
                                                                                               'prods' => [
                                                                                                            bless( {
                                                                                                                     'number' => '0',
                                                                                                                     'strcount' => 0,
                                                                                                                     'dircount' => 0,
                                                                                                                     'uncommit' => undef,
                                                                                                                     'error' => undef,
                                                                                                                     'patcount' => 1,
                                                                                                                     'actcount' => 0,
                                                                                                                     'items' => [
                                                                                                                                  bless( {
                                                                                                                                           'pattern' => 'NULLS\\s+FIRST',
                                                                                                                                           'hashname' => '__PATTERN1__',
                                                                                                                                           'description' => '/NULLS\\\\s+FIRST/i',
                                                                                                                                           'lookahead' => 0,
                                                                                                                                           'rdelim' => '/',
                                                                                                                                           'line' => 628,
                                                                                                                                           'mod' => 'i',
                                                                                                                                           'ldelim' => '/'
                                                                                                                                         }, 'Parse::RecDescent::Token' )
                                                                                                                                ],
                                                                                                                     'line' => undef
                                                                                                                   }, 'Parse::RecDescent::Production' ),
                                                                                                            bless( {
                                                                                                                     'number' => '1',
                                                                                                                     'strcount' => 0,
                                                                                                                     'dircount' => 0,
                                                                                                                     'uncommit' => undef,
                                                                                                                     'error' => undef,
                                                                                                                     'patcount' => 1,
                                                                                                                     'actcount' => 0,
                                                                                                                     'items' => [
                                                                                                                                  bless( {
                                                                                                                                           'pattern' => 'NULLS\\s+LAST',
                                                                                                                                           'hashname' => '__PATTERN1__',
                                                                                                                                           'description' => '/NULLS\\\\s+LAST/i',
                                                                                                                                           'lookahead' => 0,
                                                                                                                                           'rdelim' => '/',
                                                                                                                                           'line' => 628,
                                                                                                                                           'mod' => 'i',
                                                                                                                                           'ldelim' => '/'
                                                                                                                                         }, 'Parse::RecDescent::Token' )
                                                                                                                                ],
                                                                                                                     'line' => 628
                                                                                                                   }, 'Parse::RecDescent::Production' )
                                                                                                          ],
                                                                                               'name' => '_alternation_1_of_production_1_of_rule_desc_option',
                                                                                               'vars' => '',
                                                                                               'line' => 628
                                                                                             }, 'Parse::RecDescent::Rule' ),
                              'view_name' => bless( {
                                                      'impcount' => 0,
                                                      'calls' => [
                                                                   'SCHEMA',
                                                                   'NAME'
                                                                 ],
                                                      'changed' => 0,
                                                      'opcount' => 0,
                                                      'prods' => [
                                                                   bless( {
                                                                            'number' => '0',
                                                                            'strcount' => 1,
                                                                            'dircount' => 0,
                                                                            'uncommit' => undef,
                                                                            'error' => undef,
                                                                            'patcount' => 0,
                                                                            'actcount' => 1,
                                                                            'items' => [
                                                                                         bless( {
                                                                                                  'subrule' => 'SCHEMA',
                                                                                                  'matchrule' => 0,
                                                                                                  'implicit' => undef,
                                                                                                  'argcode' => undef,
                                                                                                  'lookahead' => 0,
                                                                                                  'line' => 129
                                                                                                }, 'Parse::RecDescent::Subrule' ),
                                                                                         bless( {
                                                                                                  'pattern' => '.',
                                                                                                  'hashname' => '__STRING1__',
                                                                                                  'description' => '\'.\'',
                                                                                                  'lookahead' => 0,
                                                                                                  'line' => 129
                                                                                                }, 'Parse::RecDescent::Literal' ),
                                                                                         bless( {
                                                                                                  'subrule' => 'NAME',
                                                                                                  'matchrule' => 0,
                                                                                                  'implicit' => undef,
                                                                                                  'argcode' => undef,
                                                                                                  'lookahead' => 0,
                                                                                                  'line' => 129
                                                                                                }, 'Parse::RecDescent::Subrule' ),
                                                                                         bless( {
                                                                                                  'hashname' => '__ACTION1__',
                                                                                                  'lookahead' => 0,
                                                                                                  'line' => 130,
                                                                                                  'code' => '{ $return = { schema => $item[1], name => $item[3] } }'
                                                                                                }, 'Parse::RecDescent::Action' )
                                                                                       ],
                                                                            'line' => undef
                                                                          }, 'Parse::RecDescent::Production' ),
                                                                   bless( {
                                                                            'number' => '1',
                                                                            'strcount' => 0,
                                                                            'dircount' => 0,
                                                                            'uncommit' => undef,
                                                                            'error' => undef,
                                                                            'patcount' => 0,
                                                                            'actcount' => 1,
                                                                            'items' => [
                                                                                         bless( {
                                                                                                  'subrule' => 'NAME',
                                                                                                  'matchrule' => 0,
                                                                                                  'implicit' => undef,
                                                                                                  'argcode' => undef,
                                                                                                  'lookahead' => 0,
                                                                                                  'line' => 131
                                                                                                }, 'Parse::RecDescent::Subrule' ),
                                                                                         bless( {
                                                                                                  'hashname' => '__ACTION1__',
                                                                                                  'lookahead' => 0,
                                                                                                  'line' => 132,
                                                                                                  'code' => '{ $return = { name => $item[1] } }'
                                                                                                }, 'Parse::RecDescent::Action' )
                                                                                       ],
                                                                            'line' => 131
                                                                          }, 'Parse::RecDescent::Production' )
                                                                 ],
                                                      'name' => 'view_name',
                                                      'vars' => '',
                                                      'line' => 129
                                                    }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule_cond' => bless( {
                                                                                        'impcount' => 0,
                                                                                        'calls' => [],
                                                                                        'changed' => 0,
                                                                                        'opcount' => 0,
                                                                                        'prods' => [
                                                                                                     bless( {
                                                                                                              'number' => '0',
                                                                                                              'strcount' => 0,
                                                                                                              'dircount' => 0,
                                                                                                              'uncommit' => undef,
                                                                                                              'error' => undef,
                                                                                                              'patcount' => 1,
                                                                                                              'actcount' => 0,
                                                                                                              'items' => [
                                                                                                                           bless( {
                                                                                                                                    'pattern' => 'AND',
                                                                                                                                    'hashname' => '__PATTERN1__',
                                                                                                                                    'description' => '/AND/i',
                                                                                                                                    'lookahead' => 0,
                                                                                                                                    'rdelim' => '/',
                                                                                                                                    'line' => 628,
                                                                                                                                    'mod' => 'i',
                                                                                                                                    'ldelim' => '/'
                                                                                                                                  }, 'Parse::RecDescent::Token' )
                                                                                                                         ],
                                                                                                              'line' => undef
                                                                                                            }, 'Parse::RecDescent::Production' ),
                                                                                                     bless( {
                                                                                                              'number' => '1',
                                                                                                              'strcount' => 0,
                                                                                                              'dircount' => 0,
                                                                                                              'uncommit' => undef,
                                                                                                              'error' => undef,
                                                                                                              'patcount' => 1,
                                                                                                              'actcount' => 0,
                                                                                                              'items' => [
                                                                                                                           bless( {
                                                                                                                                    'pattern' => 'OR',
                                                                                                                                    'hashname' => '__PATTERN1__',
                                                                                                                                    'description' => '/OR/i',
                                                                                                                                    'lookahead' => 0,
                                                                                                                                    'rdelim' => '/',
                                                                                                                                    'line' => 628,
                                                                                                                                    'mod' => 'i',
                                                                                                                                    'ldelim' => '/'
                                                                                                                                  }, 'Parse::RecDescent::Token' )
                                                                                                                         ],
                                                                                                              'line' => 628
                                                                                                            }, 'Parse::RecDescent::Production' )
                                                                                                   ],
                                                                                        'name' => '_alternation_1_of_production_1_of_rule_cond',
                                                                                        'vars' => '',
                                                                                        'line' => 628
                                                                                      }, 'Parse::RecDescent::Rule' ),
                              'numbering_function' => bless( {
                                                               'impcount' => 2,
                                                               'calls' => [
                                                                            'window_partition_clause',
                                                                            '_alternation_1_of_production_1_of_rule_numbering_function',
                                                                            '_alternation_2_of_production_1_of_rule_numbering_function'
                                                                          ],
                                                               'changed' => 0,
                                                               'opcount' => 0,
                                                               'prods' => [
                                                                            bless( {
                                                                                     'number' => '0',
                                                                                     'strcount' => 3,
                                                                                     'dircount' => 0,
                                                                                     'uncommit' => undef,
                                                                                     'error' => undef,
                                                                                     'patcount' => 2,
                                                                                     'actcount' => 0,
                                                                                     'items' => [
                                                                                                  bless( {
                                                                                                           'pattern' => 'ROW_NUMBER|ROWNUMBER',
                                                                                                           'hashname' => '__PATTERN1__',
                                                                                                           'description' => '/ROW_NUMBER|ROWNUMBER/i',
                                                                                                           'lookahead' => 0,
                                                                                                           'rdelim' => '/',
                                                                                                           'line' => 546,
                                                                                                           'mod' => 'i',
                                                                                                           'ldelim' => '/'
                                                                                                         }, 'Parse::RecDescent::Token' ),
                                                                                                  bless( {
                                                                                                           'pattern' => '()',
                                                                                                           'hashname' => '__STRING1__',
                                                                                                           'description' => '\'()\'',
                                                                                                           'lookahead' => 0,
                                                                                                           'line' => 546
                                                                                                         }, 'Parse::RecDescent::Literal' ),
                                                                                                  bless( {
                                                                                                           'pattern' => 'OVER',
                                                                                                           'hashname' => '__PATTERN2__',
                                                                                                           'description' => '/OVER/i',
                                                                                                           'lookahead' => 0,
                                                                                                           'rdelim' => '/',
                                                                                                           'line' => 546,
                                                                                                           'mod' => 'i',
                                                                                                           'ldelim' => '/'
                                                                                                         }, 'Parse::RecDescent::Token' ),
                                                                                                  bless( {
                                                                                                           'pattern' => '(',
                                                                                                           'hashname' => '__STRING2__',
                                                                                                           'description' => '\'(\'',
                                                                                                           'lookahead' => 0,
                                                                                                           'line' => 546
                                                                                                         }, 'Parse::RecDescent::Literal' ),
                                                                                                  bless( {
                                                                                                           'subrule' => 'window_partition_clause',
                                                                                                           'expected' => undef,
                                                                                                           'min' => 0,
                                                                                                           'argcode' => undef,
                                                                                                           'max' => 1,
                                                                                                           'matchrule' => 0,
                                                                                                           'repspec' => '?',
                                                                                                           'lookahead' => 0,
                                                                                                           'line' => 546
                                                                                                         }, 'Parse::RecDescent::Repetition' ),
                                                                                                  bless( {
                                                                                                           'subrule' => '_alternation_1_of_production_1_of_rule_numbering_function',
                                                                                                           'expected' => 'window_order_clause',
                                                                                                           'min' => 0,
                                                                                                           'argcode' => undef,
                                                                                                           'max' => 1,
                                                                                                           'matchrule' => 0,
                                                                                                           'repspec' => '?',
                                                                                                           'lookahead' => 0,
                                                                                                           'line' => 548
                                                                                                         }, 'Parse::RecDescent::Repetition' ),
                                                                                                  bless( {
                                                                                                           'subrule' => '_alternation_2_of_production_1_of_rule_numbering_function',
                                                                                                           'expected' => '/RANGE\\\\s+BETWEEN\\\\s+UNBOUNDED\\\\s+PRECEDING\\\\s+AND\\\\s+UNBBOUNDED\\\\s+FOLLOWING/i, or window_aggregation_group_clause',
                                                                                                           'min' => 0,
                                                                                                           'argcode' => undef,
                                                                                                           'max' => 1,
                                                                                                           'matchrule' => 0,
                                                                                                           'repspec' => '?',
                                                                                                           'lookahead' => 0,
                                                                                                           'line' => 551
                                                                                                         }, 'Parse::RecDescent::Repetition' ),
                                                                                                  bless( {
                                                                                                           'pattern' => ')',
                                                                                                           'hashname' => '__STRING3__',
                                                                                                           'description' => '\')\'',
                                                                                                           'lookahead' => 0,
                                                                                                           'line' => 551
                                                                                                         }, 'Parse::RecDescent::Literal' )
                                                                                                ],
                                                                                     'line' => undef
                                                                                   }, 'Parse::RecDescent::Production' )
                                                                          ],
                                                               'name' => 'numbering_function',
                                                               'vars' => '',
                                                               'line' => 546
                                                             }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule_window_aggregation_group_clause' => bless( {
                                                                                                                   'impcount' => 0,
                                                                                                                   'calls' => [],
                                                                                                                   'changed' => 0,
                                                                                                                   'opcount' => 0,
                                                                                                                   'prods' => [
                                                                                                                                bless( {
                                                                                                                                         'number' => '0',
                                                                                                                                         'strcount' => 0,
                                                                                                                                         'dircount' => 0,
                                                                                                                                         'uncommit' => undef,
                                                                                                                                         'error' => undef,
                                                                                                                                         'patcount' => 1,
                                                                                                                                         'actcount' => 0,
                                                                                                                                         'items' => [
                                                                                                                                                      bless( {
                                                                                                                                                               'pattern' => 'ROWS',
                                                                                                                                                               'hashname' => '__PATTERN1__',
                                                                                                                                                               'description' => '/ROWS/i',
                                                                                                                                                               'lookahead' => 0,
                                                                                                                                                               'rdelim' => '/',
                                                                                                                                                               'line' => 626,
                                                                                                                                                               'mod' => 'i',
                                                                                                                                                               'ldelim' => '/'
                                                                                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                                                                                    ],
                                                                                                                                         'line' => undef
                                                                                                                                       }, 'Parse::RecDescent::Production' ),
                                                                                                                                bless( {
                                                                                                                                         'number' => '1',
                                                                                                                                         'strcount' => 0,
                                                                                                                                         'dircount' => 0,
                                                                                                                                         'uncommit' => undef,
                                                                                                                                         'error' => undef,
                                                                                                                                         'patcount' => 1,
                                                                                                                                         'actcount' => 0,
                                                                                                                                         'items' => [
                                                                                                                                                      bless( {
                                                                                                                                                               'pattern' => 'RANGE',
                                                                                                                                                               'hashname' => '__PATTERN1__',
                                                                                                                                                               'description' => '/RANGE/i',
                                                                                                                                                               'lookahead' => 0,
                                                                                                                                                               'rdelim' => '/',
                                                                                                                                                               'line' => 627,
                                                                                                                                                               'mod' => 'i',
                                                                                                                                                               'ldelim' => '/'
                                                                                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                                                                                    ],
                                                                                                                                         'line' => 627
                                                                                                                                       }, 'Parse::RecDescent::Production' )
                                                                                                                              ],
                                                                                                                   'name' => '_alternation_1_of_production_1_of_rule_window_aggregation_group_clause',
                                                                                                                   'vars' => '',
                                                                                                                   'line' => 626
                                                                                                                 }, 'Parse::RecDescent::Rule' ),
                              'group_bound1' => bless( {
                                                         'impcount' => 0,
                                                         'calls' => [
                                                                      'unsigned_constant'
                                                                    ],
                                                         'changed' => 0,
                                                         'opcount' => 0,
                                                         'prods' => [
                                                                      bless( {
                                                                               'number' => '0',
                                                                               'strcount' => 0,
                                                                               'dircount' => 0,
                                                                               'uncommit' => undef,
                                                                               'error' => undef,
                                                                               'patcount' => 1,
                                                                               'actcount' => 0,
                                                                               'items' => [
                                                                                            bless( {
                                                                                                     'pattern' => 'UNBOUNDED\\s+PRECEDING',
                                                                                                     'hashname' => '__PATTERN1__',
                                                                                                     'description' => '/UNBOUNDED\\\\s+PRECEDING/i',
                                                                                                     'lookahead' => 0,
                                                                                                     'rdelim' => '/',
                                                                                                     'line' => 580,
                                                                                                     'mod' => 'i',
                                                                                                     'ldelim' => '/'
                                                                                                   }, 'Parse::RecDescent::Token' )
                                                                                          ],
                                                                               'line' => undef
                                                                             }, 'Parse::RecDescent::Production' ),
                                                                      bless( {
                                                                               'number' => '1',
                                                                               'strcount' => 0,
                                                                               'dircount' => 0,
                                                                               'uncommit' => undef,
                                                                               'error' => undef,
                                                                               'patcount' => 1,
                                                                               'actcount' => 0,
                                                                               'items' => [
                                                                                            bless( {
                                                                                                     'subrule' => 'unsigned_constant',
                                                                                                     'matchrule' => 0,
                                                                                                     'implicit' => undef,
                                                                                                     'argcode' => undef,
                                                                                                     'lookahead' => 0,
                                                                                                     'line' => 581
                                                                                                   }, 'Parse::RecDescent::Subrule' ),
                                                                                            bless( {
                                                                                                     'pattern' => 'PRECEDING',
                                                                                                     'hashname' => '__PATTERN1__',
                                                                                                     'description' => '/PRECEDING/i',
                                                                                                     'lookahead' => 0,
                                                                                                     'rdelim' => '/',
                                                                                                     'line' => 581,
                                                                                                     'mod' => 'i',
                                                                                                     'ldelim' => '/'
                                                                                                   }, 'Parse::RecDescent::Token' )
                                                                                          ],
                                                                               'line' => 581
                                                                             }, 'Parse::RecDescent::Production' ),
                                                                      bless( {
                                                                               'number' => '2',
                                                                               'strcount' => 0,
                                                                               'dircount' => 0,
                                                                               'uncommit' => undef,
                                                                               'error' => undef,
                                                                               'patcount' => 1,
                                                                               'actcount' => 0,
                                                                               'items' => [
                                                                                            bless( {
                                                                                                     'subrule' => 'unsigned_constant',
                                                                                                     'matchrule' => 0,
                                                                                                     'implicit' => undef,
                                                                                                     'argcode' => undef,
                                                                                                     'lookahead' => 0,
                                                                                                     'line' => 582
                                                                                                   }, 'Parse::RecDescent::Subrule' ),
                                                                                            bless( {
                                                                                                     'pattern' => 'FOLLOWING',
                                                                                                     'hashname' => '__PATTERN1__',
                                                                                                     'description' => '/FOLLOWING/i',
                                                                                                     'lookahead' => 0,
                                                                                                     'rdelim' => '/',
                                                                                                     'line' => 582,
                                                                                                     'mod' => 'i',
                                                                                                     'ldelim' => '/'
                                                                                                   }, 'Parse::RecDescent::Token' )
                                                                                          ],
                                                                               'line' => 582
                                                                             }, 'Parse::RecDescent::Production' ),
                                                                      bless( {
                                                                               'number' => '3',
                                                                               'strcount' => 0,
                                                                               'dircount' => 0,
                                                                               'uncommit' => undef,
                                                                               'error' => undef,
                                                                               'patcount' => 1,
                                                                               'actcount' => 0,
                                                                               'items' => [
                                                                                            bless( {
                                                                                                     'pattern' => 'CURRENT\\s+ROW',
                                                                                                     'hashname' => '__PATTERN1__',
                                                                                                     'description' => '/CURRENT\\\\s+ROW/i',
                                                                                                     'lookahead' => 0,
                                                                                                     'rdelim' => '/',
                                                                                                     'line' => 583,
                                                                                                     'mod' => 'i',
                                                                                                     'ldelim' => '/'
                                                                                                   }, 'Parse::RecDescent::Token' )
                                                                                          ],
                                                                               'line' => 583
                                                                             }, 'Parse::RecDescent::Production' )
                                                                    ],
                                                         'name' => 'group_bound1',
                                                         'vars' => '',
                                                         'line' => 580
                                                       }, 'Parse::RecDescent::Rule' ),
                              'OLAP_function' => bless( {
                                                          'impcount' => 0,
                                                          'calls' => [
                                                                       'ranking_function',
                                                                       'numbering_function',
                                                                       'aggregation_function'
                                                                     ],
                                                          'changed' => 0,
                                                          'opcount' => 0,
                                                          'prods' => [
                                                                       bless( {
                                                                                'number' => '0',
                                                                                'strcount' => 0,
                                                                                'dircount' => 0,
                                                                                'uncommit' => undef,
                                                                                'error' => undef,
                                                                                'patcount' => 0,
                                                                                'actcount' => 0,
                                                                                'items' => [
                                                                                             bless( {
                                                                                                      'subrule' => 'ranking_function',
                                                                                                      'matchrule' => 0,
                                                                                                      'implicit' => undef,
                                                                                                      'argcode' => undef,
                                                                                                      'lookahead' => 0,
                                                                                                      'line' => 538
                                                                                                    }, 'Parse::RecDescent::Subrule' )
                                                                                           ],
                                                                                'line' => undef
                                                                              }, 'Parse::RecDescent::Production' ),
                                                                       bless( {
                                                                                'number' => '1',
                                                                                'strcount' => 0,
                                                                                'dircount' => 0,
                                                                                'uncommit' => undef,
                                                                                'error' => undef,
                                                                                'patcount' => 0,
                                                                                'actcount' => 0,
                                                                                'items' => [
                                                                                             bless( {
                                                                                                      'subrule' => 'numbering_function',
                                                                                                      'matchrule' => 0,
                                                                                                      'implicit' => undef,
                                                                                                      'argcode' => undef,
                                                                                                      'lookahead' => 0,
                                                                                                      'line' => 539
                                                                                                    }, 'Parse::RecDescent::Subrule' )
                                                                                           ],
                                                                                'line' => 539
                                                                              }, 'Parse::RecDescent::Production' ),
                                                                       bless( {
                                                                                'number' => '2',
                                                                                'strcount' => 0,
                                                                                'dircount' => 0,
                                                                                'uncommit' => undef,
                                                                                'error' => undef,
                                                                                'patcount' => 0,
                                                                                'actcount' => 0,
                                                                                'items' => [
                                                                                             bless( {
                                                                                                      'subrule' => 'aggregation_function',
                                                                                                      'matchrule' => 0,
                                                                                                      'implicit' => undef,
                                                                                                      'argcode' => undef,
                                                                                                      'lookahead' => 0,
                                                                                                      'line' => 540
                                                                                                    }, 'Parse::RecDescent::Subrule' )
                                                                                           ],
                                                                                'line' => 540
                                                                              }, 'Parse::RecDescent::Production' )
                                                                     ],
                                                          'name' => 'OLAP_function',
                                                          'vars' => '',
                                                          'line' => 538
                                                        }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_30_of_rule_sysibm_function' => bless( {
                                                                                                    'impcount' => 0,
                                                                                                    'calls' => [],
                                                                                                    'changed' => 0,
                                                                                                    'opcount' => 0,
                                                                                                    'prods' => [
                                                                                                                 bless( {
                                                                                                                          'number' => '0',
                                                                                                                          'strcount' => 0,
                                                                                                                          'dircount' => 0,
                                                                                                                          'uncommit' => undef,
                                                                                                                          'error' => undef,
                                                                                                                          'patcount' => 1,
                                                                                                                          'actcount' => 0,
                                                                                                                          'items' => [
                                                                                                                                       bless( {
                                                                                                                                                'pattern' => 'DOUBLE',
                                                                                                                                                'hashname' => '__PATTERN1__',
                                                                                                                                                'description' => '/DOUBLE/i',
                                                                                                                                                'lookahead' => 0,
                                                                                                                                                'rdelim' => '/',
                                                                                                                                                'line' => 628,
                                                                                                                                                'mod' => 'i',
                                                                                                                                                'ldelim' => '/'
                                                                                                                                              }, 'Parse::RecDescent::Token' )
                                                                                                                                     ],
                                                                                                                          'line' => undef
                                                                                                                        }, 'Parse::RecDescent::Production' ),
                                                                                                                 bless( {
                                                                                                                          'number' => '1',
                                                                                                                          'strcount' => 0,
                                                                                                                          'dircount' => 0,
                                                                                                                          'uncommit' => undef,
                                                                                                                          'error' => undef,
                                                                                                                          'patcount' => 1,
                                                                                                                          'actcount' => 0,
                                                                                                                          'items' => [
                                                                                                                                       bless( {
                                                                                                                                                'pattern' => 'DOUBLE_PRECISION',
                                                                                                                                                'hashname' => '__PATTERN1__',
                                                                                                                                                'description' => '/DOUBLE_PRECISION/i',
                                                                                                                                                'lookahead' => 0,
                                                                                                                                                'rdelim' => '/',
                                                                                                                                                'line' => 628,
                                                                                                                                                'mod' => 'i',
                                                                                                                                                'ldelim' => '/'
                                                                                                                                              }, 'Parse::RecDescent::Token' )
                                                                                                                                     ],
                                                                                                                          'line' => 628
                                                                                                                        }, 'Parse::RecDescent::Production' )
                                                                                                               ],
                                                                                                    'name' => '_alternation_1_of_production_30_of_rule_sysibm_function',
                                                                                                    'vars' => '',
                                                                                                    'line' => 628
                                                                                                  }, 'Parse::RecDescent::Rule' ),
                              'FULL' => bless( {
                                                 'impcount' => 0,
                                                 'calls' => [],
                                                 'changed' => 0,
                                                 'opcount' => 0,
                                                 'prods' => [
                                                              bless( {
                                                                       'number' => '0',
                                                                       'strcount' => 0,
                                                                       'dircount' => 0,
                                                                       'uncommit' => undef,
                                                                       'error' => undef,
                                                                       'patcount' => 1,
                                                                       'actcount' => 0,
                                                                       'items' => [
                                                                                    bless( {
                                                                                             'pattern' => 'full',
                                                                                             'hashname' => '__PATTERN1__',
                                                                                             'description' => '/full/i',
                                                                                             'lookahead' => 0,
                                                                                             'rdelim' => '/',
                                                                                             'line' => 113,
                                                                                             'mod' => 'i',
                                                                                             'ldelim' => '/'
                                                                                           }, 'Parse::RecDescent::Token' )
                                                                                  ],
                                                                       'line' => undef
                                                                     }, 'Parse::RecDescent::Production' )
                                                            ],
                                                 'name' => 'FULL',
                                                 'vars' => '',
                                                 'line' => 113
                                               }, 'Parse::RecDescent::Rule' ),
                              '_alternation_2_of_production_1_of_rule_cast_specification' => bless( {
                                                                                                      'impcount' => 1,
                                                                                                      'calls' => [
                                                                                                                   '_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cast_specification'
                                                                                                                 ],
                                                                                                      'changed' => 0,
                                                                                                      'opcount' => 0,
                                                                                                      'prods' => [
                                                                                                                   bless( {
                                                                                                                            'number' => '0',
                                                                                                                            'strcount' => 0,
                                                                                                                            'dircount' => 0,
                                                                                                                            'uncommit' => undef,
                                                                                                                            'error' => undef,
                                                                                                                            'patcount' => 1,
                                                                                                                            'actcount' => 0,
                                                                                                                            'items' => [
                                                                                                                                         bless( {
                                                                                                                                                  'pattern' => 'SCOPE',
                                                                                                                                                  'hashname' => '__PATTERN1__',
                                                                                                                                                  'description' => '/SCOPE/',
                                                                                                                                                  'lookahead' => 0,
                                                                                                                                                  'rdelim' => '/',
                                                                                                                                                  'line' => 625,
                                                                                                                                                  'mod' => '',
                                                                                                                                                  'ldelim' => '/'
                                                                                                                                                }, 'Parse::RecDescent::Token' ),
                                                                                                                                         bless( {
                                                                                                                                                  'subrule' => '_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cast_specification',
                                                                                                                                                  'matchrule' => 0,
                                                                                                                                                  'implicit' => 'typed_table_name, or typed_view_name',
                                                                                                                                                  'argcode' => undef,
                                                                                                                                                  'lookahead' => 0,
                                                                                                                                                  'line' => 627
                                                                                                                                                }, 'Parse::RecDescent::Subrule' )
                                                                                                                                       ],
                                                                                                                            'line' => undef
                                                                                                                          }, 'Parse::RecDescent::Production' )
                                                                                                                 ],
                                                                                                      'name' => '_alternation_2_of_production_1_of_rule_cast_specification',
                                                                                                      'vars' => '',
                                                                                                      'line' => 625
                                                                                                    }, 'Parse::RecDescent::Rule' ),
                              'case_expression' => bless( {
                                                            'impcount' => 2,
                                                            'calls' => [
                                                                         '_alternation_1_of_production_1_of_rule_case_expression',
                                                                         '_alternation_2_of_production_1_of_rule_case_expression'
                                                                       ],
                                                            'changed' => 0,
                                                            'opcount' => 0,
                                                            'prods' => [
                                                                         bless( {
                                                                                  'number' => '0',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 2,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'CASE',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/CASE/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 496,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' ),
                                                                                               bless( {
                                                                                                        'subrule' => '_alternation_1_of_production_1_of_rule_case_expression',
                                                                                                        'matchrule' => 0,
                                                                                                        'implicit' => 'searched_when_clause, or simple_when_clause',
                                                                                                        'argcode' => undef,
                                                                                                        'lookahead' => 0,
                                                                                                        'line' => 498
                                                                                                      }, 'Parse::RecDescent::Subrule' ),
                                                                                               bless( {
                                                                                                        'subrule' => '_alternation_2_of_production_1_of_rule_case_expression',
                                                                                                        'expected' => '/ELSE\\\\s+NULL/i, or /ELSE/i',
                                                                                                        'min' => 0,
                                                                                                        'argcode' => undef,
                                                                                                        'max' => 1,
                                                                                                        'matchrule' => 0,
                                                                                                        'repspec' => '?',
                                                                                                        'lookahead' => 0,
                                                                                                        'line' => 501
                                                                                                      }, 'Parse::RecDescent::Repetition' ),
                                                                                               bless( {
                                                                                                        'pattern' => 'END',
                                                                                                        'hashname' => '__PATTERN2__',
                                                                                                        'description' => '/END/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 501,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => undef
                                                                                }, 'Parse::RecDescent::Production' )
                                                                       ],
                                                            'name' => 'case_expression',
                                                            'vars' => '',
                                                            'line' => 496
                                                          }, 'Parse::RecDescent::Rule' ),
                              'operator' => bless( {
                                                     'impcount' => 0,
                                                     'calls' => [
                                                                  '_alternation_1_of_production_1_of_rule_operator'
                                                                ],
                                                     'changed' => 0,
                                                     'opcount' => 0,
                                                     'prods' => [
                                                                  bless( {
                                                                           'number' => '0',
                                                                           'strcount' => 0,
                                                                           'dircount' => 0,
                                                                           'uncommit' => undef,
                                                                           'error' => undef,
                                                                           'patcount' => 0,
                                                                           'actcount' => 0,
                                                                           'items' => [
                                                                                        bless( {
                                                                                                 'subrule' => '_alternation_1_of_production_1_of_rule_operator',
                                                                                                 'matchrule' => 0,
                                                                                                 'implicit' => '/CONCAT/i, or \'||\'',
                                                                                                 'argcode' => undef,
                                                                                                 'lookahead' => 0,
                                                                                                 'line' => 321
                                                                                               }, 'Parse::RecDescent::Subrule' )
                                                                                      ],
                                                                           'line' => undef
                                                                         }, 'Parse::RecDescent::Production' ),
                                                                  bless( {
                                                                           'number' => '1',
                                                                           'strcount' => 1,
                                                                           'dircount' => 0,
                                                                           'uncommit' => undef,
                                                                           'error' => undef,
                                                                           'patcount' => 0,
                                                                           'actcount' => 0,
                                                                           'items' => [
                                                                                        bless( {
                                                                                                 'pattern' => '/',
                                                                                                 'hashname' => '__STRING1__',
                                                                                                 'description' => '\'/\'',
                                                                                                 'lookahead' => 0,
                                                                                                 'line' => 321
                                                                                               }, 'Parse::RecDescent::Literal' )
                                                                                      ],
                                                                           'line' => 321
                                                                         }, 'Parse::RecDescent::Production' ),
                                                                  bless( {
                                                                           'number' => '2',
                                                                           'strcount' => 1,
                                                                           'dircount' => 0,
                                                                           'uncommit' => undef,
                                                                           'error' => undef,
                                                                           'patcount' => 0,
                                                                           'actcount' => 0,
                                                                           'items' => [
                                                                                        bless( {
                                                                                                 'pattern' => '*',
                                                                                                 'hashname' => '__STRING1__',
                                                                                                 'description' => '\'*\'',
                                                                                                 'lookahead' => 0,
                                                                                                 'line' => 321
                                                                                               }, 'Parse::RecDescent::Literal' )
                                                                                      ],
                                                                           'line' => 321
                                                                         }, 'Parse::RecDescent::Production' ),
                                                                  bless( {
                                                                           'number' => '3',
                                                                           'strcount' => 1,
                                                                           'dircount' => 0,
                                                                           'uncommit' => undef,
                                                                           'error' => undef,
                                                                           'patcount' => 0,
                                                                           'actcount' => 0,
                                                                           'items' => [
                                                                                        bless( {
                                                                                                 'pattern' => '+',
                                                                                                 'hashname' => '__STRING1__',
                                                                                                 'description' => '\'+\'',
                                                                                                 'lookahead' => 0,
                                                                                                 'line' => 321
                                                                                               }, 'Parse::RecDescent::Literal' )
                                                                                      ],
                                                                           'line' => 321
                                                                         }, 'Parse::RecDescent::Production' ),
                                                                  bless( {
                                                                           'number' => '4',
                                                                           'strcount' => 1,
                                                                           'dircount' => 0,
                                                                           'uncommit' => undef,
                                                                           'error' => undef,
                                                                           'patcount' => 0,
                                                                           'actcount' => 0,
                                                                           'items' => [
                                                                                        bless( {
                                                                                                 'pattern' => '-',
                                                                                                 'hashname' => '__STRING1__',
                                                                                                 'description' => '\'-\'',
                                                                                                 'lookahead' => 0,
                                                                                                 'line' => 321
                                                                                               }, 'Parse::RecDescent::Literal' )
                                                                                      ],
                                                                           'line' => 321
                                                                         }, 'Parse::RecDescent::Production' )
                                                                ],
                                                     'name' => 'operator',
                                                     'vars' => '',
                                                     'line' => 321
                                                   }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_2_of_rule_type' => bless( {
                                                                                        'impcount' => 0,
                                                                                        'calls' => [],
                                                                                        'changed' => 0,
                                                                                        'opcount' => 0,
                                                                                        'prods' => [
                                                                                                     bless( {
                                                                                                              'number' => '0',
                                                                                                              'strcount' => 0,
                                                                                                              'dircount' => 0,
                                                                                                              'uncommit' => undef,
                                                                                                              'error' => undef,
                                                                                                              'patcount' => 1,
                                                                                                              'actcount' => 0,
                                                                                                              'items' => [
                                                                                                                           bless( {
                                                                                                                                    'pattern' => 'INSERT',
                                                                                                                                    'hashname' => '__PATTERN1__',
                                                                                                                                    'description' => '/INSERT/i',
                                                                                                                                    'lookahead' => 0,
                                                                                                                                    'rdelim' => '/',
                                                                                                                                    'line' => 628,
                                                                                                                                    'mod' => 'i',
                                                                                                                                    'ldelim' => '/'
                                                                                                                                  }, 'Parse::RecDescent::Token' )
                                                                                                                         ],
                                                                                                              'line' => undef
                                                                                                            }, 'Parse::RecDescent::Production' ),
                                                                                                     bless( {
                                                                                                              'number' => '1',
                                                                                                              'strcount' => 0,
                                                                                                              'dircount' => 0,
                                                                                                              'uncommit' => undef,
                                                                                                              'error' => undef,
                                                                                                              'patcount' => 1,
                                                                                                              'actcount' => 0,
                                                                                                              'items' => [
                                                                                                                           bless( {
                                                                                                                                    'pattern' => 'DELETE',
                                                                                                                                    'hashname' => '__PATTERN1__',
                                                                                                                                    'description' => '/DELETE/i',
                                                                                                                                    'lookahead' => 0,
                                                                                                                                    'rdelim' => '/',
                                                                                                                                    'line' => 628,
                                                                                                                                    'mod' => 'i',
                                                                                                                                    'ldelim' => '/'
                                                                                                                                  }, 'Parse::RecDescent::Token' )
                                                                                                                         ],
                                                                                                              'line' => 628
                                                                                                            }, 'Parse::RecDescent::Production' ),
                                                                                                     bless( {
                                                                                                              'number' => '2',
                                                                                                              'strcount' => 0,
                                                                                                              'dircount' => 0,
                                                                                                              'uncommit' => undef,
                                                                                                              'error' => undef,
                                                                                                              'patcount' => 1,
                                                                                                              'actcount' => 0,
                                                                                                              'items' => [
                                                                                                                           bless( {
                                                                                                                                    'pattern' => 'UPDATE',
                                                                                                                                    'hashname' => '__PATTERN1__',
                                                                                                                                    'description' => '/UPDATE/i',
                                                                                                                                    'lookahead' => 0,
                                                                                                                                    'rdelim' => '/',
                                                                                                                                    'line' => 628,
                                                                                                                                    'mod' => 'i',
                                                                                                                                    'ldelim' => '/'
                                                                                                                                  }, 'Parse::RecDescent::Token' )
                                                                                                                         ],
                                                                                                              'line' => 628
                                                                                                            }, 'Parse::RecDescent::Production' )
                                                                                                   ],
                                                                                        'name' => '_alternation_1_of_production_2_of_rule_type',
                                                                                        'vars' => '',
                                                                                        'line' => 628
                                                                                      }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_8_of_rule_sysibm_function' => bless( {
                                                                                                   'impcount' => 0,
                                                                                                   'calls' => [],
                                                                                                   'changed' => 0,
                                                                                                   'opcount' => 0,
                                                                                                   'prods' => [
                                                                                                                bless( {
                                                                                                                         'number' => '0',
                                                                                                                         'strcount' => 0,
                                                                                                                         'dircount' => 0,
                                                                                                                         'uncommit' => undef,
                                                                                                                         'error' => undef,
                                                                                                                         'patcount' => 1,
                                                                                                                         'actcount' => 0,
                                                                                                                         'items' => [
                                                                                                                                      bless( {
                                                                                                                                               'pattern' => 'CONCAT',
                                                                                                                                               'hashname' => '__PATTERN1__',
                                                                                                                                               'description' => '/CONCAT/',
                                                                                                                                               'lookahead' => 0,
                                                                                                                                               'rdelim' => '/',
                                                                                                                                               'line' => 628,
                                                                                                                                               'mod' => '',
                                                                                                                                               'ldelim' => '/'
                                                                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                                                                    ],
                                                                                                                         'line' => undef
                                                                                                                       }, 'Parse::RecDescent::Production' ),
                                                                                                                bless( {
                                                                                                                         'number' => '1',
                                                                                                                         'strcount' => 1,
                                                                                                                         'dircount' => 0,
                                                                                                                         'uncommit' => undef,
                                                                                                                         'error' => undef,
                                                                                                                         'patcount' => 0,
                                                                                                                         'actcount' => 0,
                                                                                                                         'items' => [
                                                                                                                                      bless( {
                                                                                                                                               'pattern' => '||',
                                                                                                                                               'hashname' => '__STRING1__',
                                                                                                                                               'description' => '\'||\'',
                                                                                                                                               'lookahead' => 0,
                                                                                                                                               'line' => 628
                                                                                                                                             }, 'Parse::RecDescent::Literal' )
                                                                                                                                    ],
                                                                                                                         'line' => 628
                                                                                                                       }, 'Parse::RecDescent::Production' )
                                                                                                              ],
                                                                                                   'name' => '_alternation_1_of_production_8_of_rule_sysibm_function',
                                                                                                   'vars' => '',
                                                                                                   'line' => 628
                                                                                                 }, 'Parse::RecDescent::Rule' ),
                              'sequence_reference' => bless( {
                                                               'impcount' => 0,
                                                               'calls' => [
                                                                            'nextval_expression',
                                                                            'prevval_expression'
                                                                          ],
                                                               'changed' => 0,
                                                               'opcount' => 0,
                                                               'prods' => [
                                                                            bless( {
                                                                                     'number' => '0',
                                                                                     'strcount' => 0,
                                                                                     'dircount' => 0,
                                                                                     'uncommit' => undef,
                                                                                     'error' => undef,
                                                                                     'patcount' => 0,
                                                                                     'actcount' => 0,
                                                                                     'items' => [
                                                                                                  bless( {
                                                                                                           'subrule' => 'nextval_expression',
                                                                                                           'matchrule' => 0,
                                                                                                           'implicit' => undef,
                                                                                                           'argcode' => undef,
                                                                                                           'lookahead' => 0,
                                                                                                           'line' => 608
                                                                                                         }, 'Parse::RecDescent::Subrule' )
                                                                                                ],
                                                                                     'line' => undef
                                                                                   }, 'Parse::RecDescent::Production' ),
                                                                            bless( {
                                                                                     'number' => '1',
                                                                                     'strcount' => 0,
                                                                                     'dircount' => 0,
                                                                                     'uncommit' => undef,
                                                                                     'error' => undef,
                                                                                     'patcount' => 0,
                                                                                     'actcount' => 0,
                                                                                     'items' => [
                                                                                                  bless( {
                                                                                                           'subrule' => 'prevval_expression',
                                                                                                           'matchrule' => 0,
                                                                                                           'implicit' => undef,
                                                                                                           'argcode' => undef,
                                                                                                           'lookahead' => 0,
                                                                                                           'line' => 609
                                                                                                         }, 'Parse::RecDescent::Subrule' )
                                                                                                ],
                                                                                     'line' => 609
                                                                                   }, 'Parse::RecDescent::Production' )
                                                                          ],
                                                               'name' => 'sequence_reference',
                                                               'vars' => '',
                                                               'line' => 608
                                                             }, 'Parse::RecDescent::Rule' ),
                              'sysibm_function' => bless( {
                                                            'impcount' => 0,
                                                            'calls' => [
                                                                         '_alternation_1_of_production_1_of_rule_sysibm_function',
                                                                         '_alternation_1_of_production_8_of_rule_sysibm_function',
                                                                         '_alternation_1_of_production_9_of_rule_sysibm_function',
                                                                         '_alternation_1_of_production_12_of_rule_sysibm_function',
                                                                         '_alternation_1_of_production_17_of_rule_sysibm_function',
                                                                         '_alternation_1_of_production_30_of_rule_sysibm_function',
                                                                         '_alternation_1_of_production_41_of_rule_sysibm_function',
                                                                         '_alternation_1_of_production_42_of_rule_sysibm_function',
                                                                         '_alternation_1_of_production_63_of_rule_sysibm_function',
                                                                         '_alternation_1_of_production_83_of_rule_sysibm_function',
                                                                         '_alternation_1_of_production_87_of_rule_sysibm_function'
                                                                       ],
                                                            'changed' => 0,
                                                            'opcount' => 0,
                                                            'prods' => [
                                                                         bless( {
                                                                                  'number' => '0',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 0,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'subrule' => '_alternation_1_of_production_1_of_rule_sysibm_function',
                                                                                                        'matchrule' => 0,
                                                                                                        'implicit' => '/ABS/i, or /ABSVAL/i',
                                                                                                        'argcode' => undef,
                                                                                                        'lookahead' => 0,
                                                                                                        'line' => 332
                                                                                                      }, 'Parse::RecDescent::Subrule' )
                                                                                             ],
                                                                                  'line' => undef
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '1',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'AVG',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/AVG/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 333,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 333
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '2',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'BIGINT',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/BIGINT/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 334,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 334
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '3',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'BLOB',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/BLOB/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 335,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 335
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '4',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'CHAR',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/CHAR/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 336,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 336
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '5',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'CLOB',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/CLOB/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 337,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 337
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '6',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'COALESCE',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/COALESCE/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 338,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 338
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '7',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 0,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'subrule' => '_alternation_1_of_production_8_of_rule_sysibm_function',
                                                                                                        'matchrule' => 0,
                                                                                                        'implicit' => '/CONCAT/, or \'||\'',
                                                                                                        'argcode' => undef,
                                                                                                        'lookahead' => 0,
                                                                                                        'line' => 339
                                                                                                      }, 'Parse::RecDescent::Subrule' )
                                                                                             ],
                                                                                  'line' => 339
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '8',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 0,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'subrule' => '_alternation_1_of_production_9_of_rule_sysibm_function',
                                                                                                        'matchrule' => 0,
                                                                                                        'implicit' => '/CORRELATION/i, or /CORR/',
                                                                                                        'argcode' => undef,
                                                                                                        'lookahead' => 0,
                                                                                                        'line' => 340
                                                                                                      }, 'Parse::RecDescent::Subrule' )
                                                                                             ],
                                                                                  'line' => 340
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '9',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'COUNT',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/COUNT/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 341,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 341
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '10',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'COUNT_BIG',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/COUNT_BIG/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 342,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 342
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '11',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 0,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'subrule' => '_alternation_1_of_production_12_of_rule_sysibm_function',
                                                                                                        'matchrule' => 0,
                                                                                                        'implicit' => '/COVARIANCE/i, or /COVAR/i',
                                                                                                        'argcode' => undef,
                                                                                                        'lookahead' => 0,
                                                                                                        'line' => 343
                                                                                                      }, 'Parse::RecDescent::Subrule' )
                                                                                             ],
                                                                                  'line' => 343
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '12',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'DATE',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/DATE/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 344,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 344
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '13',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'DAY',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/DAY/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 345,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 345
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '14',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'DAYS',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/DAYS/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 346,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 346
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '15',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'DBCLOB',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/DBCLOB/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 347,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 347
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '16',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 0,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'subrule' => '_alternation_1_of_production_17_of_rule_sysibm_function',
                                                                                                        'matchrule' => 0,
                                                                                                        'implicit' => '/DECIMAL/i, or /DEC/i',
                                                                                                        'argcode' => undef,
                                                                                                        'lookahead' => 0,
                                                                                                        'line' => 348
                                                                                                      }, 'Parse::RecDescent::Subrule' )
                                                                                             ],
                                                                                  'line' => 348
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '17',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'DECRYPT_BIN',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/DECRYPT_BIN/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 349,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 349
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '18',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'DECRYPT_CHAR',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/DECRYPT_CHAR/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 350,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 350
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '19',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'DEREF',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/DEREF/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 351,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 351
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '20',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'DIGITS',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/DIGITS/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 352,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 352
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '21',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'DLCOMMENT',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/DLCOMMENT/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 353,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 353
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '22',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'DLLINKTYPE',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/DLLINKTYPE/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 354,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 354
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '23',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'DLURLCOMPLETE',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/DLURLCOMPLETE/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 355,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 355
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '24',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'DLURLPATH',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/DLURLPATH/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 356,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 356
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '25',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'DLURLPATHONLY',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/DLURLPATHONLY/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 357,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 357
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '26',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'DLURLSCHEME',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/DLURLSCHEME/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 358,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 358
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '27',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'DLURLSERVER',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/DLURLSERVER/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 359,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 359
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '28',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'DLVALUE',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/DLVALUE/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 360,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 360
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '29',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 0,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'subrule' => '_alternation_1_of_production_30_of_rule_sysibm_function',
                                                                                                        'matchrule' => 0,
                                                                                                        'implicit' => '/DOUBLE/i, or /DOUBLE_PRECISION/i',
                                                                                                        'argcode' => undef,
                                                                                                        'lookahead' => 0,
                                                                                                        'line' => 361
                                                                                                      }, 'Parse::RecDescent::Subrule' )
                                                                                             ],
                                                                                  'line' => 361
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '30',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'ENCRYPT',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/ENCRYPT/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 362,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 362
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '31',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'EVENT_MON_STATE',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/EVENT_MON_STATE/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 363,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 363
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '32',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'FLOAT',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/FLOAT/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 364,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 364
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '33',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'GETHINT',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/GETHINT/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 365,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 365
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '34',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'GENERATE_UNIQUE',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/GENERATE_UNIQUE/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 366,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 366
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '35',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'GRAPHIC',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/GRAPHIC/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 367,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 367
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '36',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'GROUPING',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/GROUPING/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 368,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 368
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '37',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'HEX',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/HEX/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 369,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 369
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '38',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'HOUR',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/HOUR/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 370,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 370
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '39',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'IDENTITY_VAL_LOCAL',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/IDENTITY_VAL_LOCAL/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 371,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 371
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '40',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 0,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'subrule' => '_alternation_1_of_production_41_of_rule_sysibm_function',
                                                                                                        'matchrule' => 0,
                                                                                                        'implicit' => '/INTEGER/i, or /INT/',
                                                                                                        'argcode' => undef,
                                                                                                        'lookahead' => 0,
                                                                                                        'line' => 372
                                                                                                      }, 'Parse::RecDescent::Subrule' )
                                                                                             ],
                                                                                  'line' => 372
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '41',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 0,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'subrule' => '_alternation_1_of_production_42_of_rule_sysibm_function',
                                                                                                        'matchrule' => 0,
                                                                                                        'implicit' => '/LCASE/i, or /LOWER/',
                                                                                                        'argcode' => undef,
                                                                                                        'lookahead' => 0,
                                                                                                        'line' => 373
                                                                                                      }, 'Parse::RecDescent::Subrule' )
                                                                                             ],
                                                                                  'line' => 373
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '42',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'LENGTH',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/LENGTH/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 374,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 374
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '43',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'LONG_VARCHAR',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/LONG_VARCHAR/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 375,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 375
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '44',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'LONG_VARGRAPHIC',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/LONG_VARGRAPHIC/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 376,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 376
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '45',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'LTRIM',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/LTRIM/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 377,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 377
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '46',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'MAX',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/MAX/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 378,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 378
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '47',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'MICROSECOND',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/MICROSECOND/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 379,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 379
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '48',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'MIN',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/MIN/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 380,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 380
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '49',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'MINUTE',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/MINUTE/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 381,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 381
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '50',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'MONTH',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/MONTH/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 382,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 382
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '51',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'MULTIPLY_ACT',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/MULTIPLY_ACT/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 383,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 383
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '52',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'NODENUMBER',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/NODENUMBER/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 384,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 384
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '53',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'NULLIF',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/NULLIF/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 385,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 385
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '54',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'PARTITON',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/PARTITON/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 386,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 386
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '55',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'POSSTR',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/POSSTR/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 387,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 387
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '56',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'RAISE_ERROR',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/RAISE_ERROR/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 388,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 388
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '57',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'REAL',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/REAL/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 389,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 389
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '58',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'REC2XML',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/REC2XML/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 390,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 390
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '59',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'REGR_AVGX',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/REGR_AVGX/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 391,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 391
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '60',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'REGR_AVGY',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/REGR_AVGY/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 392,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 392
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '61',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'REGR_COUNT',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/REGR_COUNT/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 393,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 393
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '62',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 0,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'subrule' => '_alternation_1_of_production_63_of_rule_sysibm_function',
                                                                                                        'matchrule' => 0,
                                                                                                        'implicit' => '/REGR_INTERCEPT/i, or /REGR_ICPT/i',
                                                                                                        'argcode' => undef,
                                                                                                        'lookahead' => 0,
                                                                                                        'line' => 394
                                                                                                      }, 'Parse::RecDescent::Subrule' )
                                                                                             ],
                                                                                  'line' => 394
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '63',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'REGR_R2',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/REGR_R2/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 395,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 395
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '64',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'REGR_SLOPE',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/REGR_SLOPE/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 396,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 396
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '65',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'REGR_SXX',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/REGR_SXX/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 397,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 397
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '66',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'REGR_SXY',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/REGR_SXY/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 398,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 398
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '67',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'REGR_SYY',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/REGR_SYY/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 399,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 399
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '68',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'RTRIM',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/RTRIM/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 400,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 400
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '69',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'SECOND',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/SECOND/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 401,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 401
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '70',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'SMALLINT',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/SMALLINT/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 402,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 402
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '71',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'STDDEV',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/STDDEV/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 403,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 403
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '72',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'SUBSTR',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/SUBSTR/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 404,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 404
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '73',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'SUM',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/SUM/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 405,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 405
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '74',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'TABLE_NAME',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/TABLE_NAME/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 406,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 406
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '75',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'TABLE_SCHEMA',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/TABLE_SCHEMA/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 407,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 407
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '76',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'TIME',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/TIME/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 408,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 408
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '77',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'TIMESTAMP',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/TIMESTAMP/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 409,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 409
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '78',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'TRANSLATE',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/TRANSLATE/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 410,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 410
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '79',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'TYPE_ID',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/TYPE_ID/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 411,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 411
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '80',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'TYPE_NAME',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/TYPE_NAME/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 412,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 412
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '81',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'TYPE_SCHEMA',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/TYPE_SCHEMA/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 413,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 413
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '82',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 0,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'subrule' => '_alternation_1_of_production_83_of_rule_sysibm_function',
                                                                                                        'matchrule' => 0,
                                                                                                        'implicit' => '/UCASE/i, or /UPPER/i',
                                                                                                        'argcode' => undef,
                                                                                                        'lookahead' => 0,
                                                                                                        'line' => 414
                                                                                                      }, 'Parse::RecDescent::Subrule' )
                                                                                             ],
                                                                                  'line' => 414
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '83',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'VALUE',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/VALUE/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 415,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 415
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '84',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'VARCHAR',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/VARCHAR/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 416,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 416
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '85',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'VARGRAPHIC',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/VARGRAPHIC/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 417,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 417
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '86',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 0,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'subrule' => '_alternation_1_of_production_87_of_rule_sysibm_function',
                                                                                                        'matchrule' => 0,
                                                                                                        'implicit' => '/VARIANCE/i, or /VAR/i',
                                                                                                        'argcode' => undef,
                                                                                                        'lookahead' => 0,
                                                                                                        'line' => 418
                                                                                                      }, 'Parse::RecDescent::Subrule' )
                                                                                             ],
                                                                                  'line' => 418
                                                                                }, 'Parse::RecDescent::Production' ),
                                                                         bless( {
                                                                                  'number' => '87',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 0,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 1,
                                                                                  'actcount' => 0,
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'YEAR',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/YEAR/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 419,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                             ],
                                                                                  'line' => 419
                                                                                }, 'Parse::RecDescent::Production' )
                                                                       ],
                                                            'name' => 'sysibm_function',
                                                            'vars' => '',
                                                            'line' => 332
                                                          }, 'Parse::RecDescent::Rule' ),
                              'window_partition_clause' => bless( {
                                                                    'impcount' => 0,
                                                                    'calls' => [
                                                                                 'partitioning_expression'
                                                                               ],
                                                                    'changed' => 0,
                                                                    'opcount' => 0,
                                                                    'prods' => [
                                                                                 bless( {
                                                                                          'number' => '0',
                                                                                          'strcount' => 0,
                                                                                          'dircount' => 1,
                                                                                          'uncommit' => undef,
                                                                                          'error' => undef,
                                                                                          'patcount' => 2,
                                                                                          'actcount' => 0,
                                                                                          'op' => [],
                                                                                          'items' => [
                                                                                                       bless( {
                                                                                                                'pattern' => 'PARTITION\\s+BY',
                                                                                                                'hashname' => '__PATTERN1__',
                                                                                                                'description' => '/PARTITION\\\\s+BY/i',
                                                                                                                'lookahead' => 0,
                                                                                                                'rdelim' => '/',
                                                                                                                'line' => 553,
                                                                                                                'mod' => 'i',
                                                                                                                'ldelim' => '/'
                                                                                                              }, 'Parse::RecDescent::Token' ),
                                                                                                       bless( {
                                                                                                                'expected' => '<leftop: partitioning_expression /,/ partitioning_expression>',
                                                                                                                'min' => 1,
                                                                                                                'name' => '\'partitioning_expression(s)\'',
                                                                                                                'max' => 100000000,
                                                                                                                'leftarg' => bless( {
                                                                                                                                      'subrule' => 'partitioning_expression',
                                                                                                                                      'matchrule' => 0,
                                                                                                                                      'implicit' => undef,
                                                                                                                                      'argcode' => undef,
                                                                                                                                      'lookahead' => 0,
                                                                                                                                      'line' => 553
                                                                                                                                    }, 'Parse::RecDescent::Subrule' ),
                                                                                                                'rightarg' => bless( {
                                                                                                                                       'subrule' => 'partitioning_expression',
                                                                                                                                       'matchrule' => 0,
                                                                                                                                       'implicit' => undef,
                                                                                                                                       'argcode' => undef,
                                                                                                                                       'lookahead' => 0,
                                                                                                                                       'line' => 553
                                                                                                                                     }, 'Parse::RecDescent::Subrule' ),
                                                                                                                'hashname' => '__DIRECTIVE1__',
                                                                                                                'type' => 'leftop',
                                                                                                                'op' => bless( {
                                                                                                                                 'pattern' => ',',
                                                                                                                                 'hashname' => '__PATTERN2__',
                                                                                                                                 'description' => '/,/',
                                                                                                                                 'lookahead' => 0,
                                                                                                                                 'rdelim' => '/',
                                                                                                                                 'line' => 553,
                                                                                                                                 'mod' => '',
                                                                                                                                 'ldelim' => '/'
                                                                                                                               }, 'Parse::RecDescent::Token' )
                                                                                                              }, 'Parse::RecDescent::Operator' )
                                                                                                     ],
                                                                                          'line' => undef
                                                                                        }, 'Parse::RecDescent::Production' )
                                                                               ],
                                                                    'name' => 'window_partition_clause',
                                                                    'vars' => '',
                                                                    'line' => 553
                                                                  }, 'Parse::RecDescent::Rule' ),
                              'WHERE' => bless( {
                                                  'impcount' => 0,
                                                  'calls' => [],
                                                  'changed' => 0,
                                                  'opcount' => 0,
                                                  'prods' => [
                                                               bless( {
                                                                        'number' => '0',
                                                                        'strcount' => 0,
                                                                        'dircount' => 0,
                                                                        'uncommit' => undef,
                                                                        'error' => undef,
                                                                        'patcount' => 1,
                                                                        'actcount' => 0,
                                                                        'items' => [
                                                                                     bless( {
                                                                                              'pattern' => 'where',
                                                                                              'hashname' => '__PATTERN1__',
                                                                                              'description' => '/where/i',
                                                                                              'lookahead' => 0,
                                                                                              'rdelim' => '/',
                                                                                              'line' => 117,
                                                                                              'mod' => 'i',
                                                                                              'ldelim' => '/'
                                                                                            }, 'Parse::RecDescent::Token' )
                                                                                   ],
                                                                        'line' => undef
                                                                      }, 'Parse::RecDescent::Production' )
                                                             ],
                                                  'name' => 'WHERE',
                                                  'vars' => '',
                                                  'line' => 117
                                                }, 'Parse::RecDescent::Rule' ),
                              'CREATE' => bless( {
                                                   'impcount' => 0,
                                                   'calls' => [],
                                                   'changed' => 0,
                                                   'opcount' => 0,
                                                   'prods' => [
                                                                bless( {
                                                                         'number' => '0',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'create',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/create/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 101,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => undef
                                                                       }, 'Parse::RecDescent::Production' )
                                                              ],
                                                   'name' => 'CREATE',
                                                   'vars' => '',
                                                   'line' => 101
                                                 }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule_sysfun' => bless( {
                                                                                          'impcount' => 0,
                                                                                          'calls' => [],
                                                                                          'changed' => 0,
                                                                                          'opcount' => 0,
                                                                                          'prods' => [
                                                                                                       bless( {
                                                                                                                'number' => '0',
                                                                                                                'strcount' => 0,
                                                                                                                'dircount' => 0,
                                                                                                                'uncommit' => undef,
                                                                                                                'error' => undef,
                                                                                                                'patcount' => 1,
                                                                                                                'actcount' => 0,
                                                                                                                'items' => [
                                                                                                                             bless( {
                                                                                                                                      'pattern' => 'ABS',
                                                                                                                                      'hashname' => '__PATTERN1__',
                                                                                                                                      'description' => '/ABS/i',
                                                                                                                                      'lookahead' => 0,
                                                                                                                                      'rdelim' => '/',
                                                                                                                                      'line' => 628,
                                                                                                                                      'mod' => 'i',
                                                                                                                                      'ldelim' => '/'
                                                                                                                                    }, 'Parse::RecDescent::Token' )
                                                                                                                           ],
                                                                                                                'line' => undef
                                                                                                              }, 'Parse::RecDescent::Production' ),
                                                                                                       bless( {
                                                                                                                'number' => '1',
                                                                                                                'strcount' => 0,
                                                                                                                'dircount' => 0,
                                                                                                                'uncommit' => undef,
                                                                                                                'error' => undef,
                                                                                                                'patcount' => 1,
                                                                                                                'actcount' => 0,
                                                                                                                'items' => [
                                                                                                                             bless( {
                                                                                                                                      'pattern' => 'ABSVAL',
                                                                                                                                      'hashname' => '__PATTERN1__',
                                                                                                                                      'description' => '/ABSVAL/i',
                                                                                                                                      'lookahead' => 0,
                                                                                                                                      'rdelim' => '/',
                                                                                                                                      'line' => 628,
                                                                                                                                      'mod' => 'i',
                                                                                                                                      'ldelim' => '/'
                                                                                                                                    }, 'Parse::RecDescent::Token' )
                                                                                                                           ],
                                                                                                                'line' => 628
                                                                                                              }, 'Parse::RecDescent::Production' )
                                                                                                     ],
                                                                                          'name' => '_alternation_1_of_production_1_of_rule_sysfun',
                                                                                          'vars' => '',
                                                                                          'line' => 628
                                                                                        }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule_function' => bless( {
                                                                                            'impcount' => 0,
                                                                                            'calls' => [
                                                                                                         'sysibm_function',
                                                                                                         'sysfun_function',
                                                                                                         'userdefined_function'
                                                                                                       ],
                                                                                            'changed' => 0,
                                                                                            'opcount' => 0,
                                                                                            'prods' => [
                                                                                                         bless( {
                                                                                                                  'number' => '0',
                                                                                                                  'strcount' => 0,
                                                                                                                  'dircount' => 0,
                                                                                                                  'uncommit' => undef,
                                                                                                                  'error' => undef,
                                                                                                                  'patcount' => 1,
                                                                                                                  'actcount' => 0,
                                                                                                                  'items' => [
                                                                                                                               bless( {
                                                                                                                                        'pattern' => 'SYSIBM\\.|',
                                                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                                                        'description' => '/SYSIBM\\\\.|/i',
                                                                                                                                        'lookahead' => 0,
                                                                                                                                        'rdelim' => '/',
                                                                                                                                        'line' => 625,
                                                                                                                                        'mod' => 'i',
                                                                                                                                        'ldelim' => '/'
                                                                                                                                      }, 'Parse::RecDescent::Token' ),
                                                                                                                               bless( {
                                                                                                                                        'subrule' => 'sysibm_function',
                                                                                                                                        'matchrule' => 0,
                                                                                                                                        'implicit' => undef,
                                                                                                                                        'argcode' => undef,
                                                                                                                                        'lookahead' => 0,
                                                                                                                                        'line' => 625
                                                                                                                                      }, 'Parse::RecDescent::Subrule' )
                                                                                                                             ],
                                                                                                                  'line' => undef
                                                                                                                }, 'Parse::RecDescent::Production' ),
                                                                                                         bless( {
                                                                                                                  'number' => '1',
                                                                                                                  'strcount' => 0,
                                                                                                                  'dircount' => 0,
                                                                                                                  'uncommit' => undef,
                                                                                                                  'error' => undef,
                                                                                                                  'patcount' => 1,
                                                                                                                  'actcount' => 0,
                                                                                                                  'items' => [
                                                                                                                               bless( {
                                                                                                                                        'pattern' => 'SYSFUN\\.|',
                                                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                                                        'description' => '/SYSFUN\\\\.|/i',
                                                                                                                                        'lookahead' => 0,
                                                                                                                                        'rdelim' => '/',
                                                                                                                                        'line' => 626,
                                                                                                                                        'mod' => 'i',
                                                                                                                                        'ldelim' => '/'
                                                                                                                                      }, 'Parse::RecDescent::Token' ),
                                                                                                                               bless( {
                                                                                                                                        'subrule' => 'sysfun_function',
                                                                                                                                        'matchrule' => 0,
                                                                                                                                        'implicit' => undef,
                                                                                                                                        'argcode' => undef,
                                                                                                                                        'lookahead' => 0,
                                                                                                                                        'line' => 626
                                                                                                                                      }, 'Parse::RecDescent::Subrule' )
                                                                                                                             ],
                                                                                                                  'line' => 626
                                                                                                                }, 'Parse::RecDescent::Production' ),
                                                                                                         bless( {
                                                                                                                  'number' => '2',
                                                                                                                  'strcount' => 0,
                                                                                                                  'dircount' => 0,
                                                                                                                  'uncommit' => undef,
                                                                                                                  'error' => undef,
                                                                                                                  'patcount' => 0,
                                                                                                                  'actcount' => 0,
                                                                                                                  'items' => [
                                                                                                                               bless( {
                                                                                                                                        'subrule' => 'userdefined_function',
                                                                                                                                        'matchrule' => 0,
                                                                                                                                        'implicit' => undef,
                                                                                                                                        'argcode' => undef,
                                                                                                                                        'lookahead' => 0,
                                                                                                                                        'line' => 627
                                                                                                                                      }, 'Parse::RecDescent::Subrule' )
                                                                                                                             ],
                                                                                                                  'line' => 627
                                                                                                                }, 'Parse::RecDescent::Production' )
                                                                                                       ],
                                                                                            'name' => '_alternation_1_of_production_1_of_rule_function',
                                                                                            'vars' => '',
                                                                                            'line' => 625
                                                                                          }, 'Parse::RecDescent::Rule' ),
                              'identifier' => bless( {
                                                       'impcount' => 0,
                                                       'calls' => [
                                                                    'NAME'
                                                                  ],
                                                       'changed' => 0,
                                                       'opcount' => 0,
                                                       'prods' => [
                                                                    bless( {
                                                                             'number' => '0',
                                                                             'strcount' => 0,
                                                                             'dircount' => 0,
                                                                             'uncommit' => undef,
                                                                             'error' => undef,
                                                                             'patcount' => 0,
                                                                             'actcount' => 0,
                                                                             'items' => [
                                                                                          bless( {
                                                                                                   'subrule' => 'NAME',
                                                                                                   'matchrule' => 0,
                                                                                                   'implicit' => undef,
                                                                                                   'argcode' => undef,
                                                                                                   'lookahead' => 0,
                                                                                                   'line' => 136
                                                                                                 }, 'Parse::RecDescent::Subrule' )
                                                                                        ],
                                                                             'line' => undef
                                                                           }, 'Parse::RecDescent::Production' )
                                                                  ],
                                                       'name' => 'identifier',
                                                       'vars' => '',
                                                       'line' => 136
                                                     }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_window_order_clause' => bless( {
                                                                                                                                              'impcount' => 0,
                                                                                                                                              'calls' => [
                                                                                                                                                           'asc_option',
                                                                                                                                                           'desc_option'
                                                                                                                                                         ],
                                                                                                                                              'changed' => 0,
                                                                                                                                              'opcount' => 0,
                                                                                                                                              'prods' => [
                                                                                                                                                           bless( {
                                                                                                                                                                    'number' => '0',
                                                                                                                                                                    'strcount' => 0,
                                                                                                                                                                    'dircount' => 0,
                                                                                                                                                                    'uncommit' => undef,
                                                                                                                                                                    'error' => undef,
                                                                                                                                                                    'patcount' => 0,
                                                                                                                                                                    'actcount' => 0,
                                                                                                                                                                    'items' => [
                                                                                                                                                                                 bless( {
                                                                                                                                                                                          'subrule' => 'asc_option',
                                                                                                                                                                                          'matchrule' => 0,
                                                                                                                                                                                          'implicit' => undef,
                                                                                                                                                                                          'argcode' => undef,
                                                                                                                                                                                          'lookahead' => 0,
                                                                                                                                                                                          'line' => 626
                                                                                                                                                                                        }, 'Parse::RecDescent::Subrule' )
                                                                                                                                                                               ],
                                                                                                                                                                    'line' => undef
                                                                                                                                                                  }, 'Parse::RecDescent::Production' ),
                                                                                                                                                           bless( {
                                                                                                                                                                    'number' => '1',
                                                                                                                                                                    'strcount' => 0,
                                                                                                                                                                    'dircount' => 0,
                                                                                                                                                                    'uncommit' => undef,
                                                                                                                                                                    'error' => undef,
                                                                                                                                                                    'patcount' => 0,
                                                                                                                                                                    'actcount' => 0,
                                                                                                                                                                    'items' => [
                                                                                                                                                                                 bless( {
                                                                                                                                                                                          'subrule' => 'desc_option',
                                                                                                                                                                                          'matchrule' => 0,
                                                                                                                                                                                          'implicit' => undef,
                                                                                                                                                                                          'argcode' => undef,
                                                                                                                                                                                          'lookahead' => 0,
                                                                                                                                                                                          'line' => 627
                                                                                                                                                                                        }, 'Parse::RecDescent::Subrule' )
                                                                                                                                                                               ],
                                                                                                                                                                    'line' => 627
                                                                                                                                                                  }, 'Parse::RecDescent::Production' )
                                                                                                                                                         ],
                                                                                                                                              'name' => '_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_window_order_clause',
                                                                                                                                              'vars' => '',
                                                                                                                                              'line' => 626
                                                                                                                                            }, 'Parse::RecDescent::Rule' ),
                              'result_expression' => bless( {
                                                              'impcount' => 0,
                                                              'calls' => [
                                                                           'expression'
                                                                         ],
                                                              'changed' => 0,
                                                              'opcount' => 0,
                                                              'prods' => [
                                                                           bless( {
                                                                                    'number' => '0',
                                                                                    'strcount' => 0,
                                                                                    'dircount' => 0,
                                                                                    'uncommit' => undef,
                                                                                    'error' => undef,
                                                                                    'patcount' => 0,
                                                                                    'actcount' => 0,
                                                                                    'items' => [
                                                                                                 bless( {
                                                                                                          'subrule' => 'expression',
                                                                                                          'matchrule' => 0,
                                                                                                          'implicit' => undef,
                                                                                                          'argcode' => undef,
                                                                                                          'lookahead' => 0,
                                                                                                          'line' => 515
                                                                                                        }, 'Parse::RecDescent::Subrule' )
                                                                                               ],
                                                                                    'line' => undef
                                                                                  }, 'Parse::RecDescent::Production' )
                                                                         ],
                                                              'name' => 'result_expression',
                                                              'vars' => '',
                                                              'line' => 515
                                                            }, 'Parse::RecDescent::Rule' ),
                              'scoped_reference_expression' => bless( {
                                                                        'impcount' => 0,
                                                                        'calls' => [
                                                                                     'expression'
                                                                                   ],
                                                                        'changed' => 0,
                                                                        'opcount' => 0,
                                                                        'prods' => [
                                                                                     bless( {
                                                                                              'number' => '0',
                                                                                              'strcount' => 0,
                                                                                              'dircount' => 0,
                                                                                              'uncommit' => undef,
                                                                                              'error' => undef,
                                                                                              'patcount' => 0,
                                                                                              'actcount' => 1,
                                                                                              'items' => [
                                                                                                           bless( {
                                                                                                                    'subrule' => 'expression',
                                                                                                                    'matchrule' => 0,
                                                                                                                    'implicit' => undef,
                                                                                                                    'argcode' => undef,
                                                                                                                    'lookahead' => 0,
                                                                                                                    'line' => 532
                                                                                                                  }, 'Parse::RecDescent::Subrule' ),
                                                                                                           bless( {
                                                                                                                    'hashname' => '__ACTION1__',
                                                                                                                    'lookahead' => 0,
                                                                                                                    'line' => 533,
                                                                                                                    'code' => '{ # scoped, reference
}'
                                                                                                                  }, 'Parse::RecDescent::Action' )
                                                                                                         ],
                                                                                              'line' => undef
                                                                                            }, 'Parse::RecDescent::Production' )
                                                                                   ],
                                                                        'name' => 'scoped_reference_expression',
                                                                        'vars' => '',
                                                                        'line' => 528
                                                                      }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cast_specification' => bless( {
                                                                                                                                             'impcount' => 0,
                                                                                                                                             'calls' => [
                                                                                                                                                          'typed_table_name',
                                                                                                                                                          'typed_view_name'
                                                                                                                                                        ],
                                                                                                                                             'changed' => 0,
                                                                                                                                             'opcount' => 0,
                                                                                                                                             'prods' => [
                                                                                                                                                          bless( {
                                                                                                                                                                   'number' => '0',
                                                                                                                                                                   'strcount' => 0,
                                                                                                                                                                   'dircount' => 0,
                                                                                                                                                                   'uncommit' => undef,
                                                                                                                                                                   'error' => undef,
                                                                                                                                                                   'patcount' => 0,
                                                                                                                                                                   'actcount' => 0,
                                                                                                                                                                   'items' => [
                                                                                                                                                                                bless( {
                                                                                                                                                                                         'subrule' => 'typed_table_name',
                                                                                                                                                                                         'matchrule' => 0,
                                                                                                                                                                                         'implicit' => undef,
                                                                                                                                                                                         'argcode' => undef,
                                                                                                                                                                                         'lookahead' => 0,
                                                                                                                                                                                         'line' => 626
                                                                                                                                                                                       }, 'Parse::RecDescent::Subrule' )
                                                                                                                                                                              ],
                                                                                                                                                                   'line' => undef
                                                                                                                                                                 }, 'Parse::RecDescent::Production' ),
                                                                                                                                                          bless( {
                                                                                                                                                                   'number' => '1',
                                                                                                                                                                   'strcount' => 0,
                                                                                                                                                                   'dircount' => 0,
                                                                                                                                                                   'uncommit' => undef,
                                                                                                                                                                   'error' => undef,
                                                                                                                                                                   'patcount' => 0,
                                                                                                                                                                   'actcount' => 0,
                                                                                                                                                                   'items' => [
                                                                                                                                                                                bless( {
                                                                                                                                                                                         'subrule' => 'typed_view_name',
                                                                                                                                                                                         'matchrule' => 0,
                                                                                                                                                                                         'implicit' => undef,
                                                                                                                                                                                         'argcode' => undef,
                                                                                                                                                                                         'lookahead' => 0,
                                                                                                                                                                                         'line' => 627
                                                                                                                                                                                       }, 'Parse::RecDescent::Subrule' )
                                                                                                                                                                              ],
                                                                                                                                                                   'line' => 627
                                                                                                                                                                 }, 'Parse::RecDescent::Production' )
                                                                                                                                                        ],
                                                                                                                                             'name' => '_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cast_specification',
                                                                                                                                             'vars' => '',
                                                                                                                                             'line' => 626
                                                                                                                                           }, 'Parse::RecDescent::Rule' ),
                              'when_clause' => bless( {
                                                        'impcount' => 0,
                                                        'calls' => [
                                                                     'search_condition'
                                                                   ],
                                                        'changed' => 0,
                                                        'opcount' => 0,
                                                        'prods' => [
                                                                     bless( {
                                                                              'number' => '0',
                                                                              'strcount' => 2,
                                                                              'dircount' => 0,
                                                                              'uncommit' => undef,
                                                                              'error' => undef,
                                                                              'patcount' => 1,
                                                                              'actcount' => 1,
                                                                              'items' => [
                                                                                           bless( {
                                                                                                    'pattern' => 'WHEN',
                                                                                                    'hashname' => '__PATTERN1__',
                                                                                                    'description' => '/WHEN/i',
                                                                                                    'lookahead' => 0,
                                                                                                    'rdelim' => '/',
                                                                                                    'line' => 261,
                                                                                                    'mod' => 'i',
                                                                                                    'ldelim' => '/'
                                                                                                  }, 'Parse::RecDescent::Token' ),
                                                                                           bless( {
                                                                                                    'pattern' => '(',
                                                                                                    'hashname' => '__STRING1__',
                                                                                                    'description' => '\'(\'',
                                                                                                    'lookahead' => 0,
                                                                                                    'line' => 261
                                                                                                  }, 'Parse::RecDescent::Literal' ),
                                                                                           bless( {
                                                                                                    'subrule' => 'search_condition',
                                                                                                    'matchrule' => 0,
                                                                                                    'implicit' => undef,
                                                                                                    'argcode' => undef,
                                                                                                    'lookahead' => 0,
                                                                                                    'line' => 261
                                                                                                  }, 'Parse::RecDescent::Subrule' ),
                                                                                           bless( {
                                                                                                    'pattern' => ')',
                                                                                                    'hashname' => '__STRING2__',
                                                                                                    'description' => '\')\'',
                                                                                                    'lookahead' => 0,
                                                                                                    'line' => 261
                                                                                                  }, 'Parse::RecDescent::Literal' ),
                                                                                           bless( {
                                                                                                    'hashname' => '__ACTION1__',
                                                                                                    'lookahead' => 0,
                                                                                                    'line' => 261,
                                                                                                    'code' => '{$return = $item[3]}'
                                                                                                  }, 'Parse::RecDescent::Action' )
                                                                                         ],
                                                                              'line' => undef
                                                                            }, 'Parse::RecDescent::Production' )
                                                                   ],
                                                        'name' => 'when_clause',
                                                        'vars' => '',
                                                        'line' => 259
                                                      }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule_asc_option' => bless( {
                                                                                              'impcount' => 0,
                                                                                              'calls' => [],
                                                                                              'changed' => 0,
                                                                                              'opcount' => 0,
                                                                                              'prods' => [
                                                                                                           bless( {
                                                                                                                    'number' => '0',
                                                                                                                    'strcount' => 0,
                                                                                                                    'dircount' => 0,
                                                                                                                    'uncommit' => undef,
                                                                                                                    'error' => undef,
                                                                                                                    'patcount' => 1,
                                                                                                                    'actcount' => 0,
                                                                                                                    'items' => [
                                                                                                                                 bless( {
                                                                                                                                          'pattern' => 'NULLS\\s+FIRST',
                                                                                                                                          'hashname' => '__PATTERN1__',
                                                                                                                                          'description' => '/NULLS\\\\s+FIRST/i',
                                                                                                                                          'lookahead' => 0,
                                                                                                                                          'rdelim' => '/',
                                                                                                                                          'line' => 628,
                                                                                                                                          'mod' => 'i',
                                                                                                                                          'ldelim' => '/'
                                                                                                                                        }, 'Parse::RecDescent::Token' )
                                                                                                                               ],
                                                                                                                    'line' => undef
                                                                                                                  }, 'Parse::RecDescent::Production' ),
                                                                                                           bless( {
                                                                                                                    'number' => '1',
                                                                                                                    'strcount' => 0,
                                                                                                                    'dircount' => 0,
                                                                                                                    'uncommit' => undef,
                                                                                                                    'error' => undef,
                                                                                                                    'patcount' => 1,
                                                                                                                    'actcount' => 0,
                                                                                                                    'items' => [
                                                                                                                                 bless( {
                                                                                                                                          'pattern' => 'NULLS\\s+LAST',
                                                                                                                                          'hashname' => '__PATTERN1__',
                                                                                                                                          'description' => '/NULLS\\\\s+LAST/i',
                                                                                                                                          'lookahead' => 0,
                                                                                                                                          'rdelim' => '/',
                                                                                                                                          'line' => 628,
                                                                                                                                          'mod' => 'i',
                                                                                                                                          'ldelim' => '/'
                                                                                                                                        }, 'Parse::RecDescent::Token' )
                                                                                                                               ],
                                                                                                                    'line' => 628
                                                                                                                  }, 'Parse::RecDescent::Production' )
                                                                                                         ],
                                                                                              'name' => '_alternation_1_of_production_1_of_rule_asc_option',
                                                                                              'vars' => '',
                                                                                              'line' => 628
                                                                                            }, 'Parse::RecDescent::Rule' ),
                              'sequence_name' => bless( {
                                                          'impcount' => 0,
                                                          'calls' => [
                                                                       'NAME'
                                                                     ],
                                                          'changed' => 0,
                                                          'opcount' => 0,
                                                          'prods' => [
                                                                       bless( {
                                                                                'number' => '0',
                                                                                'strcount' => 0,
                                                                                'dircount' => 0,
                                                                                'uncommit' => undef,
                                                                                'error' => undef,
                                                                                'patcount' => 0,
                                                                                'actcount' => 0,
                                                                                'items' => [
                                                                                             bless( {
                                                                                                      'subrule' => 'NAME',
                                                                                                      'matchrule' => 0,
                                                                                                      'implicit' => undef,
                                                                                                      'argcode' => undef,
                                                                                                      'lookahead' => 0,
                                                                                                      'line' => 615
                                                                                                    }, 'Parse::RecDescent::Subrule' )
                                                                                           ],
                                                                                'line' => undef
                                                                              }, 'Parse::RecDescent::Production' )
                                                                     ],
                                                          'name' => 'sequence_name',
                                                          'vars' => '',
                                                          'line' => 615
                                                        }, 'Parse::RecDescent::Rule' ),
                              'ld_duration' => bless( {
                                                        'impcount' => 0,
                                                        'calls' => [],
                                                        'changed' => 0,
                                                        'opcount' => 0,
                                                        'prods' => [
                                                                     bless( {
                                                                              'number' => '0',
                                                                              'strcount' => 0,
                                                                              'dircount' => 0,
                                                                              'uncommit' => undef,
                                                                              'error' => undef,
                                                                              'patcount' => 1,
                                                                              'actcount' => 0,
                                                                              'items' => [
                                                                                           bless( {
                                                                                                    'pattern' => 'YEARS?',
                                                                                                    'hashname' => '__PATTERN1__',
                                                                                                    'description' => '/YEARS?/i',
                                                                                                    'lookahead' => 0,
                                                                                                    'rdelim' => '/',
                                                                                                    'line' => 488,
                                                                                                    'mod' => 'i',
                                                                                                    'ldelim' => '/'
                                                                                                  }, 'Parse::RecDescent::Token' )
                                                                                         ],
                                                                              'line' => undef
                                                                            }, 'Parse::RecDescent::Production' ),
                                                                     bless( {
                                                                              'number' => '1',
                                                                              'strcount' => 0,
                                                                              'dircount' => 0,
                                                                              'uncommit' => undef,
                                                                              'error' => undef,
                                                                              'patcount' => 1,
                                                                              'actcount' => 0,
                                                                              'items' => [
                                                                                           bless( {
                                                                                                    'pattern' => 'MONTHS?',
                                                                                                    'hashname' => '__PATTERN1__',
                                                                                                    'description' => '/MONTHS?/i',
                                                                                                    'lookahead' => 0,
                                                                                                    'rdelim' => '/',
                                                                                                    'line' => 489,
                                                                                                    'mod' => 'i',
                                                                                                    'ldelim' => '/'
                                                                                                  }, 'Parse::RecDescent::Token' )
                                                                                         ],
                                                                              'line' => 489
                                                                            }, 'Parse::RecDescent::Production' ),
                                                                     bless( {
                                                                              'number' => '2',
                                                                              'strcount' => 0,
                                                                              'dircount' => 0,
                                                                              'uncommit' => undef,
                                                                              'error' => undef,
                                                                              'patcount' => 1,
                                                                              'actcount' => 0,
                                                                              'items' => [
                                                                                           bless( {
                                                                                                    'pattern' => 'DAYS?',
                                                                                                    'hashname' => '__PATTERN1__',
                                                                                                    'description' => '/DAYS?/i',
                                                                                                    'lookahead' => 0,
                                                                                                    'rdelim' => '/',
                                                                                                    'line' => 490,
                                                                                                    'mod' => 'i',
                                                                                                    'ldelim' => '/'
                                                                                                  }, 'Parse::RecDescent::Token' )
                                                                                         ],
                                                                              'line' => 490
                                                                            }, 'Parse::RecDescent::Production' ),
                                                                     bless( {
                                                                              'number' => '3',
                                                                              'strcount' => 0,
                                                                              'dircount' => 0,
                                                                              'uncommit' => undef,
                                                                              'error' => undef,
                                                                              'patcount' => 1,
                                                                              'actcount' => 0,
                                                                              'items' => [
                                                                                           bless( {
                                                                                                    'pattern' => 'HOURS?',
                                                                                                    'hashname' => '__PATTERN1__',
                                                                                                    'description' => '/HOURS?/i',
                                                                                                    'lookahead' => 0,
                                                                                                    'rdelim' => '/',
                                                                                                    'line' => 491,
                                                                                                    'mod' => 'i',
                                                                                                    'ldelim' => '/'
                                                                                                  }, 'Parse::RecDescent::Token' )
                                                                                         ],
                                                                              'line' => 491
                                                                            }, 'Parse::RecDescent::Production' ),
                                                                     bless( {
                                                                              'number' => '4',
                                                                              'strcount' => 0,
                                                                              'dircount' => 0,
                                                                              'uncommit' => undef,
                                                                              'error' => undef,
                                                                              'patcount' => 1,
                                                                              'actcount' => 0,
                                                                              'items' => [
                                                                                           bless( {
                                                                                                    'pattern' => 'MINUTES?',
                                                                                                    'hashname' => '__PATTERN1__',
                                                                                                    'description' => '/MINUTES?/i',
                                                                                                    'lookahead' => 0,
                                                                                                    'rdelim' => '/',
                                                                                                    'line' => 492,
                                                                                                    'mod' => 'i',
                                                                                                    'ldelim' => '/'
                                                                                                  }, 'Parse::RecDescent::Token' )
                                                                                         ],
                                                                              'line' => 492
                                                                            }, 'Parse::RecDescent::Production' ),
                                                                     bless( {
                                                                              'number' => '5',
                                                                              'strcount' => 0,
                                                                              'dircount' => 0,
                                                                              'uncommit' => undef,
                                                                              'error' => undef,
                                                                              'patcount' => 1,
                                                                              'actcount' => 0,
                                                                              'items' => [
                                                                                           bless( {
                                                                                                    'pattern' => 'SECONDS?',
                                                                                                    'hashname' => '__PATTERN1__',
                                                                                                    'description' => '/SECONDS?/i',
                                                                                                    'lookahead' => 0,
                                                                                                    'rdelim' => '/',
                                                                                                    'line' => 493,
                                                                                                    'mod' => 'i',
                                                                                                    'ldelim' => '/'
                                                                                                  }, 'Parse::RecDescent::Token' )
                                                                                         ],
                                                                              'line' => 493
                                                                            }, 'Parse::RecDescent::Production' ),
                                                                     bless( {
                                                                              'number' => '6',
                                                                              'strcount' => 0,
                                                                              'dircount' => 0,
                                                                              'uncommit' => undef,
                                                                              'error' => undef,
                                                                              'patcount' => 1,
                                                                              'actcount' => 0,
                                                                              'items' => [
                                                                                           bless( {
                                                                                                    'pattern' => 'MICROSECONDS?',
                                                                                                    'hashname' => '__PATTERN1__',
                                                                                                    'description' => '/MICROSECONDS?/i',
                                                                                                    'lookahead' => 0,
                                                                                                    'rdelim' => '/',
                                                                                                    'line' => 494,
                                                                                                    'mod' => 'i',
                                                                                                    'ldelim' => '/'
                                                                                                  }, 'Parse::RecDescent::Token' )
                                                                                         ],
                                                                              'line' => 494
                                                                            }, 'Parse::RecDescent::Production' )
                                                                   ],
                                                        'name' => 'ld_duration',
                                                        'vars' => '',
                                                        'line' => 488
                                                      }, 'Parse::RecDescent::Rule' ),
                              'reference_a' => bless( {
                                                        'impcount' => 0,
                                                        'calls' => [
                                                                     'old_new_corr',
                                                                     'old_new_table'
                                                                   ],
                                                        'changed' => 0,
                                                        'opcount' => 0,
                                                        'prods' => [
                                                                     bless( {
                                                                              'number' => '0',
                                                                              'strcount' => 0,
                                                                              'dircount' => 0,
                                                                              'uncommit' => undef,
                                                                              'error' => undef,
                                                                              'patcount' => 1,
                                                                              'actcount' => 1,
                                                                              'items' => [
                                                                                           bless( {
                                                                                                    'pattern' => 'REFERENCING',
                                                                                                    'hashname' => '__PATTERN1__',
                                                                                                    'description' => '/REFERENCING/i',
                                                                                                    'lookahead' => 0,
                                                                                                    'rdelim' => '/',
                                                                                                    'line' => 283,
                                                                                                    'mod' => 'i',
                                                                                                    'ldelim' => '/'
                                                                                                  }, 'Parse::RecDescent::Token' ),
                                                                                           bless( {
                                                                                                    'subrule' => 'old_new_corr',
                                                                                                    'expected' => undef,
                                                                                                    'min' => 0,
                                                                                                    'argcode' => undef,
                                                                                                    'max' => 2,
                                                                                                    'matchrule' => 0,
                                                                                                    'repspec' => '0..2',
                                                                                                    'lookahead' => 0,
                                                                                                    'line' => 283
                                                                                                  }, 'Parse::RecDescent::Repetition' ),
                                                                                           bless( {
                                                                                                    'subrule' => 'old_new_table',
                                                                                                    'expected' => undef,
                                                                                                    'min' => 0,
                                                                                                    'argcode' => undef,
                                                                                                    'max' => 2,
                                                                                                    'matchrule' => 0,
                                                                                                    'repspec' => '0..2',
                                                                                                    'lookahead' => 0,
                                                                                                    'line' => 283
                                                                                                  }, 'Parse::RecDescent::Repetition' ),
                                                                                           bless( {
                                                                                                    'hashname' => '__ACTION1__',
                                                                                                    'lookahead' => 0,
                                                                                                    'line' => 284,
                                                                                                    'code' => '{ $return = join(\' \', $item[1], join(\' \', @{$item[2]}), join(\' \', @{$item[3]})  ) }'
                                                                                                  }, 'Parse::RecDescent::Action' )
                                                                                         ],
                                                                              'line' => undef
                                                                            }, 'Parse::RecDescent::Production' )
                                                                   ],
                                                        'name' => 'reference_a',
                                                        'vars' => '',
                                                        'line' => 283
                                                      }, 'Parse::RecDescent::Rule' ),
                              'cast_specification' => bless( {
                                                               'impcount' => 2,
                                                               'calls' => [
                                                                            '_alternation_1_of_production_1_of_rule_cast_specification',
                                                                            'data_type',
                                                                            '_alternation_2_of_production_1_of_rule_cast_specification'
                                                                          ],
                                                               'changed' => 0,
                                                               'opcount' => 0,
                                                               'prods' => [
                                                                            bless( {
                                                                                     'number' => '0',
                                                                                     'strcount' => 2,
                                                                                     'dircount' => 0,
                                                                                     'uncommit' => undef,
                                                                                     'error' => undef,
                                                                                     'patcount' => 2,
                                                                                     'actcount' => 0,
                                                                                     'items' => [
                                                                                                  bless( {
                                                                                                           'pattern' => 'CAST',
                                                                                                           'hashname' => '__PATTERN1__',
                                                                                                           'description' => '/CAST/i',
                                                                                                           'lookahead' => 0,
                                                                                                           'rdelim' => '/',
                                                                                                           'line' => 517,
                                                                                                           'mod' => 'i',
                                                                                                           'ldelim' => '/'
                                                                                                         }, 'Parse::RecDescent::Token' ),
                                                                                                  bless( {
                                                                                                           'pattern' => '(',
                                                                                                           'hashname' => '__STRING1__',
                                                                                                           'description' => '\'(\'',
                                                                                                           'lookahead' => 0,
                                                                                                           'line' => 517
                                                                                                         }, 'Parse::RecDescent::Literal' ),
                                                                                                  bless( {
                                                                                                           'subrule' => '_alternation_1_of_production_1_of_rule_cast_specification',
                                                                                                           'matchrule' => 0,
                                                                                                           'implicit' => 'expression, or /NULL/i, or parameter_marker',
                                                                                                           'argcode' => undef,
                                                                                                           'lookahead' => 0,
                                                                                                           'line' => 520
                                                                                                         }, 'Parse::RecDescent::Subrule' ),
                                                                                                  bless( {
                                                                                                           'pattern' => 'AS',
                                                                                                           'hashname' => '__PATTERN2__',
                                                                                                           'description' => '/AS/i',
                                                                                                           'lookahead' => 0,
                                                                                                           'rdelim' => '/',
                                                                                                           'line' => 520,
                                                                                                           'mod' => 'i',
                                                                                                           'ldelim' => '/'
                                                                                                         }, 'Parse::RecDescent::Token' ),
                                                                                                  bless( {
                                                                                                           'subrule' => 'data_type',
                                                                                                           'matchrule' => 0,
                                                                                                           'implicit' => undef,
                                                                                                           'argcode' => undef,
                                                                                                           'lookahead' => 0,
                                                                                                           'line' => 520
                                                                                                         }, 'Parse::RecDescent::Subrule' ),
                                                                                                  bless( {
                                                                                                           'subrule' => '_alternation_2_of_production_1_of_rule_cast_specification',
                                                                                                           'expected' => '/SCOPE/',
                                                                                                           'min' => 0,
                                                                                                           'argcode' => undef,
                                                                                                           'max' => 1,
                                                                                                           'matchrule' => 0,
                                                                                                           'repspec' => '?',
                                                                                                           'lookahead' => 0,
                                                                                                           'line' => 524
                                                                                                         }, 'Parse::RecDescent::Repetition' ),
                                                                                                  bless( {
                                                                                                           'pattern' => ')',
                                                                                                           'hashname' => '__STRING2__',
                                                                                                           'description' => '\')\'',
                                                                                                           'lookahead' => 0,
                                                                                                           'line' => 524
                                                                                                         }, 'Parse::RecDescent::Literal' )
                                                                                                ],
                                                                                     'line' => undef
                                                                                   }, 'Parse::RecDescent::Production' )
                                                                          ],
                                                               'name' => 'cast_specification',
                                                               'vars' => '',
                                                               'line' => 517
                                                             }, 'Parse::RecDescent::Rule' ),
                              'type' => bless( {
                                                 'impcount' => 1,
                                                 'calls' => [
                                                              'column_name',
                                                              '_alternation_1_of_production_2_of_rule_type'
                                                            ],
                                                 'changed' => 0,
                                                 'opcount' => 0,
                                                 'prods' => [
                                                              bless( {
                                                                       'number' => '0',
                                                                       'strcount' => 0,
                                                                       'dircount' => 1,
                                                                       'uncommit' => undef,
                                                                       'error' => undef,
                                                                       'patcount' => 3,
                                                                       'actcount' => 1,
                                                                       'op' => [],
                                                                       'items' => [
                                                                                    bless( {
                                                                                             'pattern' => 'UPDATE',
                                                                                             'hashname' => '__PATTERN1__',
                                                                                             'description' => '/UPDATE/i',
                                                                                             'lookahead' => 0,
                                                                                             'rdelim' => '/',
                                                                                             'line' => 272,
                                                                                             'mod' => 'i',
                                                                                             'ldelim' => '/'
                                                                                           }, 'Parse::RecDescent::Token' ),
                                                                                    bless( {
                                                                                             'pattern' => 'OF',
                                                                                             'hashname' => '__PATTERN2__',
                                                                                             'description' => '/OF/i',
                                                                                             'lookahead' => 0,
                                                                                             'rdelim' => '/',
                                                                                             'line' => 272,
                                                                                             'mod' => 'i',
                                                                                             'ldelim' => '/'
                                                                                           }, 'Parse::RecDescent::Token' ),
                                                                                    bless( {
                                                                                             'expected' => '<leftop: column_name /,/ column_name>',
                                                                                             'min' => 1,
                                                                                             'name' => '\'column_name(s)\'',
                                                                                             'max' => 100000000,
                                                                                             'leftarg' => bless( {
                                                                                                                   'subrule' => 'column_name',
                                                                                                                   'matchrule' => 0,
                                                                                                                   'implicit' => undef,
                                                                                                                   'argcode' => undef,
                                                                                                                   'lookahead' => 0,
                                                                                                                   'line' => 272
                                                                                                                 }, 'Parse::RecDescent::Subrule' ),
                                                                                             'rightarg' => bless( {
                                                                                                                    'subrule' => 'column_name',
                                                                                                                    'matchrule' => 0,
                                                                                                                    'implicit' => undef,
                                                                                                                    'argcode' => undef,
                                                                                                                    'lookahead' => 0,
                                                                                                                    'line' => 272
                                                                                                                  }, 'Parse::RecDescent::Subrule' ),
                                                                                             'hashname' => '__DIRECTIVE1__',
                                                                                             'type' => 'leftop',
                                                                                             'op' => bless( {
                                                                                                              'pattern' => ',',
                                                                                                              'hashname' => '__PATTERN3__',
                                                                                                              'description' => '/,/',
                                                                                                              'lookahead' => 0,
                                                                                                              'rdelim' => '/',
                                                                                                              'line' => 272,
                                                                                                              'mod' => '',
                                                                                                              'ldelim' => '/'
                                                                                                            }, 'Parse::RecDescent::Token' )
                                                                                           }, 'Parse::RecDescent::Operator' ),
                                                                                    bless( {
                                                                                             'hashname' => '__ACTION1__',
                                                                                             'lookahead' => 0,
                                                                                             'line' => 273,
                                                                                             'code' => '{ $return = { event  => \'update_on\',
              fields => $item[3] }
}'
                                                                                           }, 'Parse::RecDescent::Action' )
                                                                                  ],
                                                                       'line' => undef
                                                                     }, 'Parse::RecDescent::Production' ),
                                                              bless( {
                                                                       'number' => '1',
                                                                       'strcount' => 0,
                                                                       'dircount' => 0,
                                                                       'uncommit' => undef,
                                                                       'error' => undef,
                                                                       'patcount' => 0,
                                                                       'actcount' => 1,
                                                                       'items' => [
                                                                                    bless( {
                                                                                             'subrule' => '_alternation_1_of_production_2_of_rule_type',
                                                                                             'matchrule' => 0,
                                                                                             'implicit' => '/INSERT/i, or /DELETE/i, or /UPDATE/i',
                                                                                             'argcode' => undef,
                                                                                             'lookahead' => 0,
                                                                                             'line' => 277
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'hashname' => '__ACTION1__',
                                                                                             'lookahead' => 0,
                                                                                             'line' => 278,
                                                                                             'code' => '{ $return = { event => $item[1] } }'
                                                                                           }, 'Parse::RecDescent::Action' )
                                                                                  ],
                                                                       'line' => undef
                                                                     }, 'Parse::RecDescent::Production' )
                                                            ],
                                                 'name' => 'type',
                                                 'vars' => '',
                                                 'line' => 272
                                               }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_12_of_rule_sysibm_function' => bless( {
                                                                                                    'impcount' => 0,
                                                                                                    'calls' => [],
                                                                                                    'changed' => 0,
                                                                                                    'opcount' => 0,
                                                                                                    'prods' => [
                                                                                                                 bless( {
                                                                                                                          'number' => '0',
                                                                                                                          'strcount' => 0,
                                                                                                                          'dircount' => 0,
                                                                                                                          'uncommit' => undef,
                                                                                                                          'error' => undef,
                                                                                                                          'patcount' => 1,
                                                                                                                          'actcount' => 0,
                                                                                                                          'items' => [
                                                                                                                                       bless( {
                                                                                                                                                'pattern' => 'COVARIANCE',
                                                                                                                                                'hashname' => '__PATTERN1__',
                                                                                                                                                'description' => '/COVARIANCE/i',
                                                                                                                                                'lookahead' => 0,
                                                                                                                                                'rdelim' => '/',
                                                                                                                                                'line' => 628,
                                                                                                                                                'mod' => 'i',
                                                                                                                                                'ldelim' => '/'
                                                                                                                                              }, 'Parse::RecDescent::Token' )
                                                                                                                                     ],
                                                                                                                          'line' => undef
                                                                                                                        }, 'Parse::RecDescent::Production' ),
                                                                                                                 bless( {
                                                                                                                          'number' => '1',
                                                                                                                          'strcount' => 0,
                                                                                                                          'dircount' => 0,
                                                                                                                          'uncommit' => undef,
                                                                                                                          'error' => undef,
                                                                                                                          'patcount' => 1,
                                                                                                                          'actcount' => 0,
                                                                                                                          'items' => [
                                                                                                                                       bless( {
                                                                                                                                                'pattern' => 'COVAR',
                                                                                                                                                'hashname' => '__PATTERN1__',
                                                                                                                                                'description' => '/COVAR/i',
                                                                                                                                                'lookahead' => 0,
                                                                                                                                                'rdelim' => '/',
                                                                                                                                                'line' => 628,
                                                                                                                                                'mod' => 'i',
                                                                                                                                                'ldelim' => '/'
                                                                                                                                              }, 'Parse::RecDescent::Token' )
                                                                                                                                     ],
                                                                                                                          'line' => 628
                                                                                                                        }, 'Parse::RecDescent::Production' )
                                                                                                               ],
                                                                                                    'name' => '_alternation_1_of_production_12_of_rule_sysibm_function',
                                                                                                    'vars' => '',
                                                                                                    'line' => 628
                                                                                                  }, 'Parse::RecDescent::Rule' ),
                              'scalar_fullselect' => bless( {
                                                              'impcount' => 0,
                                                              'calls' => [
                                                                           'fullselect'
                                                                         ],
                                                              'changed' => 0,
                                                              'opcount' => 0,
                                                              'prods' => [
                                                                           bless( {
                                                                                    'number' => '0',
                                                                                    'strcount' => 2,
                                                                                    'dircount' => 0,
                                                                                    'uncommit' => undef,
                                                                                    'error' => undef,
                                                                                    'patcount' => 0,
                                                                                    'actcount' => 0,
                                                                                    'items' => [
                                                                                                 bless( {
                                                                                                          'pattern' => '(',
                                                                                                          'hashname' => '__STRING1__',
                                                                                                          'description' => '\'(\'',
                                                                                                          'lookahead' => 0,
                                                                                                          'line' => 478
                                                                                                        }, 'Parse::RecDescent::Literal' ),
                                                                                                 bless( {
                                                                                                          'subrule' => 'fullselect',
                                                                                                          'matchrule' => 0,
                                                                                                          'implicit' => undef,
                                                                                                          'argcode' => undef,
                                                                                                          'lookahead' => 0,
                                                                                                          'line' => 478
                                                                                                        }, 'Parse::RecDescent::Subrule' ),
                                                                                                 bless( {
                                                                                                          'pattern' => ')',
                                                                                                          'hashname' => '__STRING2__',
                                                                                                          'description' => '\')\'',
                                                                                                          'lookahead' => 0,
                                                                                                          'line' => 478
                                                                                                        }, 'Parse::RecDescent::Literal' )
                                                                                               ],
                                                                                    'line' => undef
                                                                                  }, 'Parse::RecDescent::Production' )
                                                                         ],
                                                              'name' => 'scalar_fullselect',
                                                              'vars' => '',
                                                              'line' => 478
                                                            }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule_options' => bless( {
                                                                                           'impcount' => 0,
                                                                                           'calls' => [],
                                                                                           'changed' => 0,
                                                                                           'opcount' => 0,
                                                                                           'prods' => [
                                                                                                        bless( {
                                                                                                                 'number' => '0',
                                                                                                                 'strcount' => 0,
                                                                                                                 'dircount' => 0,
                                                                                                                 'uncommit' => undef,
                                                                                                                 'error' => undef,
                                                                                                                 'patcount' => 1,
                                                                                                                 'actcount' => 0,
                                                                                                                 'items' => [
                                                                                                                              bless( {
                                                                                                                                       'pattern' => 'CASCADED',
                                                                                                                                       'hashname' => '__PATTERN1__',
                                                                                                                                       'description' => '/CASCADED/i',
                                                                                                                                       'lookahead' => 0,
                                                                                                                                       'rdelim' => '/',
                                                                                                                                       'line' => 628,
                                                                                                                                       'mod' => 'i',
                                                                                                                                       'ldelim' => '/'
                                                                                                                                     }, 'Parse::RecDescent::Token' )
                                                                                                                            ],
                                                                                                                 'line' => undef
                                                                                                               }, 'Parse::RecDescent::Production' ),
                                                                                                        bless( {
                                                                                                                 'number' => '1',
                                                                                                                 'strcount' => 0,
                                                                                                                 'dircount' => 0,
                                                                                                                 'uncommit' => undef,
                                                                                                                 'error' => undef,
                                                                                                                 'patcount' => 1,
                                                                                                                 'actcount' => 0,
                                                                                                                 'items' => [
                                                                                                                              bless( {
                                                                                                                                       'pattern' => 'LOCAL',
                                                                                                                                       'hashname' => '__PATTERN1__',
                                                                                                                                       'description' => '/LOCAL/i',
                                                                                                                                       'lookahead' => 0,
                                                                                                                                       'rdelim' => '/',
                                                                                                                                       'line' => 628,
                                                                                                                                       'mod' => 'i',
                                                                                                                                       'ldelim' => '/'
                                                                                                                                     }, 'Parse::RecDescent::Token' )
                                                                                                                            ],
                                                                                                                 'line' => 628
                                                                                                               }, 'Parse::RecDescent::Production' )
                                                                                                      ],
                                                                                           'name' => '_alternation_1_of_production_1_of_rule_options',
                                                                                           'vars' => '',
                                                                                           'line' => 628
                                                                                         }, 'Parse::RecDescent::Rule' ),
                              'func_args' => bless( {
                                                      'impcount' => 0,
                                                      'calls' => [
                                                                   'expression'
                                                                 ],
                                                      'changed' => 0,
                                                      'opcount' => 0,
                                                      'prods' => [
                                                                   bless( {
                                                                            'number' => '0',
                                                                            'strcount' => 0,
                                                                            'dircount' => 0,
                                                                            'uncommit' => undef,
                                                                            'error' => undef,
                                                                            'patcount' => 0,
                                                                            'actcount' => 0,
                                                                            'items' => [
                                                                                         bless( {
                                                                                                  'subrule' => 'expression',
                                                                                                  'matchrule' => 0,
                                                                                                  'implicit' => undef,
                                                                                                  'argcode' => undef,
                                                                                                  'lookahead' => 0,
                                                                                                  'line' => 330
                                                                                                }, 'Parse::RecDescent::Subrule' )
                                                                                       ],
                                                                            'line' => undef
                                                                          }, 'Parse::RecDescent::Production' )
                                                                 ],
                                                      'name' => 'func_args',
                                                      'vars' => '',
                                                      'line' => 330
                                                    }, 'Parse::RecDescent::Rule' ),
                              'trigger_name' => bless( {
                                                         'impcount' => 0,
                                                         'calls' => [
                                                                      'SCHEMA',
                                                                      'NAME'
                                                                    ],
                                                         'changed' => 0,
                                                         'opcount' => 0,
                                                         'prods' => [
                                                                      bless( {
                                                                               'number' => '0',
                                                                               'strcount' => 1,
                                                                               'dircount' => 0,
                                                                               'uncommit' => undef,
                                                                               'error' => undef,
                                                                               'patcount' => 0,
                                                                               'actcount' => 1,
                                                                               'items' => [
                                                                                            bless( {
                                                                                                     'subrule' => 'SCHEMA',
                                                                                                     'matchrule' => 0,
                                                                                                     'implicit' => undef,
                                                                                                     'argcode' => undef,
                                                                                                     'lookahead' => 0,
                                                                                                     'line' => 119
                                                                                                   }, 'Parse::RecDescent::Subrule' ),
                                                                                            bless( {
                                                                                                     'pattern' => '.',
                                                                                                     'hashname' => '__STRING1__',
                                                                                                     'description' => '\'.\'',
                                                                                                     'lookahead' => 0,
                                                                                                     'line' => 119
                                                                                                   }, 'Parse::RecDescent::Literal' ),
                                                                                            bless( {
                                                                                                     'subrule' => 'NAME',
                                                                                                     'matchrule' => 0,
                                                                                                     'implicit' => undef,
                                                                                                     'argcode' => undef,
                                                                                                     'lookahead' => 0,
                                                                                                     'line' => 119
                                                                                                   }, 'Parse::RecDescent::Subrule' ),
                                                                                            bless( {
                                                                                                     'hashname' => '__ACTION1__',
                                                                                                     'lookahead' => 0,
                                                                                                     'line' => 120,
                                                                                                     'code' => '{ $return = { schema => $item[1], name => $item[3] } }'
                                                                                                   }, 'Parse::RecDescent::Action' )
                                                                                          ],
                                                                               'line' => undef
                                                                             }, 'Parse::RecDescent::Production' ),
                                                                      bless( {
                                                                               'number' => '1',
                                                                               'strcount' => 0,
                                                                               'dircount' => 0,
                                                                               'uncommit' => undef,
                                                                               'error' => undef,
                                                                               'patcount' => 0,
                                                                               'actcount' => 1,
                                                                               'items' => [
                                                                                            bless( {
                                                                                                     'subrule' => 'NAME',
                                                                                                     'matchrule' => 0,
                                                                                                     'implicit' => undef,
                                                                                                     'argcode' => undef,
                                                                                                     'lookahead' => 0,
                                                                                                     'line' => 121
                                                                                                   }, 'Parse::RecDescent::Subrule' ),
                                                                                            bless( {
                                                                                                     'hashname' => '__ACTION1__',
                                                                                                     'lookahead' => 0,
                                                                                                     'line' => 122,
                                                                                                     'code' => '{ $return = { name => $item[1] } }'
                                                                                                   }, 'Parse::RecDescent::Action' )
                                                                                          ],
                                                                               'line' => 121
                                                                             }, 'Parse::RecDescent::Production' )
                                                                    ],
                                                         'name' => 'trigger_name',
                                                         'vars' => '',
                                                         'line' => 119
                                                       }, 'Parse::RecDescent::Rule' ),
                              '_alternation_2_of_production_1_of_rule_numbering_function' => bless( {
                                                                                                      'impcount' => 0,
                                                                                                      'calls' => [
                                                                                                                   'window_aggregation_group_clause'
                                                                                                                 ],
                                                                                                      'changed' => 0,
                                                                                                      'opcount' => 0,
                                                                                                      'prods' => [
                                                                                                                   bless( {
                                                                                                                            'number' => '0',
                                                                                                                            'strcount' => 0,
                                                                                                                            'dircount' => 0,
                                                                                                                            'uncommit' => undef,
                                                                                                                            'error' => undef,
                                                                                                                            'patcount' => 1,
                                                                                                                            'actcount' => 0,
                                                                                                                            'items' => [
                                                                                                                                         bless( {
                                                                                                                                                  'pattern' => 'RANGE\\s+BETWEEN\\s+UNBOUNDED\\s+PRECEDING\\s+AND\\s+UNBBOUNDED\\s+FOLLOWING',
                                                                                                                                                  'hashname' => '__PATTERN1__',
                                                                                                                                                  'description' => '/RANGE\\\\s+BETWEEN\\\\s+UNBOUNDED\\\\s+PRECEDING\\\\s+AND\\\\s+UNBBOUNDED\\\\s+FOLLOWING/i',
                                                                                                                                                  'lookahead' => 0,
                                                                                                                                                  'rdelim' => '/',
                                                                                                                                                  'line' => 626,
                                                                                                                                                  'mod' => 'i',
                                                                                                                                                  'ldelim' => '/'
                                                                                                                                                }, 'Parse::RecDescent::Token' )
                                                                                                                                       ],
                                                                                                                            'line' => undef
                                                                                                                          }, 'Parse::RecDescent::Production' ),
                                                                                                                   bless( {
                                                                                                                            'number' => '1',
                                                                                                                            'strcount' => 0,
                                                                                                                            'dircount' => 0,
                                                                                                                            'uncommit' => undef,
                                                                                                                            'error' => undef,
                                                                                                                            'patcount' => 0,
                                                                                                                            'actcount' => 0,
                                                                                                                            'items' => [
                                                                                                                                         bless( {
                                                                                                                                                  'subrule' => 'window_aggregation_group_clause',
                                                                                                                                                  'matchrule' => 0,
                                                                                                                                                  'implicit' => undef,
                                                                                                                                                  'argcode' => undef,
                                                                                                                                                  'lookahead' => 0,
                                                                                                                                                  'line' => 627
                                                                                                                                                }, 'Parse::RecDescent::Subrule' )
                                                                                                                                       ],
                                                                                                                            'line' => 627
                                                                                                                          }, 'Parse::RecDescent::Production' )
                                                                                                                 ],
                                                                                                      'name' => '_alternation_2_of_production_1_of_rule_numbering_function',
                                                                                                      'vars' => '',
                                                                                                      'line' => 626
                                                                                                    }, 'Parse::RecDescent::Rule' ),
                              'method_name' => bless( {
                                                        'impcount' => 0,
                                                        'calls' => [
                                                                     'NAME'
                                                                   ],
                                                        'changed' => 0,
                                                        'opcount' => 0,
                                                        'prods' => [
                                                                     bless( {
                                                                              'number' => '0',
                                                                              'strcount' => 0,
                                                                              'dircount' => 0,
                                                                              'uncommit' => undef,
                                                                              'error' => undef,
                                                                              'patcount' => 0,
                                                                              'actcount' => 1,
                                                                              'items' => [
                                                                                           bless( {
                                                                                                    'subrule' => 'NAME',
                                                                                                    'matchrule' => 0,
                                                                                                    'implicit' => undef,
                                                                                                    'argcode' => undef,
                                                                                                    'lookahead' => 0,
                                                                                                    'line' => 602
                                                                                                  }, 'Parse::RecDescent::Subrule' ),
                                                                                           bless( {
                                                                                                    'hashname' => '__ACTION1__',
                                                                                                    'lookahead' => 0,
                                                                                                    'line' => 603,
                                                                                                    'code' => '{ # must be a method of subject_expression
}'
                                                                                                  }, 'Parse::RecDescent::Action' )
                                                                                         ],
                                                                              'line' => undef
                                                                            }, 'Parse::RecDescent::Production' )
                                                                   ],
                                                        'name' => 'method_name',
                                                        'vars' => '',
                                                        'line' => 602
                                                      }, 'Parse::RecDescent::Rule' ),
                              'quantified_p' => bless( {
                                                         'impcount' => 0,
                                                         'calls' => [
                                                                      'expression1',
                                                                      'fullselect'
                                                                    ],
                                                         'changed' => 0,
                                                         'opcount' => 0,
                                                         'prods' => [
                                                                      bless( {
                                                                               'number' => '0',
                                                                               'strcount' => 2,
                                                                               'dircount' => 0,
                                                                               'uncommit' => undef,
                                                                               'error' => undef,
                                                                               'patcount' => 2,
                                                                               'actcount' => 0,
                                                                               'items' => [
                                                                                            bless( {
                                                                                                     'subrule' => 'expression1',
                                                                                                     'matchrule' => 0,
                                                                                                     'implicit' => undef,
                                                                                                     'argcode' => undef,
                                                                                                     'lookahead' => 0,
                                                                                                     'line' => 626
                                                                                                   }, 'Parse::RecDescent::Subrule' ),
                                                                                            bless( {
                                                                                                     'pattern' => '(=|<>|<|>|<=|=>|\\^=|\\^<|\\^>|\\!=)',
                                                                                                     'hashname' => '__PATTERN1__',
                                                                                                     'description' => '/(=|<>|<|>|<=|=>|\\\\^=|\\\\^<|\\\\^>|\\\\!=)/',
                                                                                                     'lookahead' => 0,
                                                                                                     'rdelim' => '/',
                                                                                                     'line' => 626,
                                                                                                     'mod' => '',
                                                                                                     'ldelim' => '/'
                                                                                                   }, 'Parse::RecDescent::Token' ),
                                                                                            bless( {
                                                                                                     'pattern' => 'SOME|ANY|ALL',
                                                                                                     'hashname' => '__PATTERN2__',
                                                                                                     'description' => '/SOME|ANY|ALL/i',
                                                                                                     'lookahead' => 0,
                                                                                                     'rdelim' => '/',
                                                                                                     'line' => 626,
                                                                                                     'mod' => 'i',
                                                                                                     'ldelim' => '/'
                                                                                                   }, 'Parse::RecDescent::Token' ),
                                                                                            bless( {
                                                                                                     'pattern' => '(',
                                                                                                     'hashname' => '__STRING1__',
                                                                                                     'description' => '\'(\'',
                                                                                                     'lookahead' => 0,
                                                                                                     'line' => 626
                                                                                                   }, 'Parse::RecDescent::Literal' ),
                                                                                            bless( {
                                                                                                     'subrule' => 'fullselect',
                                                                                                     'matchrule' => 0,
                                                                                                     'implicit' => undef,
                                                                                                     'argcode' => undef,
                                                                                                     'lookahead' => 0,
                                                                                                     'line' => 626
                                                                                                   }, 'Parse::RecDescent::Subrule' ),
                                                                                            bless( {
                                                                                                     'pattern' => ')',
                                                                                                     'hashname' => '__STRING2__',
                                                                                                     'description' => '\')\'',
                                                                                                     'lookahead' => 0,
                                                                                                     'line' => 626
                                                                                                   }, 'Parse::RecDescent::Literal' )
                                                                                          ],
                                                                               'line' => undef
                                                                             }, 'Parse::RecDescent::Production' )
                                                                    ],
                                                         'name' => 'quantified_p',
                                                         'vars' => '',
                                                         'line' => 626
                                                       }, 'Parse::RecDescent::Rule' ),
                              'common_table_expression' => bless( {
                                                                    'impcount' => 0,
                                                                    'calls' => [
                                                                                 'table_name',
                                                                                 'column_list',
                                                                                 'get_bracketed',
                                                                                 'fullselect'
                                                                               ],
                                                                    'changed' => 0,
                                                                    'opcount' => 0,
                                                                    'prods' => [
                                                                                 bless( {
                                                                                          'number' => '0',
                                                                                          'strcount' => 0,
                                                                                          'dircount' => 0,
                                                                                          'uncommit' => undef,
                                                                                          'error' => undef,
                                                                                          'patcount' => 1,
                                                                                          'actcount' => 1,
                                                                                          'items' => [
                                                                                                       bless( {
                                                                                                                'subrule' => 'table_name',
                                                                                                                'matchrule' => 0,
                                                                                                                'implicit' => undef,
                                                                                                                'argcode' => undef,
                                                                                                                'lookahead' => 0,
                                                                                                                'line' => 162
                                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                                       bless( {
                                                                                                                'subrule' => 'column_list',
                                                                                                                'matchrule' => 0,
                                                                                                                'implicit' => undef,
                                                                                                                'argcode' => undef,
                                                                                                                'lookahead' => 0,
                                                                                                                'line' => 162
                                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                                       bless( {
                                                                                                                'pattern' => 'AS',
                                                                                                                'hashname' => '__PATTERN1__',
                                                                                                                'description' => '/AS/i',
                                                                                                                'lookahead' => 0,
                                                                                                                'rdelim' => '/',
                                                                                                                'line' => 162,
                                                                                                                'mod' => 'i',
                                                                                                                'ldelim' => '/'
                                                                                                              }, 'Parse::RecDescent::Token' ),
                                                                                                       bless( {
                                                                                                                'subrule' => 'get_bracketed',
                                                                                                                'matchrule' => 0,
                                                                                                                'implicit' => undef,
                                                                                                                'argcode' => undef,
                                                                                                                'lookahead' => 0,
                                                                                                                'line' => 162
                                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                                       bless( {
                                                                                                                'hashname' => '__ACTION1__',
                                                                                                                'lookahead' => 0,
                                                                                                                'line' => 163,
                                                                                                                'code' => '{
    $return = { name  => $item{table_name}{name},
                query => $item[4]
                };
}'
                                                                                                              }, 'Parse::RecDescent::Action' )
                                                                                                     ],
                                                                                          'line' => undef
                                                                                        }, 'Parse::RecDescent::Production' ),
                                                                                 bless( {
                                                                                          'number' => '1',
                                                                                          'strcount' => 2,
                                                                                          'dircount' => 0,
                                                                                          'uncommit' => undef,
                                                                                          'error' => undef,
                                                                                          'patcount' => 1,
                                                                                          'actcount' => 0,
                                                                                          'items' => [
                                                                                                       bless( {
                                                                                                                'subrule' => 'table_name',
                                                                                                                'matchrule' => 0,
                                                                                                                'implicit' => undef,
                                                                                                                'argcode' => undef,
                                                                                                                'lookahead' => 0,
                                                                                                                'line' => 174
                                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                                       bless( {
                                                                                                                'subrule' => 'column_list',
                                                                                                                'matchrule' => 0,
                                                                                                                'implicit' => undef,
                                                                                                                'argcode' => undef,
                                                                                                                'lookahead' => 0,
                                                                                                                'line' => 174
                                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                                       bless( {
                                                                                                                'pattern' => 'AS',
                                                                                                                'hashname' => '__PATTERN1__',
                                                                                                                'description' => '/AS/i',
                                                                                                                'lookahead' => 0,
                                                                                                                'rdelim' => '/',
                                                                                                                'line' => 174,
                                                                                                                'mod' => 'i',
                                                                                                                'ldelim' => '/'
                                                                                                              }, 'Parse::RecDescent::Token' ),
                                                                                                       bless( {
                                                                                                                'pattern' => '(',
                                                                                                                'hashname' => '__STRING1__',
                                                                                                                'description' => '\'(\'',
                                                                                                                'lookahead' => 0,
                                                                                                                'line' => 174
                                                                                                              }, 'Parse::RecDescent::Literal' ),
                                                                                                       bless( {
                                                                                                                'subrule' => 'fullselect',
                                                                                                                'matchrule' => 0,
                                                                                                                'implicit' => undef,
                                                                                                                'argcode' => undef,
                                                                                                                'lookahead' => 0,
                                                                                                                'line' => 174
                                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                                       bless( {
                                                                                                                'pattern' => ')',
                                                                                                                'hashname' => '__STRING2__',
                                                                                                                'description' => '\')\'',
                                                                                                                'lookahead' => 0,
                                                                                                                'line' => 174
                                                                                                              }, 'Parse::RecDescent::Literal' )
                                                                                                     ],
                                                                                          'line' => undef
                                                                                        }, 'Parse::RecDescent::Production' )
                                                                               ],
                                                                    'name' => 'common_table_expression',
                                                                    'vars' => '',
                                                                    'line' => 160
                                                                  }, 'Parse::RecDescent::Rule' ),
                              'after' => bless( {
                                                  'impcount' => 0,
                                                  'calls' => [],
                                                  'changed' => 0,
                                                  'opcount' => 0,
                                                  'prods' => [
                                                               bless( {
                                                                        'number' => '0',
                                                                        'strcount' => 0,
                                                                        'dircount' => 0,
                                                                        'uncommit' => undef,
                                                                        'error' => undef,
                                                                        'patcount' => 1,
                                                                        'actcount' => 0,
                                                                        'items' => [
                                                                                     bless( {
                                                                                              'pattern' => 'AFTER',
                                                                                              'hashname' => '__PATTERN1__',
                                                                                              'description' => '/AFTER/i',
                                                                                              'lookahead' => 0,
                                                                                              'rdelim' => '/',
                                                                                              'line' => 270,
                                                                                              'mod' => 'i',
                                                                                              'ldelim' => '/'
                                                                                            }, 'Parse::RecDescent::Token' )
                                                                                   ],
                                                                        'line' => undef
                                                                      }, 'Parse::RecDescent::Production' )
                                                             ],
                                                  'name' => 'after',
                                                  'vars' => '',
                                                  'line' => 270
                                                }, 'Parse::RecDescent::Rule' ),
                              'predicate' => bless( {
                                                      'impcount' => 0,
                                                      'calls' => [
                                                                   'basic_p',
                                                                   'quantified_p',
                                                                   'between_p',
                                                                   'exists_p',
                                                                   'in_p',
                                                                   'like_p',
                                                                   'null_p',
                                                                   'type_p'
                                                                 ],
                                                      'changed' => 0,
                                                      'opcount' => 0,
                                                      'prods' => [
                                                                   bless( {
                                                                            'number' => '0',
                                                                            'strcount' => 0,
                                                                            'dircount' => 0,
                                                                            'uncommit' => undef,
                                                                            'error' => undef,
                                                                            'patcount' => 0,
                                                                            'actcount' => 0,
                                                                            'items' => [
                                                                                         bless( {
                                                                                                  'subrule' => 'basic_p',
                                                                                                  'matchrule' => 0,
                                                                                                  'implicit' => undef,
                                                                                                  'argcode' => undef,
                                                                                                  'lookahead' => 0,
                                                                                                  'line' => 622
                                                                                                }, 'Parse::RecDescent::Subrule' )
                                                                                       ],
                                                                            'line' => undef
                                                                          }, 'Parse::RecDescent::Production' ),
                                                                   bless( {
                                                                            'number' => '1',
                                                                            'strcount' => 0,
                                                                            'dircount' => 0,
                                                                            'uncommit' => undef,
                                                                            'error' => undef,
                                                                            'patcount' => 0,
                                                                            'actcount' => 0,
                                                                            'items' => [
                                                                                         bless( {
                                                                                                  'subrule' => 'quantified_p',
                                                                                                  'matchrule' => 0,
                                                                                                  'implicit' => undef,
                                                                                                  'argcode' => undef,
                                                                                                  'lookahead' => 0,
                                                                                                  'line' => 622
                                                                                                }, 'Parse::RecDescent::Subrule' )
                                                                                       ],
                                                                            'line' => 622
                                                                          }, 'Parse::RecDescent::Production' ),
                                                                   bless( {
                                                                            'number' => '2',
                                                                            'strcount' => 0,
                                                                            'dircount' => 0,
                                                                            'uncommit' => undef,
                                                                            'error' => undef,
                                                                            'patcount' => 0,
                                                                            'actcount' => 0,
                                                                            'items' => [
                                                                                         bless( {
                                                                                                  'subrule' => 'between_p',
                                                                                                  'matchrule' => 0,
                                                                                                  'implicit' => undef,
                                                                                                  'argcode' => undef,
                                                                                                  'lookahead' => 0,
                                                                                                  'line' => 622
                                                                                                }, 'Parse::RecDescent::Subrule' )
                                                                                       ],
                                                                            'line' => 622
                                                                          }, 'Parse::RecDescent::Production' ),
                                                                   bless( {
                                                                            'number' => '3',
                                                                            'strcount' => 0,
                                                                            'dircount' => 0,
                                                                            'uncommit' => undef,
                                                                            'error' => undef,
                                                                            'patcount' => 0,
                                                                            'actcount' => 0,
                                                                            'items' => [
                                                                                         bless( {
                                                                                                  'subrule' => 'exists_p',
                                                                                                  'matchrule' => 0,
                                                                                                  'implicit' => undef,
                                                                                                  'argcode' => undef,
                                                                                                  'lookahead' => 0,
                                                                                                  'line' => 622
                                                                                                }, 'Parse::RecDescent::Subrule' )
                                                                                       ],
                                                                            'line' => 622
                                                                          }, 'Parse::RecDescent::Production' ),
                                                                   bless( {
                                                                            'number' => '4',
                                                                            'strcount' => 0,
                                                                            'dircount' => 0,
                                                                            'uncommit' => undef,
                                                                            'error' => undef,
                                                                            'patcount' => 0,
                                                                            'actcount' => 0,
                                                                            'items' => [
                                                                                         bless( {
                                                                                                  'subrule' => 'in_p',
                                                                                                  'matchrule' => 0,
                                                                                                  'implicit' => undef,
                                                                                                  'argcode' => undef,
                                                                                                  'lookahead' => 0,
                                                                                                  'line' => 622
                                                                                                }, 'Parse::RecDescent::Subrule' )
                                                                                       ],
                                                                            'line' => 622
                                                                          }, 'Parse::RecDescent::Production' ),
                                                                   bless( {
                                                                            'number' => '5',
                                                                            'strcount' => 0,
                                                                            'dircount' => 0,
                                                                            'uncommit' => undef,
                                                                            'error' => undef,
                                                                            'patcount' => 0,
                                                                            'actcount' => 0,
                                                                            'items' => [
                                                                                         bless( {
                                                                                                  'subrule' => 'like_p',
                                                                                                  'matchrule' => 0,
                                                                                                  'implicit' => undef,
                                                                                                  'argcode' => undef,
                                                                                                  'lookahead' => 0,
                                                                                                  'line' => 622
                                                                                                }, 'Parse::RecDescent::Subrule' )
                                                                                       ],
                                                                            'line' => 622
                                                                          }, 'Parse::RecDescent::Production' ),
                                                                   bless( {
                                                                            'number' => '6',
                                                                            'strcount' => 0,
                                                                            'dircount' => 0,
                                                                            'uncommit' => undef,
                                                                            'error' => undef,
                                                                            'patcount' => 0,
                                                                            'actcount' => 0,
                                                                            'items' => [
                                                                                         bless( {
                                                                                                  'subrule' => 'null_p',
                                                                                                  'matchrule' => 0,
                                                                                                  'implicit' => undef,
                                                                                                  'argcode' => undef,
                                                                                                  'lookahead' => 0,
                                                                                                  'line' => 622
                                                                                                }, 'Parse::RecDescent::Subrule' )
                                                                                       ],
                                                                            'line' => 622
                                                                          }, 'Parse::RecDescent::Production' ),
                                                                   bless( {
                                                                            'number' => '7',
                                                                            'strcount' => 0,
                                                                            'dircount' => 0,
                                                                            'uncommit' => undef,
                                                                            'error' => undef,
                                                                            'patcount' => 0,
                                                                            'actcount' => 0,
                                                                            'items' => [
                                                                                         bless( {
                                                                                                  'subrule' => 'type_p',
                                                                                                  'matchrule' => 0,
                                                                                                  'implicit' => undef,
                                                                                                  'argcode' => undef,
                                                                                                  'lookahead' => 0,
                                                                                                  'line' => 622
                                                                                                }, 'Parse::RecDescent::Subrule' )
                                                                                       ],
                                                                            'line' => 622
                                                                          }, 'Parse::RecDescent::Production' )
                                                                 ],
                                                      'name' => 'predicate',
                                                      'vars' => '',
                                                      'line' => 622
                                                    }, 'Parse::RecDescent::Rule' ),
                              'column_name' => bless( {
                                                        'impcount' => 0,
                                                        'calls' => [
                                                                     'NAME'
                                                                   ],
                                                        'changed' => 0,
                                                        'opcount' => 0,
                                                        'prods' => [
                                                                     bless( {
                                                                              'number' => '0',
                                                                              'strcount' => 0,
                                                                              'dircount' => 0,
                                                                              'uncommit' => undef,
                                                                              'error' => undef,
                                                                              'patcount' => 0,
                                                                              'actcount' => 0,
                                                                              'items' => [
                                                                                           bless( {
                                                                                                    'subrule' => 'NAME',
                                                                                                    'matchrule' => 0,
                                                                                                    'implicit' => undef,
                                                                                                    'argcode' => undef,
                                                                                                    'lookahead' => 0,
                                                                                                    'line' => 134
                                                                                                  }, 'Parse::RecDescent::Subrule' )
                                                                                         ],
                                                                              'line' => undef
                                                                            }, 'Parse::RecDescent::Production' )
                                                                   ],
                                                        'name' => 'column_name',
                                                        'vars' => '',
                                                        'line' => 134
                                                      }, 'Parse::RecDescent::Rule' ),
                              'method_invocation' => bless( {
                                                              'impcount' => 1,
                                                              'calls' => [
                                                                           'subject_expression',
                                                                           'method_name',
                                                                           '_alternation_1_of_production_1_of_rule_method_invocation'
                                                                         ],
                                                              'changed' => 0,
                                                              'opcount' => 0,
                                                              'prods' => [
                                                                           bless( {
                                                                                    'number' => '0',
                                                                                    'strcount' => 1,
                                                                                    'dircount' => 0,
                                                                                    'uncommit' => undef,
                                                                                    'error' => undef,
                                                                                    'patcount' => 0,
                                                                                    'actcount' => 0,
                                                                                    'items' => [
                                                                                                 bless( {
                                                                                                          'subrule' => 'subject_expression',
                                                                                                          'matchrule' => 0,
                                                                                                          'implicit' => undef,
                                                                                                          'argcode' => undef,
                                                                                                          'lookahead' => 0,
                                                                                                          'line' => 593
                                                                                                        }, 'Parse::RecDescent::Subrule' ),
                                                                                                 bless( {
                                                                                                          'pattern' => '..',
                                                                                                          'hashname' => '__STRING1__',
                                                                                                          'description' => '\'..\'',
                                                                                                          'lookahead' => 0,
                                                                                                          'line' => 593
                                                                                                        }, 'Parse::RecDescent::Literal' ),
                                                                                                 bless( {
                                                                                                          'subrule' => 'method_name',
                                                                                                          'matchrule' => 0,
                                                                                                          'implicit' => undef,
                                                                                                          'argcode' => undef,
                                                                                                          'lookahead' => 0,
                                                                                                          'line' => 593
                                                                                                        }, 'Parse::RecDescent::Subrule' ),
                                                                                                 bless( {
                                                                                                          'subrule' => '_alternation_1_of_production_1_of_rule_method_invocation',
                                                                                                          'expected' => '\'(\'',
                                                                                                          'min' => 0,
                                                                                                          'argcode' => undef,
                                                                                                          'max' => 1,
                                                                                                          'matchrule' => 0,
                                                                                                          'repspec' => '?',
                                                                                                          'lookahead' => 0,
                                                                                                          'line' => 596
                                                                                                        }, 'Parse::RecDescent::Repetition' )
                                                                                               ],
                                                                                    'line' => undef
                                                                                  }, 'Parse::RecDescent::Production' )
                                                                         ],
                                                              'name' => 'method_invocation',
                                                              'vars' => '',
                                                              'line' => 593
                                                            }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule_dereference_operation' => bless( {
                                                                                                         'impcount' => 0,
                                                                                                         'calls' => [
                                                                                                                      'expression'
                                                                                                                    ],
                                                                                                         'changed' => 0,
                                                                                                         'opcount' => 0,
                                                                                                         'prods' => [
                                                                                                                      bless( {
                                                                                                                               'number' => '0',
                                                                                                                               'strcount' => 2,
                                                                                                                               'dircount' => 0,
                                                                                                                               'uncommit' => undef,
                                                                                                                               'error' => undef,
                                                                                                                               'patcount' => 0,
                                                                                                                               'actcount' => 0,
                                                                                                                               'items' => [
                                                                                                                                            bless( {
                                                                                                                                                     'pattern' => '(',
                                                                                                                                                     'hashname' => '__STRING1__',
                                                                                                                                                     'description' => '\'(\'',
                                                                                                                                                     'lookahead' => 0,
                                                                                                                                                     'line' => 628
                                                                                                                                                   }, 'Parse::RecDescent::Literal' ),
                                                                                                                                            bless( {
                                                                                                                                                     'subrule' => 'expression',
                                                                                                                                                     'expected' => undef,
                                                                                                                                                     'min' => 1,
                                                                                                                                                     'argcode' => undef,
                                                                                                                                                     'max' => 100000000,
                                                                                                                                                     'matchrule' => 0,
                                                                                                                                                     'repspec' => 's',
                                                                                                                                                     'lookahead' => 0,
                                                                                                                                                     'line' => 628
                                                                                                                                                   }, 'Parse::RecDescent::Repetition' ),
                                                                                                                                            bless( {
                                                                                                                                                     'pattern' => ')',
                                                                                                                                                     'hashname' => '__STRING2__',
                                                                                                                                                     'description' => '\')\'',
                                                                                                                                                     'lookahead' => 0,
                                                                                                                                                     'line' => 628
                                                                                                                                                   }, 'Parse::RecDescent::Literal' )
                                                                                                                                          ],
                                                                                                                               'line' => undef
                                                                                                                             }, 'Parse::RecDescent::Production' )
                                                                                                                    ],
                                                                                                         'name' => '_alternation_1_of_production_1_of_rule_dereference_operation',
                                                                                                         'vars' => '',
                                                                                                         'line' => 628
                                                                                                       }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule_searched_when_clause' => bless( {
                                                                                                        'impcount' => 1,
                                                                                                        'calls' => [
                                                                                                                     'search_condition',
                                                                                                                     '_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_searched_when_clause'
                                                                                                                   ],
                                                                                                        'changed' => 0,
                                                                                                        'opcount' => 0,
                                                                                                        'prods' => [
                                                                                                                     bless( {
                                                                                                                              'number' => '0',
                                                                                                                              'strcount' => 0,
                                                                                                                              'dircount' => 0,
                                                                                                                              'uncommit' => undef,
                                                                                                                              'error' => undef,
                                                                                                                              'patcount' => 2,
                                                                                                                              'actcount' => 0,
                                                                                                                              'items' => [
                                                                                                                                           bless( {
                                                                                                                                                    'pattern' => 'WHEN',
                                                                                                                                                    'hashname' => '__PATTERN1__',
                                                                                                                                                    'description' => '/WHEN/i',
                                                                                                                                                    'lookahead' => 0,
                                                                                                                                                    'rdelim' => '/',
                                                                                                                                                    'line' => 624,
                                                                                                                                                    'mod' => 'i',
                                                                                                                                                    'ldelim' => '/'
                                                                                                                                                  }, 'Parse::RecDescent::Token' ),
                                                                                                                                           bless( {
                                                                                                                                                    'subrule' => 'search_condition',
                                                                                                                                                    'matchrule' => 0,
                                                                                                                                                    'implicit' => undef,
                                                                                                                                                    'argcode' => undef,
                                                                                                                                                    'lookahead' => 0,
                                                                                                                                                    'line' => 624
                                                                                                                                                  }, 'Parse::RecDescent::Subrule' ),
                                                                                                                                           bless( {
                                                                                                                                                    'pattern' => 'THEN',
                                                                                                                                                    'hashname' => '__PATTERN2__',
                                                                                                                                                    'description' => '/THEN/i',
                                                                                                                                                    'lookahead' => 0,
                                                                                                                                                    'rdelim' => '/',
                                                                                                                                                    'line' => 624,
                                                                                                                                                    'mod' => 'i',
                                                                                                                                                    'ldelim' => '/'
                                                                                                                                                  }, 'Parse::RecDescent::Token' ),
                                                                                                                                           bless( {
                                                                                                                                                    'subrule' => '_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_searched_when_clause',
                                                                                                                                                    'matchrule' => 0,
                                                                                                                                                    'implicit' => 'result_expression, or /NULL/i',
                                                                                                                                                    'argcode' => undef,
                                                                                                                                                    'lookahead' => 0,
                                                                                                                                                    'line' => 627
                                                                                                                                                  }, 'Parse::RecDescent::Subrule' )
                                                                                                                                         ],
                                                                                                                              'line' => undef
                                                                                                                            }, 'Parse::RecDescent::Production' )
                                                                                                                   ],
                                                                                                        'name' => '_alternation_1_of_production_1_of_rule_searched_when_clause',
                                                                                                        'vars' => '',
                                                                                                        'line' => 624
                                                                                                      }, 'Parse::RecDescent::Rule' ),
                              'group_bound2' => bless( {
                                                         'impcount' => 0,
                                                         'calls' => [
                                                                      'unsigned_constant'
                                                                    ],
                                                         'changed' => 0,
                                                         'opcount' => 0,
                                                         'prods' => [
                                                                      bless( {
                                                                               'number' => '0',
                                                                               'strcount' => 0,
                                                                               'dircount' => 0,
                                                                               'uncommit' => undef,
                                                                               'error' => undef,
                                                                               'patcount' => 1,
                                                                               'actcount' => 0,
                                                                               'items' => [
                                                                                            bless( {
                                                                                                     'pattern' => 'UNBOUNDED\\s+PRECEDING',
                                                                                                     'hashname' => '__PATTERN1__',
                                                                                                     'description' => '/UNBOUNDED\\\\s+PRECEDING/i',
                                                                                                     'lookahead' => 0,
                                                                                                     'rdelim' => '/',
                                                                                                     'line' => 585,
                                                                                                     'mod' => 'i',
                                                                                                     'ldelim' => '/'
                                                                                                   }, 'Parse::RecDescent::Token' )
                                                                                          ],
                                                                               'line' => undef
                                                                             }, 'Parse::RecDescent::Production' ),
                                                                      bless( {
                                                                               'number' => '1',
                                                                               'strcount' => 0,
                                                                               'dircount' => 0,
                                                                               'uncommit' => undef,
                                                                               'error' => undef,
                                                                               'patcount' => 1,
                                                                               'actcount' => 0,
                                                                               'items' => [
                                                                                            bless( {
                                                                                                     'subrule' => 'unsigned_constant',
                                                                                                     'matchrule' => 0,
                                                                                                     'implicit' => undef,
                                                                                                     'argcode' => undef,
                                                                                                     'lookahead' => 0,
                                                                                                     'line' => 586
                                                                                                   }, 'Parse::RecDescent::Subrule' ),
                                                                                            bless( {
                                                                                                     'pattern' => 'PRECEDING',
                                                                                                     'hashname' => '__PATTERN1__',
                                                                                                     'description' => '/PRECEDING/i',
                                                                                                     'lookahead' => 0,
                                                                                                     'rdelim' => '/',
                                                                                                     'line' => 586,
                                                                                                     'mod' => 'i',
                                                                                                     'ldelim' => '/'
                                                                                                   }, 'Parse::RecDescent::Token' )
                                                                                          ],
                                                                               'line' => 586
                                                                             }, 'Parse::RecDescent::Production' ),
                                                                      bless( {
                                                                               'number' => '2',
                                                                               'strcount' => 0,
                                                                               'dircount' => 0,
                                                                               'uncommit' => undef,
                                                                               'error' => undef,
                                                                               'patcount' => 1,
                                                                               'actcount' => 0,
                                                                               'items' => [
                                                                                            bless( {
                                                                                                     'subrule' => 'unsigned_constant',
                                                                                                     'matchrule' => 0,
                                                                                                     'implicit' => undef,
                                                                                                     'argcode' => undef,
                                                                                                     'lookahead' => 0,
                                                                                                     'line' => 587
                                                                                                   }, 'Parse::RecDescent::Subrule' ),
                                                                                            bless( {
                                                                                                     'pattern' => 'FOLLOWING',
                                                                                                     'hashname' => '__PATTERN1__',
                                                                                                     'description' => '/FOLLOWING/i',
                                                                                                     'lookahead' => 0,
                                                                                                     'rdelim' => '/',
                                                                                                     'line' => 587,
                                                                                                     'mod' => 'i',
                                                                                                     'ldelim' => '/'
                                                                                                   }, 'Parse::RecDescent::Token' )
                                                                                          ],
                                                                               'line' => 587
                                                                             }, 'Parse::RecDescent::Production' ),
                                                                      bless( {
                                                                               'number' => '3',
                                                                               'strcount' => 0,
                                                                               'dircount' => 0,
                                                                               'uncommit' => undef,
                                                                               'error' => undef,
                                                                               'patcount' => 1,
                                                                               'actcount' => 0,
                                                                               'items' => [
                                                                                            bless( {
                                                                                                     'pattern' => 'CURRENT\\s+ROW',
                                                                                                     'hashname' => '__PATTERN1__',
                                                                                                     'description' => '/CURRENT\\\\s+ROW/i',
                                                                                                     'lookahead' => 0,
                                                                                                     'rdelim' => '/',
                                                                                                     'line' => 588,
                                                                                                     'mod' => 'i',
                                                                                                     'ldelim' => '/'
                                                                                                   }, 'Parse::RecDescent::Token' )
                                                                                          ],
                                                                               'line' => 588
                                                                             }, 'Parse::RecDescent::Production' )
                                                                    ],
                                                         'name' => 'group_bound2',
                                                         'vars' => '',
                                                         'line' => 585
                                                       }, 'Parse::RecDescent::Rule' ),
                              'searched_when_clause' => bless( {
                                                                 'impcount' => 1,
                                                                 'calls' => [
                                                                              '_alternation_1_of_production_1_of_rule_searched_when_clause'
                                                                            ],
                                                                 'changed' => 0,
                                                                 'opcount' => 0,
                                                                 'prods' => [
                                                                              bless( {
                                                                                       'number' => '0',
                                                                                       'strcount' => 0,
                                                                                       'dircount' => 0,
                                                                                       'uncommit' => undef,
                                                                                       'error' => undef,
                                                                                       'patcount' => 0,
                                                                                       'actcount' => 0,
                                                                                       'items' => [
                                                                                                    bless( {
                                                                                                             'subrule' => '_alternation_1_of_production_1_of_rule_searched_when_clause',
                                                                                                             'expected' => '/WHEN/i',
                                                                                                             'min' => 1,
                                                                                                             'argcode' => undef,
                                                                                                             'max' => 100000000,
                                                                                                             'matchrule' => 0,
                                                                                                             'repspec' => 's',
                                                                                                             'lookahead' => 0,
                                                                                                             'line' => 507
                                                                                                           }, 'Parse::RecDescent::Repetition' )
                                                                                                  ],
                                                                                       'line' => undef
                                                                                     }, 'Parse::RecDescent::Production' )
                                                                            ],
                                                                 'name' => 'searched_when_clause',
                                                                 'vars' => '',
                                                                 'line' => 503
                                                               }, 'Parse::RecDescent::Rule' ),
                              'basic_p' => bless( {
                                                    'impcount' => 0,
                                                    'calls' => [
                                                                 'expression'
                                                               ],
                                                    'changed' => 0,
                                                    'opcount' => 0,
                                                    'prods' => [
                                                                 bless( {
                                                                          'number' => '0',
                                                                          'strcount' => 0,
                                                                          'dircount' => 0,
                                                                          'uncommit' => undef,
                                                                          'error' => undef,
                                                                          'patcount' => 1,
                                                                          'actcount' => 0,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'subrule' => 'expression',
                                                                                                'matchrule' => 0,
                                                                                                'implicit' => undef,
                                                                                                'argcode' => undef,
                                                                                                'lookahead' => 0,
                                                                                                'line' => 624
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'pattern' => '(=|<>|<|>|<=|=>|\\^=|\\^<|\\^>|\\!=)',
                                                                                                'hashname' => '__PATTERN1__',
                                                                                                'description' => '/(=|<>|<|>|<=|=>|\\\\^=|\\\\^<|\\\\^>|\\\\!=)/',
                                                                                                'lookahead' => 0,
                                                                                                'rdelim' => '/',
                                                                                                'line' => 624,
                                                                                                'mod' => '',
                                                                                                'ldelim' => '/'
                                                                                              }, 'Parse::RecDescent::Token' ),
                                                                                       bless( {
                                                                                                'subrule' => 'expression',
                                                                                                'matchrule' => 0,
                                                                                                'implicit' => undef,
                                                                                                'argcode' => undef,
                                                                                                'lookahead' => 0,
                                                                                                'line' => 624
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => undef
                                                                        }, 'Parse::RecDescent::Production' )
                                                               ],
                                                    'name' => 'basic_p',
                                                    'vars' => '',
                                                    'line' => 624
                                                  }, 'Parse::RecDescent::Rule' ),
                              'asc_option' => bless( {
                                                       'impcount' => 1,
                                                       'calls' => [
                                                                    '_alternation_1_of_production_1_of_rule_asc_option'
                                                                  ],
                                                       'changed' => 0,
                                                       'opcount' => 0,
                                                       'prods' => [
                                                                    bless( {
                                                                             'number' => '0',
                                                                             'strcount' => 0,
                                                                             'dircount' => 0,
                                                                             'uncommit' => undef,
                                                                             'error' => undef,
                                                                             'patcount' => 1,
                                                                             'actcount' => 0,
                                                                             'items' => [
                                                                                          bless( {
                                                                                                   'pattern' => 'ASC',
                                                                                                   'hashname' => '__PATTERN1__',
                                                                                                   'description' => '/ASC/i',
                                                                                                   'lookahead' => 0,
                                                                                                   'rdelim' => '/',
                                                                                                   'line' => 562,
                                                                                                   'mod' => 'i',
                                                                                                   'ldelim' => '/'
                                                                                                 }, 'Parse::RecDescent::Token' ),
                                                                                          bless( {
                                                                                                   'subrule' => '_alternation_1_of_production_1_of_rule_asc_option',
                                                                                                   'expected' => '/NULLS\\\\s+FIRST/i, or /NULLS\\\\s+LAST/i',
                                                                                                   'min' => 0,
                                                                                                   'argcode' => undef,
                                                                                                   'max' => 1,
                                                                                                   'matchrule' => 0,
                                                                                                   'repspec' => '?',
                                                                                                   'lookahead' => 0,
                                                                                                   'line' => 562
                                                                                                 }, 'Parse::RecDescent::Repetition' )
                                                                                        ],
                                                                             'line' => undef
                                                                           }, 'Parse::RecDescent::Production' )
                                                                  ],
                                                       'name' => 'asc_option',
                                                       'vars' => '',
                                                       'line' => 562
                                                     }, 'Parse::RecDescent::Rule' ),
                              'search_condition' => bless( {
                                                             'impcount' => 1,
                                                             'calls' => [
                                                                          '_alternation_1_of_production_2_of_rule_search_condition',
                                                                          'cond'
                                                                        ],
                                                             'changed' => 0,
                                                             'opcount' => 0,
                                                             'prods' => [
                                                                          bless( {
                                                                                   'number' => '0',
                                                                                   'strcount' => 0,
                                                                                   'dircount' => 0,
                                                                                   'uncommit' => undef,
                                                                                   'error' => undef,
                                                                                   'patcount' => 1,
                                                                                   'actcount' => 0,
                                                                                   'items' => [
                                                                                                bless( {
                                                                                                         'pattern' => '[^)]+',
                                                                                                         'hashname' => '__PATTERN1__',
                                                                                                         'description' => '/[^)]+/',
                                                                                                         'lookahead' => 0,
                                                                                                         'rdelim' => '/',
                                                                                                         'line' => 297,
                                                                                                         'mod' => '',
                                                                                                         'ldelim' => '/'
                                                                                                       }, 'Parse::RecDescent::Token' )
                                                                                              ],
                                                                                   'line' => undef
                                                                                 }, 'Parse::RecDescent::Production' ),
                                                                          bless( {
                                                                                   'number' => '1',
                                                                                   'strcount' => 0,
                                                                                   'dircount' => 0,
                                                                                   'uncommit' => undef,
                                                                                   'error' => undef,
                                                                                   'patcount' => 1,
                                                                                   'actcount' => 0,
                                                                                   'items' => [
                                                                                                bless( {
                                                                                                         'pattern' => 'NOT|',
                                                                                                         'hashname' => '__PATTERN1__',
                                                                                                         'description' => '/NOT|/i',
                                                                                                         'lookahead' => 0,
                                                                                                         'rdelim' => '/',
                                                                                                         'line' => 618,
                                                                                                         'mod' => 'i',
                                                                                                         'ldelim' => '/'
                                                                                                       }, 'Parse::RecDescent::Token' ),
                                                                                                bless( {
                                                                                                         'subrule' => '_alternation_1_of_production_2_of_rule_search_condition',
                                                                                                         'matchrule' => 0,
                                                                                                         'implicit' => 'predicate, or \'(\'',
                                                                                                         'argcode' => undef,
                                                                                                         'lookahead' => 0,
                                                                                                         'line' => 618
                                                                                                       }, 'Parse::RecDescent::Subrule' ),
                                                                                                bless( {
                                                                                                         'subrule' => 'cond',
                                                                                                         'expected' => undef,
                                                                                                         'min' => 0,
                                                                                                         'argcode' => undef,
                                                                                                         'max' => 100000000,
                                                                                                         'matchrule' => 0,
                                                                                                         'repspec' => 's?',
                                                                                                         'lookahead' => 0,
                                                                                                         'line' => 618
                                                                                                       }, 'Parse::RecDescent::Repetition' )
                                                                                              ],
                                                                                   'line' => undef
                                                                                 }, 'Parse::RecDescent::Production' )
                                                                        ],
                                                             'name' => 'search_condition',
                                                             'vars' => '',
                                                             'line' => 296
                                                           }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule_operator' => bless( {
                                                                                            'impcount' => 0,
                                                                                            'calls' => [],
                                                                                            'changed' => 0,
                                                                                            'opcount' => 0,
                                                                                            'prods' => [
                                                                                                         bless( {
                                                                                                                  'number' => '0',
                                                                                                                  'strcount' => 0,
                                                                                                                  'dircount' => 0,
                                                                                                                  'uncommit' => undef,
                                                                                                                  'error' => undef,
                                                                                                                  'patcount' => 1,
                                                                                                                  'actcount' => 0,
                                                                                                                  'items' => [
                                                                                                                               bless( {
                                                                                                                                        'pattern' => 'CONCAT',
                                                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                                                        'description' => '/CONCAT/i',
                                                                                                                                        'lookahead' => 0,
                                                                                                                                        'rdelim' => '/',
                                                                                                                                        'line' => 628,
                                                                                                                                        'mod' => 'i',
                                                                                                                                        'ldelim' => '/'
                                                                                                                                      }, 'Parse::RecDescent::Token' )
                                                                                                                             ],
                                                                                                                  'line' => undef
                                                                                                                }, 'Parse::RecDescent::Production' ),
                                                                                                         bless( {
                                                                                                                  'number' => '1',
                                                                                                                  'strcount' => 1,
                                                                                                                  'dircount' => 0,
                                                                                                                  'uncommit' => undef,
                                                                                                                  'error' => undef,
                                                                                                                  'patcount' => 0,
                                                                                                                  'actcount' => 0,
                                                                                                                  'items' => [
                                                                                                                               bless( {
                                                                                                                                        'pattern' => '||',
                                                                                                                                        'hashname' => '__STRING1__',
                                                                                                                                        'description' => '\'||\'',
                                                                                                                                        'lookahead' => 0,
                                                                                                                                        'line' => 628
                                                                                                                                      }, 'Parse::RecDescent::Literal' )
                                                                                                                             ],
                                                                                                                  'line' => 628
                                                                                                                }, 'Parse::RecDescent::Production' )
                                                                                                       ],
                                                                                            'name' => '_alternation_1_of_production_1_of_rule_operator',
                                                                                            'vars' => '',
                                                                                            'line' => 628
                                                                                          }, 'Parse::RecDescent::Rule' ),
                              'simple_when_clause' => bless( {
                                                               'impcount' => 1,
                                                               'calls' => [
                                                                            'expression',
                                                                            '_alternation_1_of_production_1_of_rule_simple_when_clause'
                                                                          ],
                                                               'changed' => 0,
                                                               'opcount' => 0,
                                                               'prods' => [
                                                                            bless( {
                                                                                     'number' => '0',
                                                                                     'strcount' => 0,
                                                                                     'dircount' => 0,
                                                                                     'uncommit' => undef,
                                                                                     'error' => undef,
                                                                                     'patcount' => 0,
                                                                                     'actcount' => 0,
                                                                                     'items' => [
                                                                                                  bless( {
                                                                                                           'subrule' => 'expression',
                                                                                                           'matchrule' => 0,
                                                                                                           'implicit' => undef,
                                                                                                           'argcode' => undef,
                                                                                                           'lookahead' => 0,
                                                                                                           'line' => 509
                                                                                                         }, 'Parse::RecDescent::Subrule' ),
                                                                                                  bless( {
                                                                                                           'subrule' => '_alternation_1_of_production_1_of_rule_simple_when_clause',
                                                                                                           'expected' => '/WHEN/i',
                                                                                                           'min' => 1,
                                                                                                           'argcode' => undef,
                                                                                                           'max' => 100000000,
                                                                                                           'matchrule' => 0,
                                                                                                           'repspec' => 's',
                                                                                                           'lookahead' => 0,
                                                                                                           'line' => 513
                                                                                                         }, 'Parse::RecDescent::Repetition' )
                                                                                                ],
                                                                                     'line' => undef
                                                                                   }, 'Parse::RecDescent::Production' )
                                                                          ],
                                                               'name' => 'simple_when_clause',
                                                               'vars' => '',
                                                               'line' => 509
                                                             }, 'Parse::RecDescent::Rule' ),
                              'INNER' => bless( {
                                                  'impcount' => 0,
                                                  'calls' => [],
                                                  'changed' => 0,
                                                  'opcount' => 0,
                                                  'prods' => [
                                                               bless( {
                                                                        'number' => '0',
                                                                        'strcount' => 0,
                                                                        'dircount' => 0,
                                                                        'uncommit' => undef,
                                                                        'error' => undef,
                                                                        'patcount' => 1,
                                                                        'actcount' => 0,
                                                                        'items' => [
                                                                                     bless( {
                                                                                              'pattern' => 'inner',
                                                                                              'hashname' => '__PATTERN1__',
                                                                                              'description' => '/inner/i',
                                                                                              'lookahead' => 0,
                                                                                              'rdelim' => '/',
                                                                                              'line' => 107,
                                                                                              'mod' => 'i',
                                                                                              'ldelim' => '/'
                                                                                            }, 'Parse::RecDescent::Token' )
                                                                                   ],
                                                                        'line' => undef
                                                                      }, 'Parse::RecDescent::Production' )
                                                             ],
                                                  'name' => 'INNER',
                                                  'vars' => '',
                                                  'line' => 107
                                                }, 'Parse::RecDescent::Rule' ),
                              'eofile' => bless( {
                                                   'impcount' => 0,
                                                   'calls' => [],
                                                   'changed' => 0,
                                                   'opcount' => 0,
                                                   'prods' => [
                                                                bless( {
                                                                         'number' => '0',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => '^\\Z',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/^\\\\Z/',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 20,
                                                                                               'mod' => '',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => undef
                                                                       }, 'Parse::RecDescent::Production' )
                                                              ],
                                                   'name' => 'eofile',
                                                   'vars' => '',
                                                   'line' => 20
                                                 }, 'Parse::RecDescent::Rule' ),
                              'cond' => bless( {
                                                 'impcount' => 2,
                                                 'calls' => [
                                                              '_alternation_1_of_production_1_of_rule_cond',
                                                              '_alternation_2_of_production_1_of_rule_cond'
                                                            ],
                                                 'changed' => 0,
                                                 'opcount' => 0,
                                                 'prods' => [
                                                              bless( {
                                                                       'number' => '0',
                                                                       'strcount' => 0,
                                                                       'dircount' => 0,
                                                                       'uncommit' => undef,
                                                                       'error' => undef,
                                                                       'patcount' => 1,
                                                                       'actcount' => 0,
                                                                       'items' => [
                                                                                    bless( {
                                                                                             'subrule' => '_alternation_1_of_production_1_of_rule_cond',
                                                                                             'matchrule' => 0,
                                                                                             'implicit' => '/AND/i, or /OR/i',
                                                                                             'argcode' => undef,
                                                                                             'lookahead' => 0,
                                                                                             'line' => 620
                                                                                           }, 'Parse::RecDescent::Subrule' ),
                                                                                    bless( {
                                                                                             'pattern' => 'NOT|',
                                                                                             'hashname' => '__PATTERN1__',
                                                                                             'description' => '/NOT|/i',
                                                                                             'lookahead' => 0,
                                                                                             'rdelim' => '/',
                                                                                             'line' => 620,
                                                                                             'mod' => 'i',
                                                                                             'ldelim' => '/'
                                                                                           }, 'Parse::RecDescent::Token' ),
                                                                                    bless( {
                                                                                             'subrule' => '_alternation_2_of_production_1_of_rule_cond',
                                                                                             'matchrule' => 0,
                                                                                             'implicit' => 'predicate, or \'(\'',
                                                                                             'argcode' => undef,
                                                                                             'lookahead' => 0,
                                                                                             'line' => 620
                                                                                           }, 'Parse::RecDescent::Subrule' )
                                                                                  ],
                                                                       'line' => undef
                                                                     }, 'Parse::RecDescent::Production' )
                                                            ],
                                                 'name' => 'cond',
                                                 'vars' => '',
                                                 'line' => 620
                                               }, 'Parse::RecDescent::Rule' ),
                              'ld_type' => bless( {
                                                    'impcount' => 0,
                                                    'calls' => [
                                                                 'function',
                                                                 'expression',
                                                                 'constant',
                                                                 'column_name',
                                                                 'host_variable'
                                                               ],
                                                    'changed' => 0,
                                                    'opcount' => 0,
                                                    'prods' => [
                                                                 bless( {
                                                                          'number' => '0',
                                                                          'strcount' => 0,
                                                                          'dircount' => 0,
                                                                          'uncommit' => undef,
                                                                          'error' => undef,
                                                                          'patcount' => 0,
                                                                          'actcount' => 0,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'subrule' => 'function',
                                                                                                'matchrule' => 0,
                                                                                                'implicit' => undef,
                                                                                                'argcode' => undef,
                                                                                                'lookahead' => 0,
                                                                                                'line' => 482
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => undef
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'number' => '1',
                                                                          'strcount' => 2,
                                                                          'dircount' => 0,
                                                                          'uncommit' => undef,
                                                                          'error' => undef,
                                                                          'patcount' => 0,
                                                                          'actcount' => 0,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'pattern' => '(',
                                                                                                'hashname' => '__STRING1__',
                                                                                                'description' => '\'(\'',
                                                                                                'lookahead' => 0,
                                                                                                'line' => 483
                                                                                              }, 'Parse::RecDescent::Literal' ),
                                                                                       bless( {
                                                                                                'subrule' => 'expression',
                                                                                                'matchrule' => 0,
                                                                                                'implicit' => undef,
                                                                                                'argcode' => undef,
                                                                                                'lookahead' => 0,
                                                                                                'line' => 483
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'pattern' => ')',
                                                                                                'hashname' => '__STRING2__',
                                                                                                'description' => '\')\'',
                                                                                                'lookahead' => 0,
                                                                                                'line' => 483
                                                                                              }, 'Parse::RecDescent::Literal' )
                                                                                     ],
                                                                          'line' => 483
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'number' => '2',
                                                                          'strcount' => 0,
                                                                          'dircount' => 0,
                                                                          'uncommit' => undef,
                                                                          'error' => undef,
                                                                          'patcount' => 0,
                                                                          'actcount' => 0,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'subrule' => 'constant',
                                                                                                'matchrule' => 0,
                                                                                                'implicit' => undef,
                                                                                                'argcode' => undef,
                                                                                                'lookahead' => 0,
                                                                                                'line' => 484
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 484
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'number' => '3',
                                                                          'strcount' => 0,
                                                                          'dircount' => 0,
                                                                          'uncommit' => undef,
                                                                          'error' => undef,
                                                                          'patcount' => 0,
                                                                          'actcount' => 0,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'subrule' => 'column_name',
                                                                                                'matchrule' => 0,
                                                                                                'implicit' => undef,
                                                                                                'argcode' => undef,
                                                                                                'lookahead' => 0,
                                                                                                'line' => 485
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 485
                                                                        }, 'Parse::RecDescent::Production' ),
                                                                 bless( {
                                                                          'number' => '4',
                                                                          'strcount' => 0,
                                                                          'dircount' => 0,
                                                                          'uncommit' => undef,
                                                                          'error' => undef,
                                                                          'patcount' => 0,
                                                                          'actcount' => 0,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'subrule' => 'host_variable',
                                                                                                'matchrule' => 0,
                                                                                                'implicit' => undef,
                                                                                                'argcode' => undef,
                                                                                                'lookahead' => 0,
                                                                                                'line' => 486
                                                                                              }, 'Parse::RecDescent::Subrule' )
                                                                                     ],
                                                                          'line' => 486
                                                                        }, 'Parse::RecDescent::Production' )
                                                               ],
                                                    'name' => 'ld_type',
                                                    'vars' => '',
                                                    'line' => 482
                                                  }, 'Parse::RecDescent::Rule' ),
                              'RIGHT' => bless( {
                                                  'impcount' => 0,
                                                  'calls' => [],
                                                  'changed' => 0,
                                                  'opcount' => 0,
                                                  'prods' => [
                                                               bless( {
                                                                        'number' => '0',
                                                                        'strcount' => 0,
                                                                        'dircount' => 0,
                                                                        'uncommit' => undef,
                                                                        'error' => undef,
                                                                        'patcount' => 1,
                                                                        'actcount' => 0,
                                                                        'items' => [
                                                                                     bless( {
                                                                                              'pattern' => 'right',
                                                                                              'hashname' => '__PATTERN1__',
                                                                                              'description' => '/right/i',
                                                                                              'lookahead' => 0,
                                                                                              'rdelim' => '/',
                                                                                              'line' => 111,
                                                                                              'mod' => 'i',
                                                                                              'ldelim' => '/'
                                                                                            }, 'Parse::RecDescent::Token' )
                                                                                   ],
                                                                        'line' => undef
                                                                      }, 'Parse::RecDescent::Production' )
                                                             ],
                                                  'name' => 'RIGHT',
                                                  'vars' => '',
                                                  'line' => 111
                                                }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule_method_invocation' => bless( {
                                                                                                     'impcount' => 0,
                                                                                                     'calls' => [
                                                                                                                  'expression'
                                                                                                                ],
                                                                                                     'changed' => 0,
                                                                                                     'opcount' => 0,
                                                                                                     'prods' => [
                                                                                                                  bless( {
                                                                                                                           'number' => '0',
                                                                                                                           'strcount' => 2,
                                                                                                                           'dircount' => 0,
                                                                                                                           'uncommit' => undef,
                                                                                                                           'error' => undef,
                                                                                                                           'patcount' => 0,
                                                                                                                           'actcount' => 0,
                                                                                                                           'items' => [
                                                                                                                                        bless( {
                                                                                                                                                 'pattern' => '(',
                                                                                                                                                 'hashname' => '__STRING1__',
                                                                                                                                                 'description' => '\'(\'',
                                                                                                                                                 'lookahead' => 0,
                                                                                                                                                 'line' => 626
                                                                                                                                               }, 'Parse::RecDescent::Literal' ),
                                                                                                                                        bless( {
                                                                                                                                                 'subrule' => 'expression',
                                                                                                                                                 'expected' => undef,
                                                                                                                                                 'min' => 1,
                                                                                                                                                 'argcode' => undef,
                                                                                                                                                 'max' => 100000000,
                                                                                                                                                 'matchrule' => 0,
                                                                                                                                                 'repspec' => 's',
                                                                                                                                                 'lookahead' => 0,
                                                                                                                                                 'line' => 626
                                                                                                                                               }, 'Parse::RecDescent::Repetition' ),
                                                                                                                                        bless( {
                                                                                                                                                 'pattern' => ')',
                                                                                                                                                 'hashname' => '__STRING2__',
                                                                                                                                                 'description' => '\')\'',
                                                                                                                                                 'lookahead' => 0,
                                                                                                                                                 'line' => 626
                                                                                                                                               }, 'Parse::RecDescent::Literal' )
                                                                                                                                      ],
                                                                                                                           'line' => undef
                                                                                                                         }, 'Parse::RecDescent::Production' )
                                                                                                                ],
                                                                                                     'name' => '_alternation_1_of_production_1_of_rule_method_invocation',
                                                                                                     'vars' => '',
                                                                                                     'line' => 626
                                                                                                   }, 'Parse::RecDescent::Rule' ),
                              'LEFT' => bless( {
                                                 'impcount' => 0,
                                                 'calls' => [],
                                                 'changed' => 0,
                                                 'opcount' => 0,
                                                 'prods' => [
                                                              bless( {
                                                                       'number' => '0',
                                                                       'strcount' => 0,
                                                                       'dircount' => 0,
                                                                       'uncommit' => undef,
                                                                       'error' => undef,
                                                                       'patcount' => 1,
                                                                       'actcount' => 0,
                                                                       'items' => [
                                                                                    bless( {
                                                                                             'pattern' => 'left',
                                                                                             'hashname' => '__PATTERN1__',
                                                                                             'description' => '/left/i',
                                                                                             'lookahead' => 0,
                                                                                             'rdelim' => '/',
                                                                                             'line' => 109,
                                                                                             'mod' => 'i',
                                                                                             'ldelim' => '/'
                                                                                           }, 'Parse::RecDescent::Token' )
                                                                                  ],
                                                                       'line' => undef
                                                                     }, 'Parse::RecDescent::Production' )
                                                            ],
                                                 'name' => 'LEFT',
                                                 'vars' => '',
                                                 'line' => 109
                                               }, 'Parse::RecDescent::Rule' ),
                              'table_name' => bless( {
                                                       'impcount' => 0,
                                                       'calls' => [
                                                                    'SCHEMA',
                                                                    'NAME'
                                                                  ],
                                                       'changed' => 0,
                                                       'opcount' => 0,
                                                       'prods' => [
                                                                    bless( {
                                                                             'number' => '0',
                                                                             'strcount' => 1,
                                                                             'dircount' => 0,
                                                                             'uncommit' => undef,
                                                                             'error' => undef,
                                                                             'patcount' => 0,
                                                                             'actcount' => 1,
                                                                             'items' => [
                                                                                          bless( {
                                                                                                   'subrule' => 'SCHEMA',
                                                                                                   'matchrule' => 0,
                                                                                                   'implicit' => undef,
                                                                                                   'argcode' => undef,
                                                                                                   'lookahead' => 0,
                                                                                                   'line' => 124
                                                                                                 }, 'Parse::RecDescent::Subrule' ),
                                                                                          bless( {
                                                                                                   'pattern' => '.',
                                                                                                   'hashname' => '__STRING1__',
                                                                                                   'description' => '\'.\'',
                                                                                                   'lookahead' => 0,
                                                                                                   'line' => 124
                                                                                                 }, 'Parse::RecDescent::Literal' ),
                                                                                          bless( {
                                                                                                   'subrule' => 'NAME',
                                                                                                   'matchrule' => 0,
                                                                                                   'implicit' => undef,
                                                                                                   'argcode' => undef,
                                                                                                   'lookahead' => 0,
                                                                                                   'line' => 124
                                                                                                 }, 'Parse::RecDescent::Subrule' ),
                                                                                          bless( {
                                                                                                   'hashname' => '__ACTION1__',
                                                                                                   'lookahead' => 0,
                                                                                                   'line' => 125,
                                                                                                   'code' => '{ $return = { schema => $item[1], name => $item[3] } }'
                                                                                                 }, 'Parse::RecDescent::Action' )
                                                                                        ],
                                                                             'line' => undef
                                                                           }, 'Parse::RecDescent::Production' ),
                                                                    bless( {
                                                                             'number' => '1',
                                                                             'strcount' => 0,
                                                                             'dircount' => 0,
                                                                             'uncommit' => undef,
                                                                             'error' => undef,
                                                                             'patcount' => 0,
                                                                             'actcount' => 1,
                                                                             'items' => [
                                                                                          bless( {
                                                                                                   'subrule' => 'NAME',
                                                                                                   'matchrule' => 0,
                                                                                                   'implicit' => undef,
                                                                                                   'argcode' => undef,
                                                                                                   'lookahead' => 0,
                                                                                                   'line' => 126
                                                                                                 }, 'Parse::RecDescent::Subrule' ),
                                                                                          bless( {
                                                                                                   'hashname' => '__ACTION1__',
                                                                                                   'lookahead' => 0,
                                                                                                   'line' => 127,
                                                                                                   'code' => '{ $return = { name => $item[1] } }'
                                                                                                 }, 'Parse::RecDescent::Action' )
                                                                                        ],
                                                                             'line' => 126
                                                                           }, 'Parse::RecDescent::Production' )
                                                                  ],
                                                       'name' => 'table_name',
                                                       'vars' => '',
                                                       'line' => 124
                                                     }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_53_of_rule_sysfun' => bless( {
                                                                                           'impcount' => 0,
                                                                                           'calls' => [],
                                                                                           'changed' => 0,
                                                                                           'opcount' => 0,
                                                                                           'prods' => [
                                                                                                        bless( {
                                                                                                                 'number' => '0',
                                                                                                                 'strcount' => 0,
                                                                                                                 'dircount' => 0,
                                                                                                                 'uncommit' => undef,
                                                                                                                 'error' => undef,
                                                                                                                 'patcount' => 1,
                                                                                                                 'actcount' => 0,
                                                                                                                 'items' => [
                                                                                                                              bless( {
                                                                                                                                       'pattern' => 'TRUNCATE',
                                                                                                                                       'hashname' => '__PATTERN1__',
                                                                                                                                       'description' => '/TRUNCATE/i',
                                                                                                                                       'lookahead' => 0,
                                                                                                                                       'rdelim' => '/',
                                                                                                                                       'line' => 628,
                                                                                                                                       'mod' => 'i',
                                                                                                                                       'ldelim' => '/'
                                                                                                                                     }, 'Parse::RecDescent::Token' )
                                                                                                                            ],
                                                                                                                 'line' => undef
                                                                                                               }, 'Parse::RecDescent::Production' ),
                                                                                                        bless( {
                                                                                                                 'number' => '1',
                                                                                                                 'strcount' => 0,
                                                                                                                 'dircount' => 0,
                                                                                                                 'uncommit' => undef,
                                                                                                                 'error' => undef,
                                                                                                                 'patcount' => 1,
                                                                                                                 'actcount' => 0,
                                                                                                                 'items' => [
                                                                                                                              bless( {
                                                                                                                                       'pattern' => 'TRUNC',
                                                                                                                                       'hashname' => '__PATTERN1__',
                                                                                                                                       'description' => '/TRUNC/i',
                                                                                                                                       'lookahead' => 0,
                                                                                                                                       'rdelim' => '/',
                                                                                                                                       'line' => 628,
                                                                                                                                       'mod' => 'i',
                                                                                                                                       'ldelim' => '/'
                                                                                                                                     }, 'Parse::RecDescent::Token' )
                                                                                                                            ],
                                                                                                                 'line' => 628
                                                                                                               }, 'Parse::RecDescent::Production' )
                                                                                                      ],
                                                                                           'name' => '_alternation_1_of_production_53_of_rule_sysfun',
                                                                                           'vars' => '',
                                                                                           'line' => 628
                                                                                         }, 'Parse::RecDescent::Rule' ),
                              'options' => bless( {
                                                    'impcount' => 1,
                                                    'calls' => [
                                                                 '_alternation_1_of_production_1_of_rule_options'
                                                               ],
                                                    'changed' => 0,
                                                    'opcount' => 0,
                                                    'prods' => [
                                                                 bless( {
                                                                          'number' => '0',
                                                                          'strcount' => 0,
                                                                          'dircount' => 0,
                                                                          'uncommit' => undef,
                                                                          'error' => undef,
                                                                          'patcount' => 2,
                                                                          'actcount' => 0,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'pattern' => 'WITH',
                                                                                                'hashname' => '__PATTERN1__',
                                                                                                'description' => '/WITH/i',
                                                                                                'lookahead' => 0,
                                                                                                'rdelim' => '/',
                                                                                                'line' => 150,
                                                                                                'mod' => 'i',
                                                                                                'ldelim' => '/'
                                                                                              }, 'Parse::RecDescent::Token' ),
                                                                                       bless( {
                                                                                                'subrule' => '_alternation_1_of_production_1_of_rule_options',
                                                                                                'matchrule' => 0,
                                                                                                'implicit' => '/CASCADED/i, or /LOCAL/i',
                                                                                                'argcode' => undef,
                                                                                                'lookahead' => 0,
                                                                                                'line' => 150
                                                                                              }, 'Parse::RecDescent::Subrule' ),
                                                                                       bless( {
                                                                                                'pattern' => 'CHECK\\s+OPTION',
                                                                                                'hashname' => '__PATTERN2__',
                                                                                                'description' => '/CHECK\\\\s+OPTION/i',
                                                                                                'lookahead' => 0,
                                                                                                'rdelim' => '/',
                                                                                                'line' => 150,
                                                                                                'mod' => 'i',
                                                                                                'ldelim' => '/'
                                                                                              }, 'Parse::RecDescent::Token' )
                                                                                     ],
                                                                          'line' => undef
                                                                        }, 'Parse::RecDescent::Production' )
                                                               ],
                                                    'name' => 'options',
                                                    'vars' => '',
                                                    'line' => 150
                                                  }, 'Parse::RecDescent::Rule' ),
                              'function' => bless( {
                                                     'impcount' => 1,
                                                     'calls' => [
                                                                  '_alternation_1_of_production_1_of_rule_function',
                                                                  'func_args'
                                                                ],
                                                     'changed' => 0,
                                                     'opcount' => 0,
                                                     'prods' => [
                                                                  bless( {
                                                                           'number' => '0',
                                                                           'strcount' => 2,
                                                                           'dircount' => 1,
                                                                           'uncommit' => undef,
                                                                           'error' => undef,
                                                                           'patcount' => 1,
                                                                           'actcount' => 0,
                                                                           'op' => [],
                                                                           'items' => [
                                                                                        bless( {
                                                                                                 'subrule' => '_alternation_1_of_production_1_of_rule_function',
                                                                                                 'matchrule' => 0,
                                                                                                 'implicit' => '/SYSIBM\\\\.|/i, or /SYSFUN\\\\.|/i, or userdefined_function',
                                                                                                 'argcode' => undef,
                                                                                                 'lookahead' => 0,
                                                                                                 'line' => 326
                                                                                               }, 'Parse::RecDescent::Subrule' ),
                                                                                        bless( {
                                                                                                 'pattern' => '(',
                                                                                                 'hashname' => '__STRING1__',
                                                                                                 'description' => '\'(\'',
                                                                                                 'lookahead' => 0,
                                                                                                 'line' => 326
                                                                                               }, 'Parse::RecDescent::Literal' ),
                                                                                        bless( {
                                                                                                 'expected' => '<leftop: func_args /,/ func_args>',
                                                                                                 'min' => 1,
                                                                                                 'name' => '\'func_args(s)\'',
                                                                                                 'max' => 100000000,
                                                                                                 'leftarg' => bless( {
                                                                                                                       'subrule' => 'func_args',
                                                                                                                       'matchrule' => 0,
                                                                                                                       'implicit' => undef,
                                                                                                                       'argcode' => undef,
                                                                                                                       'lookahead' => 0,
                                                                                                                       'line' => 326
                                                                                                                     }, 'Parse::RecDescent::Subrule' ),
                                                                                                 'rightarg' => bless( {
                                                                                                                        'subrule' => 'func_args',
                                                                                                                        'matchrule' => 0,
                                                                                                                        'implicit' => undef,
                                                                                                                        'argcode' => undef,
                                                                                                                        'lookahead' => 0,
                                                                                                                        'line' => 326
                                                                                                                      }, 'Parse::RecDescent::Subrule' ),
                                                                                                 'hashname' => '__DIRECTIVE1__',
                                                                                                 'type' => 'leftop',
                                                                                                 'op' => bless( {
                                                                                                                  'pattern' => ',',
                                                                                                                  'hashname' => '__PATTERN1__',
                                                                                                                  'description' => '/,/',
                                                                                                                  'lookahead' => 0,
                                                                                                                  'rdelim' => '/',
                                                                                                                  'line' => 326,
                                                                                                                  'mod' => '',
                                                                                                                  'ldelim' => '/'
                                                                                                                }, 'Parse::RecDescent::Token' )
                                                                                               }, 'Parse::RecDescent::Operator' ),
                                                                                        bless( {
                                                                                                 'pattern' => ')',
                                                                                                 'hashname' => '__STRING2__',
                                                                                                 'description' => '\')\'',
                                                                                                 'lookahead' => 0,
                                                                                                 'line' => 326
                                                                                               }, 'Parse::RecDescent::Literal' )
                                                                                      ],
                                                                           'line' => undef
                                                                         }, 'Parse::RecDescent::Production' )
                                                                ],
                                                     'name' => 'function',
                                                     'vars' => '',
                                                     'line' => 323
                                                   }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_41_of_rule_sysibm_function' => bless( {
                                                                                                    'impcount' => 0,
                                                                                                    'calls' => [],
                                                                                                    'changed' => 0,
                                                                                                    'opcount' => 0,
                                                                                                    'prods' => [
                                                                                                                 bless( {
                                                                                                                          'number' => '0',
                                                                                                                          'strcount' => 0,
                                                                                                                          'dircount' => 0,
                                                                                                                          'uncommit' => undef,
                                                                                                                          'error' => undef,
                                                                                                                          'patcount' => 1,
                                                                                                                          'actcount' => 0,
                                                                                                                          'items' => [
                                                                                                                                       bless( {
                                                                                                                                                'pattern' => 'INTEGER',
                                                                                                                                                'hashname' => '__PATTERN1__',
                                                                                                                                                'description' => '/INTEGER/i',
                                                                                                                                                'lookahead' => 0,
                                                                                                                                                'rdelim' => '/',
                                                                                                                                                'line' => 628,
                                                                                                                                                'mod' => 'i',
                                                                                                                                                'ldelim' => '/'
                                                                                                                                              }, 'Parse::RecDescent::Token' )
                                                                                                                                     ],
                                                                                                                          'line' => undef
                                                                                                                        }, 'Parse::RecDescent::Production' ),
                                                                                                                 bless( {
                                                                                                                          'number' => '1',
                                                                                                                          'strcount' => 0,
                                                                                                                          'dircount' => 0,
                                                                                                                          'uncommit' => undef,
                                                                                                                          'error' => undef,
                                                                                                                          'patcount' => 1,
                                                                                                                          'actcount' => 0,
                                                                                                                          'items' => [
                                                                                                                                       bless( {
                                                                                                                                                'pattern' => 'INT',
                                                                                                                                                'hashname' => '__PATTERN1__',
                                                                                                                                                'description' => '/INT/',
                                                                                                                                                'lookahead' => 0,
                                                                                                                                                'rdelim' => '/',
                                                                                                                                                'line' => 628,
                                                                                                                                                'mod' => '',
                                                                                                                                                'ldelim' => '/'
                                                                                                                                              }, 'Parse::RecDescent::Token' )
                                                                                                                                     ],
                                                                                                                          'line' => 628
                                                                                                                        }, 'Parse::RecDescent::Production' )
                                                                                                               ],
                                                                                                    'name' => '_alternation_1_of_production_41_of_rule_sysibm_function',
                                                                                                    'vars' => '',
                                                                                                    'line' => 628
                                                                                                  }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule_case_expression' => bless( {
                                                                                                   'impcount' => 0,
                                                                                                   'calls' => [
                                                                                                                'searched_when_clause',
                                                                                                                'simple_when_clause'
                                                                                                              ],
                                                                                                   'changed' => 0,
                                                                                                   'opcount' => 0,
                                                                                                   'prods' => [
                                                                                                                bless( {
                                                                                                                         'number' => '0',
                                                                                                                         'strcount' => 0,
                                                                                                                         'dircount' => 0,
                                                                                                                         'uncommit' => undef,
                                                                                                                         'error' => undef,
                                                                                                                         'patcount' => 0,
                                                                                                                         'actcount' => 0,
                                                                                                                         'items' => [
                                                                                                                                      bless( {
                                                                                                                                               'subrule' => 'searched_when_clause',
                                                                                                                                               'matchrule' => 0,
                                                                                                                                               'implicit' => undef,
                                                                                                                                               'argcode' => undef,
                                                                                                                                               'lookahead' => 0,
                                                                                                                                               'line' => 626
                                                                                                                                             }, 'Parse::RecDescent::Subrule' )
                                                                                                                                    ],
                                                                                                                         'line' => undef
                                                                                                                       }, 'Parse::RecDescent::Production' ),
                                                                                                                bless( {
                                                                                                                         'number' => '1',
                                                                                                                         'strcount' => 0,
                                                                                                                         'dircount' => 0,
                                                                                                                         'uncommit' => undef,
                                                                                                                         'error' => undef,
                                                                                                                         'patcount' => 0,
                                                                                                                         'actcount' => 0,
                                                                                                                         'items' => [
                                                                                                                                      bless( {
                                                                                                                                               'subrule' => 'simple_when_clause',
                                                                                                                                               'matchrule' => 0,
                                                                                                                                               'implicit' => undef,
                                                                                                                                               'argcode' => undef,
                                                                                                                                               'lookahead' => 0,
                                                                                                                                               'line' => 627
                                                                                                                                             }, 'Parse::RecDescent::Subrule' )
                                                                                                                                    ],
                                                                                                                         'line' => 627
                                                                                                                       }, 'Parse::RecDescent::Production' )
                                                                                                              ],
                                                                                                   'name' => '_alternation_1_of_production_1_of_rule_case_expression',
                                                                                                   'vars' => '',
                                                                                                   'line' => 626
                                                                                                 }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule_window_order_clause' => bless( {
                                                                                                       'impcount' => 1,
                                                                                                       'calls' => [
                                                                                                                    'sort_key_expression',
                                                                                                                    '_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_window_order_clause'
                                                                                                                  ],
                                                                                                       'changed' => 0,
                                                                                                       'opcount' => 0,
                                                                                                       'prods' => [
                                                                                                                    bless( {
                                                                                                                             'number' => '0',
                                                                                                                             'strcount' => 0,
                                                                                                                             'dircount' => 0,
                                                                                                                             'uncommit' => undef,
                                                                                                                             'error' => undef,
                                                                                                                             'patcount' => 0,
                                                                                                                             'actcount' => 0,
                                                                                                                             'items' => [
                                                                                                                                          bless( {
                                                                                                                                                   'subrule' => 'sort_key_expression',
                                                                                                                                                   'matchrule' => 0,
                                                                                                                                                   'implicit' => undef,
                                                                                                                                                   'argcode' => undef,
                                                                                                                                                   'lookahead' => 0,
                                                                                                                                                   'line' => 624
                                                                                                                                                 }, 'Parse::RecDescent::Subrule' ),
                                                                                                                                          bless( {
                                                                                                                                                   'subrule' => '_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_window_order_clause',
                                                                                                                                                   'expected' => 'asc_option, or desc_option',
                                                                                                                                                   'min' => 0,
                                                                                                                                                   'argcode' => undef,
                                                                                                                                                   'max' => 1,
                                                                                                                                                   'matchrule' => 0,
                                                                                                                                                   'repspec' => '?',
                                                                                                                                                   'lookahead' => 0,
                                                                                                                                                   'line' => 627
                                                                                                                                                 }, 'Parse::RecDescent::Repetition' )
                                                                                                                                        ],
                                                                                                                             'line' => undef
                                                                                                                           }, 'Parse::RecDescent::Production' )
                                                                                                                  ],
                                                                                                       'name' => '_alternation_1_of_production_1_of_rule_window_order_clause',
                                                                                                       'vars' => '',
                                                                                                       'line' => 624
                                                                                                     }, 'Parse::RecDescent::Rule' ),
                              'create' => bless( {
                                                   'impcount' => 0,
                                                   'calls' => [
                                                                'CREATE',
                                                                'TRIGGER',
                                                                'trigger_name',
                                                                'before',
                                                                'type',
                                                                'table_name',
                                                                'reference_b',
                                                                'triggered_action',
                                                                'after',
                                                                'reference_a',
                                                                'VIEW',
                                                                'view_name',
                                                                'column_list',
                                                                'with_expression',
                                                                'SQL_procedure_statement'
                                                              ],
                                                   'changed' => 0,
                                                   'opcount' => 0,
                                                   'prods' => [
                                                                bless( {
                                                                         'number' => '0',
                                                                         'strcount' => 1,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 2,
                                                                         'actcount' => 1,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'subrule' => 'CREATE',
                                                                                               'matchrule' => 0,
                                                                                               'implicit' => undef,
                                                                                               'argcode' => undef,
                                                                                               'lookahead' => 0,
                                                                                               'line' => 36
                                                                                             }, 'Parse::RecDescent::Subrule' ),
                                                                                      bless( {
                                                                                               'subrule' => 'TRIGGER',
                                                                                               'matchrule' => 0,
                                                                                               'implicit' => undef,
                                                                                               'argcode' => undef,
                                                                                               'lookahead' => 0,
                                                                                               'line' => 36
                                                                                             }, 'Parse::RecDescent::Subrule' ),
                                                                                      bless( {
                                                                                               'subrule' => 'trigger_name',
                                                                                               'matchrule' => 0,
                                                                                               'implicit' => undef,
                                                                                               'argcode' => undef,
                                                                                               'lookahead' => 0,
                                                                                               'line' => 36
                                                                                             }, 'Parse::RecDescent::Subrule' ),
                                                                                      bless( {
                                                                                               'subrule' => 'before',
                                                                                               'matchrule' => 0,
                                                                                               'implicit' => undef,
                                                                                               'argcode' => undef,
                                                                                               'lookahead' => 0,
                                                                                               'line' => 36
                                                                                             }, 'Parse::RecDescent::Subrule' ),
                                                                                      bless( {
                                                                                               'subrule' => 'type',
                                                                                               'matchrule' => 0,
                                                                                               'implicit' => undef,
                                                                                               'argcode' => undef,
                                                                                               'lookahead' => 0,
                                                                                               'line' => 36
                                                                                             }, 'Parse::RecDescent::Subrule' ),
                                                                                      bless( {
                                                                                               'pattern' => 'ON',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/ON/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 36,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' ),
                                                                                      bless( {
                                                                                               'subrule' => 'table_name',
                                                                                               'matchrule' => 0,
                                                                                               'implicit' => undef,
                                                                                               'argcode' => undef,
                                                                                               'lookahead' => 0,
                                                                                               'line' => 36
                                                                                             }, 'Parse::RecDescent::Subrule' ),
                                                                                      bless( {
                                                                                               'subrule' => 'reference_b',
                                                                                               'expected' => undef,
                                                                                               'min' => 0,
                                                                                               'argcode' => undef,
                                                                                               'max' => 1,
                                                                                               'matchrule' => 0,
                                                                                               'repspec' => '?',
                                                                                               'lookahead' => 0,
                                                                                               'line' => 36
                                                                                             }, 'Parse::RecDescent::Repetition' ),
                                                                                      bless( {
                                                                                               'pattern' => 'FOR EACH ROW',
                                                                                               'hashname' => '__PATTERN2__',
                                                                                               'description' => '/FOR EACH ROW/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 36,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' ),
                                                                                      bless( {
                                                                                               'pattern' => 'MODE DB2SQL',
                                                                                               'hashname' => '__STRING1__',
                                                                                               'description' => '\'MODE DB2SQL\'',
                                                                                               'lookahead' => 0,
                                                                                               'line' => 36
                                                                                             }, 'Parse::RecDescent::Literal' ),
                                                                                      bless( {
                                                                                               'subrule' => 'triggered_action',
                                                                                               'matchrule' => 0,
                                                                                               'implicit' => undef,
                                                                                               'argcode' => undef,
                                                                                               'lookahead' => 0,
                                                                                               'line' => 36
                                                                                             }, 'Parse::RecDescent::Subrule' ),
                                                                                      bless( {
                                                                                               'hashname' => '__ACTION1__',
                                                                                               'lookahead' => 0,
                                                                                               'line' => 37,
                                                                                               'code' => '{
    my $table_name = $item{\'table_name\'}{\'name\'};
    $return =  {
        table      => $table_name,
        schema     => $item{\'trigger_name\'}{\'schema\'},
        name       => $item{\'trigger_name\'}{\'name\'},
        when       => \'before\',
        db_event   => $item{\'type\'}->{\'event\'},
        fields     => $item{\'type\'}{\'fields\'},
        condition  => $item{\'triggered_action\'}{\'condition\'},
        reference  => $item{\'reference_b\'},
        granularity => $item[9],
        action     => $item{\'triggered_action\'}{\'statement\'}
    };

    push @triggers, $return;
}'
                                                                                             }, 'Parse::RecDescent::Action' )
                                                                                    ],
                                                                         'line' => undef
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '1',
                                                                         'strcount' => 1,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 2,
                                                                         'actcount' => 1,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'subrule' => 'CREATE',
                                                                                               'matchrule' => 0,
                                                                                               'implicit' => undef,
                                                                                               'argcode' => undef,
                                                                                               'lookahead' => 0,
                                                                                               'line' => 55
                                                                                             }, 'Parse::RecDescent::Subrule' ),
                                                                                      bless( {
                                                                                               'subrule' => 'TRIGGER',
                                                                                               'matchrule' => 0,
                                                                                               'implicit' => undef,
                                                                                               'argcode' => undef,
                                                                                               'lookahead' => 0,
                                                                                               'line' => 55
                                                                                             }, 'Parse::RecDescent::Subrule' ),
                                                                                      bless( {
                                                                                               'subrule' => 'trigger_name',
                                                                                               'matchrule' => 0,
                                                                                               'implicit' => undef,
                                                                                               'argcode' => undef,
                                                                                               'lookahead' => 0,
                                                                                               'line' => 55
                                                                                             }, 'Parse::RecDescent::Subrule' ),
                                                                                      bless( {
                                                                                               'subrule' => 'after',
                                                                                               'matchrule' => 0,
                                                                                               'implicit' => undef,
                                                                                               'argcode' => undef,
                                                                                               'lookahead' => 0,
                                                                                               'line' => 55
                                                                                             }, 'Parse::RecDescent::Subrule' ),
                                                                                      bless( {
                                                                                               'subrule' => 'type',
                                                                                               'matchrule' => 0,
                                                                                               'implicit' => undef,
                                                                                               'argcode' => undef,
                                                                                               'lookahead' => 0,
                                                                                               'line' => 55
                                                                                             }, 'Parse::RecDescent::Subrule' ),
                                                                                      bless( {
                                                                                               'pattern' => 'ON',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/ON/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 55,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' ),
                                                                                      bless( {
                                                                                               'subrule' => 'table_name',
                                                                                               'matchrule' => 0,
                                                                                               'implicit' => undef,
                                                                                               'argcode' => undef,
                                                                                               'lookahead' => 0,
                                                                                               'line' => 55
                                                                                             }, 'Parse::RecDescent::Subrule' ),
                                                                                      bless( {
                                                                                               'subrule' => 'reference_a',
                                                                                               'expected' => undef,
                                                                                               'min' => 0,
                                                                                               'argcode' => undef,
                                                                                               'max' => 1,
                                                                                               'matchrule' => 0,
                                                                                               'repspec' => '?',
                                                                                               'lookahead' => 0,
                                                                                               'line' => 55
                                                                                             }, 'Parse::RecDescent::Repetition' ),
                                                                                      bless( {
                                                                                               'pattern' => 'FOR EACH ROW|FOR EACH STATEMENT',
                                                                                               'hashname' => '__PATTERN2__',
                                                                                               'description' => '/FOR EACH ROW|FOR EACH STATEMENT/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 55,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' ),
                                                                                      bless( {
                                                                                               'pattern' => 'MODE DB2SQL',
                                                                                               'hashname' => '__STRING1__',
                                                                                               'description' => '\'MODE DB2SQL\'',
                                                                                               'lookahead' => 0,
                                                                                               'line' => 55
                                                                                             }, 'Parse::RecDescent::Literal' ),
                                                                                      bless( {
                                                                                               'subrule' => 'triggered_action',
                                                                                               'matchrule' => 0,
                                                                                               'implicit' => undef,
                                                                                               'argcode' => undef,
                                                                                               'lookahead' => 0,
                                                                                               'line' => 55
                                                                                             }, 'Parse::RecDescent::Subrule' ),
                                                                                      bless( {
                                                                                               'hashname' => '__ACTION1__',
                                                                                               'lookahead' => 0,
                                                                                               'line' => 56,
                                                                                               'code' => '{
    my $table_name = $item{\'table_name\'}{\'name\'};
    $return = {
        table      => $table_name,
        schema     => $item{\'trigger_name\'}{\'schema\'},
        name       => $item{\'trigger_name\'}{\'name\'},
        when       => \'after\',
        db_event   => $item{\'type\'}{\'event\'},
        fields     => $item{\'type\'}{\'fields\'},
        condition  => $item{\'triggered_action\'}{\'condition\'},
        reference  => $item{\'reference_a\'},
        granularity => $item[9],
        action     => $item{\'triggered_action\'}{\'statement\'}
    };

    push @triggers, $return;
}'
                                                                                             }, 'Parse::RecDescent::Action' )
                                                                                    ],
                                                                         'line' => undef
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '2',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 2,
                                                                         'actcount' => 1,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'subrule' => 'CREATE',
                                                                                               'matchrule' => 0,
                                                                                               'implicit' => undef,
                                                                                               'argcode' => undef,
                                                                                               'lookahead' => 0,
                                                                                               'line' => 74
                                                                                             }, 'Parse::RecDescent::Subrule' ),
                                                                                      bless( {
                                                                                               'pattern' => 'FEDERATED|',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/FEDERATED|/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 74,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' ),
                                                                                      bless( {
                                                                                               'subrule' => 'VIEW',
                                                                                               'matchrule' => 0,
                                                                                               'implicit' => undef,
                                                                                               'argcode' => undef,
                                                                                               'lookahead' => 0,
                                                                                               'line' => 74
                                                                                             }, 'Parse::RecDescent::Subrule' ),
                                                                                      bless( {
                                                                                               'subrule' => 'view_name',
                                                                                               'matchrule' => 0,
                                                                                               'implicit' => undef,
                                                                                               'argcode' => undef,
                                                                                               'lookahead' => 0,
                                                                                               'line' => 74
                                                                                             }, 'Parse::RecDescent::Subrule' ),
                                                                                      bless( {
                                                                                               'subrule' => 'column_list',
                                                                                               'expected' => undef,
                                                                                               'min' => 0,
                                                                                               'argcode' => undef,
                                                                                               'max' => 1,
                                                                                               'matchrule' => 0,
                                                                                               'repspec' => '?',
                                                                                               'lookahead' => 0,
                                                                                               'line' => 74
                                                                                             }, 'Parse::RecDescent::Repetition' ),
                                                                                      bless( {
                                                                                               'pattern' => 'AS',
                                                                                               'hashname' => '__PATTERN2__',
                                                                                               'description' => '/AS/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 74,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' ),
                                                                                      bless( {
                                                                                               'subrule' => 'with_expression',
                                                                                               'expected' => undef,
                                                                                               'min' => 0,
                                                                                               'argcode' => undef,
                                                                                               'max' => 1,
                                                                                               'matchrule' => 0,
                                                                                               'repspec' => '?',
                                                                                               'lookahead' => 0,
                                                                                               'line' => 74
                                                                                             }, 'Parse::RecDescent::Repetition' ),
                                                                                      bless( {
                                                                                               'subrule' => 'SQL_procedure_statement',
                                                                                               'matchrule' => 0,
                                                                                               'implicit' => undef,
                                                                                               'argcode' => undef,
                                                                                               'lookahead' => 0,
                                                                                               'line' => 74
                                                                                             }, 'Parse::RecDescent::Subrule' ),
                                                                                      bless( {
                                                                                               'hashname' => '__ACTION1__',
                                                                                               'lookahead' => 0,
                                                                                               'line' => 75,
                                                                                               'code' => '{
    $return = {
        name   => $item{view_name}{name},
        sql    => $item{SQL_procedure_statement},
        with   => $item{\'with_expression(?)\'},
        fields => $item{\'column_list(?)\'}
    };
    push @views, $return;
}'
                                                                                             }, 'Parse::RecDescent::Action' )
                                                                                    ],
                                                                         'line' => undef
                                                                       }, 'Parse::RecDescent::Production' )
                                                              ],
                                                   'name' => 'create',
                                                   'vars' => '',
                                                   'line' => 36
                                                 }, 'Parse::RecDescent::Rule' ),
                              'sysfun' => bless( {
                                                   'impcount' => 0,
                                                   'calls' => [
                                                                '_alternation_1_of_production_1_of_rule_sysfun',
                                                                '_alternation_1_of_production_7_of_rule_sysfun',
                                                                'I',
                                                                '_alternation_1_of_production_53_of_rule_sysfun'
                                                              ],
                                                   'changed' => 0,
                                                   'opcount' => 0,
                                                   'prods' => [
                                                                bless( {
                                                                         'number' => '0',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 0,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'subrule' => '_alternation_1_of_production_1_of_rule_sysfun',
                                                                                               'matchrule' => 0,
                                                                                               'implicit' => '/ABS/i, or /ABSVAL/i',
                                                                                               'argcode' => undef,
                                                                                               'lookahead' => 0,
                                                                                               'line' => 421
                                                                                             }, 'Parse::RecDescent::Subrule' )
                                                                                    ],
                                                                         'line' => undef
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '1',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'ACOS',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/ACOS/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 422,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 422
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '2',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'ASCII',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/ASCII/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 423,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 423
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '3',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'ASIN',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/ASIN/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 424,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 424
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '4',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'ATAN',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/ATAN/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 425,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 425
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '5',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'ATAN2',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/ATAN2/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 426,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 426
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '6',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 0,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'subrule' => '_alternation_1_of_production_7_of_rule_sysfun',
                                                                                               'matchrule' => 0,
                                                                                               'implicit' => '/CEIL/i, or /CEILING/i',
                                                                                               'argcode' => undef,
                                                                                               'lookahead' => 0,
                                                                                               'line' => 427
                                                                                             }, 'Parse::RecDescent::Subrule' )
                                                                                    ],
                                                                         'line' => 427
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '7',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'CHAR',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/CHAR/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 428,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 428
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '8',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'CHR',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/CHR/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 429,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 429
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '9',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'COS',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/COS/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 430,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 430
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '10',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'COT',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/COT/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 431,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 431
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '11',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'DAYNAME',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/DAYNAME/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 432,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 432
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '12',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'DAYOFWEEK',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/DAYOFWEEK/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 433,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 433
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '13',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'DAYOFWEEK_ISO',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/DAYOFWEEK_ISO/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 434,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 434
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '14',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'DAYOFYEAR',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/DAYOFYEAR/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 435,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 435
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '15',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'DEGREES',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/DEGREES/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 436,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 436
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '16',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'DIFFERENCE',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/DIFFERENCE/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 437,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 437
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '17',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'DOUBLE',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/DOUBLE/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 438,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 438
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '18',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'EXP',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/EXP/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 439,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 439
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '19',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'FLOOR',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/FLOOR/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 440,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 440
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '20',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'GET_ROUTINE_SAR',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/GET_ROUTINE_SAR/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 441,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 441
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '21',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'INSERT',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/INSERT/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 442,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 442
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '22',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'JULIAN_DAY',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/JULIAN_DAY/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 443,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 443
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '23',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'LCASE',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/LCASE/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 444,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 444
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '24',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'LEFT',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/LEFT/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 445,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 445
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '25',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'LN',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/LN/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 446,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 446
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '26',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'LOCATE',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/LOCATE/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 447,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 447
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '27',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'LOG',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/LOG/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 448,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 448
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '28',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'LOG10',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/LOG10/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 449,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 449
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '29',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'LTRIM',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/LTRIM/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 450,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 450
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '30',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'MIDNIGHT_SECONDS',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/MIDNIGHT_SECONDS/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 451,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 451
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '31',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'MOD',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/MOD/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 452,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 452
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '32',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'MONTHNAME',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/MONTHNAME/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 453,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 453
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '33',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'POWER',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/POWER/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 454,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 454
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '34',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'PUT_ROUTINE_SAR',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/PUT_ROUTINE_SAR/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 455,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 455
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '35',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'QUARTER',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/QUARTER/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 456,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 456
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '36',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'RADIANS',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/RADIANS/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 457,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 457
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '37',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'RAND',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/RAND/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 458,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 458
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '38',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'REPEAT',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/REPEAT/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 459,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 459
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '39',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'REPLACE',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/REPLACE/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 460,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 460
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '40',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'RIGHT',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/RIGHT/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 461,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 461
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '41',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'ROUND',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/ROUND/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 462,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 462
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '42',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'RTRIM',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/RTRIM/',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 463,
                                                                                               'mod' => '',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' ),
                                                                                      bless( {
                                                                                               'subrule' => 'I',
                                                                                               'matchrule' => 0,
                                                                                               'implicit' => undef,
                                                                                               'argcode' => undef,
                                                                                               'lookahead' => 0,
                                                                                               'line' => 463
                                                                                             }, 'Parse::RecDescent::Subrule' )
                                                                                    ],
                                                                         'line' => 463
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '43',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'SIGN',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/SIGN/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 464,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 464
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '44',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'SIN',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/SIN/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 465,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 465
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '45',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'SOUNDEX',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/SOUNDEX/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 466,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 466
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '46',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'SPACE',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/SPACE/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 467,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 467
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '47',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'SQLCACHE_SNAPSHOT',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/SQLCACHE_SNAPSHOT/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 468,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 468
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '48',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'SQRT',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/SQRT/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 469,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 469
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '49',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'TAN',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/TAN/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 470,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 470
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '50',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'TIMESTAMP_ISO',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/TIMESTAMP_ISO/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 471,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 471
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '51',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'TIMESTAMPDIFF',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/TIMESTAMPDIFF/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 472,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 472
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '52',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 0,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'subrule' => '_alternation_1_of_production_53_of_rule_sysfun',
                                                                                               'matchrule' => 0,
                                                                                               'implicit' => '/TRUNCATE/i, or /TRUNC/i',
                                                                                               'argcode' => undef,
                                                                                               'lookahead' => 0,
                                                                                               'line' => 473
                                                                                             }, 'Parse::RecDescent::Subrule' )
                                                                                    ],
                                                                         'line' => 473
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '53',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'UCASE',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/UCASE/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 474,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 474
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '54',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'WEEK',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/WEEK/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 475,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 475
                                                                       }, 'Parse::RecDescent::Production' ),
                                                                bless( {
                                                                         'number' => '55',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'WEEK_ISO',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/WEEK_ISO/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 476,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => 476
                                                                       }, 'Parse::RecDescent::Production' )
                                                              ],
                                                   'name' => 'sysfun',
                                                   'vars' => '',
                                                   'line' => 421
                                                 }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cond' => bless( {
                                                                                                                               'impcount' => 0,
                                                                                                                               'calls' => [
                                                                                                                                            'numeric_constant'
                                                                                                                                          ],
                                                                                                                               'changed' => 0,
                                                                                                                               'opcount' => 0,
                                                                                                                               'prods' => [
                                                                                                                                            bless( {
                                                                                                                                                     'number' => '0',
                                                                                                                                                     'strcount' => 0,
                                                                                                                                                     'dircount' => 0,
                                                                                                                                                     'uncommit' => undef,
                                                                                                                                                     'error' => undef,
                                                                                                                                                     'patcount' => 1,
                                                                                                                                                     'actcount' => 0,
                                                                                                                                                     'items' => [
                                                                                                                                                                  bless( {
                                                                                                                                                                           'pattern' => 'SELECTIVITY',
                                                                                                                                                                           'hashname' => '__PATTERN1__',
                                                                                                                                                                           'description' => '/SELECTIVITY/i',
                                                                                                                                                                           'lookahead' => 0,
                                                                                                                                                                           'rdelim' => '/',
                                                                                                                                                                           'line' => 628,
                                                                                                                                                                           'mod' => 'i',
                                                                                                                                                                           'ldelim' => '/'
                                                                                                                                                                         }, 'Parse::RecDescent::Token' ),
                                                                                                                                                                  bless( {
                                                                                                                                                                           'subrule' => 'numeric_constant',
                                                                                                                                                                           'matchrule' => 0,
                                                                                                                                                                           'implicit' => undef,
                                                                                                                                                                           'argcode' => undef,
                                                                                                                                                                           'lookahead' => 0,
                                                                                                                                                                           'line' => 628
                                                                                                                                                                         }, 'Parse::RecDescent::Subrule' )
                                                                                                                                                                ],
                                                                                                                                                     'line' => undef
                                                                                                                                                   }, 'Parse::RecDescent::Production' )
                                                                                                                                          ],
                                                                                                                               'name' => '_alternation_1_of_production_1_of_rule__alternation_2_of_production_1_of_rule_cond',
                                                                                                                               'vars' => '',
                                                                                                                               'line' => 628
                                                                                                                             }, 'Parse::RecDescent::Rule' ),
                              'NAME' => bless( {
                                                 'impcount' => 0,
                                                 'calls' => [],
                                                 'changed' => 0,
                                                 'opcount' => 0,
                                                 'prods' => [
                                                              bless( {
                                                                       'number' => '0',
                                                                       'strcount' => 0,
                                                                       'dircount' => 0,
                                                                       'uncommit' => undef,
                                                                       'error' => undef,
                                                                       'patcount' => 1,
                                                                       'actcount' => 0,
                                                                       'items' => [
                                                                                    bless( {
                                                                                             'pattern' => '\\w+',
                                                                                             'hashname' => '__PATTERN1__',
                                                                                             'description' => '/\\\\w+/',
                                                                                             'lookahead' => 0,
                                                                                             'rdelim' => '/',
                                                                                             'line' => 146,
                                                                                             'mod' => '',
                                                                                             'ldelim' => '/'
                                                                                           }, 'Parse::RecDescent::Token' )
                                                                                  ],
                                                                       'line' => undef
                                                                     }, 'Parse::RecDescent::Production' ),
                                                              bless( {
                                                                       'number' => '1',
                                                                       'strcount' => 0,
                                                                       'dircount' => 0,
                                                                       'uncommit' => undef,
                                                                       'error' => undef,
                                                                       'patcount' => 1,
                                                                       'actcount' => 0,
                                                                       'items' => [
                                                                                    bless( {
                                                                                             'pattern' => '\\w{1,18}',
                                                                                             'hashname' => '__PATTERN1__',
                                                                                             'description' => '/\\\\w\\{1,18\\}/',
                                                                                             'lookahead' => 0,
                                                                                             'rdelim' => '/',
                                                                                             'line' => 148,
                                                                                             'mod' => '',
                                                                                             'ldelim' => '/'
                                                                                           }, 'Parse::RecDescent::Token' )
                                                                                  ],
                                                                       'line' => undef
                                                                     }, 'Parse::RecDescent::Production' )
                                                            ],
                                                 'name' => 'NAME',
                                                 'vars' => '',
                                                 'line' => 146
                                               }, 'Parse::RecDescent::Rule' ),
                              'constant' => bless( {
                                                     'impcount' => 0,
                                                     'calls' => [
                                                                  'int_const',
                                                                  'float_const',
                                                                  'dec_const',
                                                                  'char_const',
                                                                  'hex_const',
                                                                  'grastr_const'
                                                                ],
                                                     'changed' => 0,
                                                     'opcount' => 0,
                                                     'prods' => [
                                                                  bless( {
                                                                           'number' => '0',
                                                                           'strcount' => 0,
                                                                           'dircount' => 0,
                                                                           'uncommit' => undef,
                                                                           'error' => undef,
                                                                           'patcount' => 0,
                                                                           'actcount' => 0,
                                                                           'items' => [
                                                                                        bless( {
                                                                                                 'subrule' => 'int_const',
                                                                                                 'matchrule' => 0,
                                                                                                 'implicit' => undef,
                                                                                                 'argcode' => undef,
                                                                                                 'lookahead' => 0,
                                                                                                 'line' => 328
                                                                                               }, 'Parse::RecDescent::Subrule' )
                                                                                      ],
                                                                           'line' => undef
                                                                         }, 'Parse::RecDescent::Production' ),
                                                                  bless( {
                                                                           'number' => '1',
                                                                           'strcount' => 0,
                                                                           'dircount' => 0,
                                                                           'uncommit' => undef,
                                                                           'error' => undef,
                                                                           'patcount' => 0,
                                                                           'actcount' => 0,
                                                                           'items' => [
                                                                                        bless( {
                                                                                                 'subrule' => 'float_const',
                                                                                                 'matchrule' => 0,
                                                                                                 'implicit' => undef,
                                                                                                 'argcode' => undef,
                                                                                                 'lookahead' => 0,
                                                                                                 'line' => 328
                                                                                               }, 'Parse::RecDescent::Subrule' )
                                                                                      ],
                                                                           'line' => 328
                                                                         }, 'Parse::RecDescent::Production' ),
                                                                  bless( {
                                                                           'number' => '2',
                                                                           'strcount' => 0,
                                                                           'dircount' => 0,
                                                                           'uncommit' => undef,
                                                                           'error' => undef,
                                                                           'patcount' => 0,
                                                                           'actcount' => 0,
                                                                           'items' => [
                                                                                        bless( {
                                                                                                 'subrule' => 'dec_const',
                                                                                                 'matchrule' => 0,
                                                                                                 'implicit' => undef,
                                                                                                 'argcode' => undef,
                                                                                                 'lookahead' => 0,
                                                                                                 'line' => 328
                                                                                               }, 'Parse::RecDescent::Subrule' )
                                                                                      ],
                                                                           'line' => 328
                                                                         }, 'Parse::RecDescent::Production' ),
                                                                  bless( {
                                                                           'number' => '3',
                                                                           'strcount' => 0,
                                                                           'dircount' => 0,
                                                                           'uncommit' => undef,
                                                                           'error' => undef,
                                                                           'patcount' => 0,
                                                                           'actcount' => 0,
                                                                           'items' => [
                                                                                        bless( {
                                                                                                 'subrule' => 'char_const',
                                                                                                 'matchrule' => 0,
                                                                                                 'implicit' => undef,
                                                                                                 'argcode' => undef,
                                                                                                 'lookahead' => 0,
                                                                                                 'line' => 328
                                                                                               }, 'Parse::RecDescent::Subrule' )
                                                                                      ],
                                                                           'line' => 328
                                                                         }, 'Parse::RecDescent::Production' ),
                                                                  bless( {
                                                                           'number' => '4',
                                                                           'strcount' => 0,
                                                                           'dircount' => 0,
                                                                           'uncommit' => undef,
                                                                           'error' => undef,
                                                                           'patcount' => 0,
                                                                           'actcount' => 0,
                                                                           'items' => [
                                                                                        bless( {
                                                                                                 'subrule' => 'hex_const',
                                                                                                 'matchrule' => 0,
                                                                                                 'implicit' => undef,
                                                                                                 'argcode' => undef,
                                                                                                 'lookahead' => 0,
                                                                                                 'line' => 328
                                                                                               }, 'Parse::RecDescent::Subrule' )
                                                                                      ],
                                                                           'line' => 328
                                                                         }, 'Parse::RecDescent::Production' ),
                                                                  bless( {
                                                                           'number' => '5',
                                                                           'strcount' => 0,
                                                                           'dircount' => 0,
                                                                           'uncommit' => undef,
                                                                           'error' => undef,
                                                                           'patcount' => 0,
                                                                           'actcount' => 0,
                                                                           'items' => [
                                                                                        bless( {
                                                                                                 'subrule' => 'grastr_const',
                                                                                                 'matchrule' => 0,
                                                                                                 'implicit' => undef,
                                                                                                 'argcode' => undef,
                                                                                                 'lookahead' => 0,
                                                                                                 'line' => 328
                                                                                               }, 'Parse::RecDescent::Subrule' )
                                                                                      ],
                                                                           'line' => 328
                                                                         }, 'Parse::RecDescent::Production' )
                                                                ],
                                                     'name' => 'constant',
                                                     'vars' => '',
                                                     'line' => 328
                                                   }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule_ranking_function' => bless( {
                                                                                                    'impcount' => 0,
                                                                                                    'calls' => [],
                                                                                                    'changed' => 0,
                                                                                                    'opcount' => 0,
                                                                                                    'prods' => [
                                                                                                                 bless( {
                                                                                                                          'number' => '0',
                                                                                                                          'strcount' => 1,
                                                                                                                          'dircount' => 0,
                                                                                                                          'uncommit' => undef,
                                                                                                                          'error' => undef,
                                                                                                                          'patcount' => 1,
                                                                                                                          'actcount' => 0,
                                                                                                                          'items' => [
                                                                                                                                       bless( {
                                                                                                                                                'pattern' => 'RANK',
                                                                                                                                                'hashname' => '__PATTERN1__',
                                                                                                                                                'description' => '/RANK/',
                                                                                                                                                'lookahead' => 0,
                                                                                                                                                'rdelim' => '/',
                                                                                                                                                'line' => 626,
                                                                                                                                                'mod' => '',
                                                                                                                                                'ldelim' => '/'
                                                                                                                                              }, 'Parse::RecDescent::Token' ),
                                                                                                                                       bless( {
                                                                                                                                                'pattern' => '()',
                                                                                                                                                'hashname' => '__STRING1__',
                                                                                                                                                'description' => '\'()\'',
                                                                                                                                                'lookahead' => 0,
                                                                                                                                                'line' => 626
                                                                                                                                              }, 'Parse::RecDescent::Literal' )
                                                                                                                                     ],
                                                                                                                          'line' => undef
                                                                                                                        }, 'Parse::RecDescent::Production' ),
                                                                                                                 bless( {
                                                                                                                          'number' => '1',
                                                                                                                          'strcount' => 1,
                                                                                                                          'dircount' => 0,
                                                                                                                          'uncommit' => undef,
                                                                                                                          'error' => undef,
                                                                                                                          'patcount' => 1,
                                                                                                                          'actcount' => 0,
                                                                                                                          'items' => [
                                                                                                                                       bless( {
                                                                                                                                                'pattern' => 'DENSE_RANK|DENSERANK',
                                                                                                                                                'hashname' => '__PATTERN1__',
                                                                                                                                                'description' => '/DENSE_RANK|DENSERANK/i',
                                                                                                                                                'lookahead' => 0,
                                                                                                                                                'rdelim' => '/',
                                                                                                                                                'line' => 627,
                                                                                                                                                'mod' => 'i',
                                                                                                                                                'ldelim' => '/'
                                                                                                                                              }, 'Parse::RecDescent::Token' ),
                                                                                                                                       bless( {
                                                                                                                                                'pattern' => '()',
                                                                                                                                                'hashname' => '__STRING1__',
                                                                                                                                                'description' => '\'()\'',
                                                                                                                                                'lookahead' => 0,
                                                                                                                                                'line' => 627
                                                                                                                                              }, 'Parse::RecDescent::Literal' )
                                                                                                                                     ],
                                                                                                                          'line' => 627
                                                                                                                        }, 'Parse::RecDescent::Production' )
                                                                                                               ],
                                                                                                    'name' => '_alternation_1_of_production_1_of_rule_ranking_function',
                                                                                                    'vars' => '',
                                                                                                    'line' => 626
                                                                                                  }, 'Parse::RecDescent::Rule' ),
                              'window_aggregation_group_clause' => bless( {
                                                                            'impcount' => 2,
                                                                            'calls' => [
                                                                                         '_alternation_1_of_production_1_of_rule_window_aggregation_group_clause',
                                                                                         '_alternation_2_of_production_1_of_rule_window_aggregation_group_clause'
                                                                                       ],
                                                                            'changed' => 0,
                                                                            'opcount' => 0,
                                                                            'prods' => [
                                                                                         bless( {
                                                                                                  'number' => '0',
                                                                                                  'strcount' => 0,
                                                                                                  'dircount' => 0,
                                                                                                  'uncommit' => undef,
                                                                                                  'error' => undef,
                                                                                                  'patcount' => 0,
                                                                                                  'actcount' => 0,
                                                                                                  'items' => [
                                                                                                               bless( {
                                                                                                                        'subrule' => '_alternation_1_of_production_1_of_rule_window_aggregation_group_clause',
                                                                                                                        'matchrule' => 0,
                                                                                                                        'implicit' => '/ROWS/i, or /RANGE/i',
                                                                                                                        'argcode' => undef,
                                                                                                                        'lookahead' => 0,
                                                                                                                        'line' => 568
                                                                                                                      }, 'Parse::RecDescent::Subrule' ),
                                                                                                               bless( {
                                                                                                                        'subrule' => '_alternation_2_of_production_1_of_rule_window_aggregation_group_clause',
                                                                                                                        'matchrule' => 0,
                                                                                                                        'implicit' => 'group_start, or group_between, or group_end',
                                                                                                                        'argcode' => undef,
                                                                                                                        'lookahead' => 0,
                                                                                                                        'line' => 572
                                                                                                                      }, 'Parse::RecDescent::Subrule' )
                                                                                                             ],
                                                                                                  'line' => undef
                                                                                                }, 'Parse::RecDescent::Production' )
                                                                                       ],
                                                                            'name' => 'window_aggregation_group_clause',
                                                                            'vars' => '',
                                                                            'line' => 566
                                                                          }, 'Parse::RecDescent::Rule' ),
                              '_alternation_2_of_production_1_of_rule_window_aggregation_group_clause' => bless( {
                                                                                                                   'impcount' => 0,
                                                                                                                   'calls' => [
                                                                                                                                'group_start',
                                                                                                                                'group_between',
                                                                                                                                'group_end'
                                                                                                                              ],
                                                                                                                   'changed' => 0,
                                                                                                                   'opcount' => 0,
                                                                                                                   'prods' => [
                                                                                                                                bless( {
                                                                                                                                         'number' => '0',
                                                                                                                                         'strcount' => 0,
                                                                                                                                         'dircount' => 0,
                                                                                                                                         'uncommit' => undef,
                                                                                                                                         'error' => undef,
                                                                                                                                         'patcount' => 0,
                                                                                                                                         'actcount' => 0,
                                                                                                                                         'items' => [
                                                                                                                                                      bless( {
                                                                                                                                                               'subrule' => 'group_start',
                                                                                                                                                               'matchrule' => 0,
                                                                                                                                                               'implicit' => undef,
                                                                                                                                                               'argcode' => undef,
                                                                                                                                                               'lookahead' => 0,
                                                                                                                                                               'line' => 625
                                                                                                                                                             }, 'Parse::RecDescent::Subrule' )
                                                                                                                                                    ],
                                                                                                                                         'line' => undef
                                                                                                                                       }, 'Parse::RecDescent::Production' ),
                                                                                                                                bless( {
                                                                                                                                         'number' => '1',
                                                                                                                                         'strcount' => 0,
                                                                                                                                         'dircount' => 0,
                                                                                                                                         'uncommit' => undef,
                                                                                                                                         'error' => undef,
                                                                                                                                         'patcount' => 0,
                                                                                                                                         'actcount' => 0,
                                                                                                                                         'items' => [
                                                                                                                                                      bless( {
                                                                                                                                                               'subrule' => 'group_between',
                                                                                                                                                               'matchrule' => 0,
                                                                                                                                                               'implicit' => undef,
                                                                                                                                                               'argcode' => undef,
                                                                                                                                                               'lookahead' => 0,
                                                                                                                                                               'line' => 626
                                                                                                                                                             }, 'Parse::RecDescent::Subrule' )
                                                                                                                                                    ],
                                                                                                                                         'line' => 626
                                                                                                                                       }, 'Parse::RecDescent::Production' ),
                                                                                                                                bless( {
                                                                                                                                         'number' => '2',
                                                                                                                                         'strcount' => 0,
                                                                                                                                         'dircount' => 0,
                                                                                                                                         'uncommit' => undef,
                                                                                                                                         'error' => undef,
                                                                                                                                         'patcount' => 0,
                                                                                                                                         'actcount' => 0,
                                                                                                                                         'items' => [
                                                                                                                                                      bless( {
                                                                                                                                                               'subrule' => 'group_end',
                                                                                                                                                               'matchrule' => 0,
                                                                                                                                                               'implicit' => undef,
                                                                                                                                                               'argcode' => undef,
                                                                                                                                                               'lookahead' => 0,
                                                                                                                                                               'line' => 627
                                                                                                                                                             }, 'Parse::RecDescent::Subrule' )
                                                                                                                                                    ],
                                                                                                                                         'line' => 627
                                                                                                                                       }, 'Parse::RecDescent::Production' )
                                                                                                                              ],
                                                                                                                   'name' => '_alternation_2_of_production_1_of_rule_window_aggregation_group_clause',
                                                                                                                   'vars' => '',
                                                                                                                   'line' => 625
                                                                                                                 }, 'Parse::RecDescent::Rule' ),
                              'VIEW' => bless( {
                                                 'impcount' => 0,
                                                 'calls' => [],
                                                 'changed' => 0,
                                                 'opcount' => 0,
                                                 'prods' => [
                                                              bless( {
                                                                       'number' => '0',
                                                                       'strcount' => 0,
                                                                       'dircount' => 0,
                                                                       'uncommit' => undef,
                                                                       'error' => undef,
                                                                       'patcount' => 1,
                                                                       'actcount' => 0,
                                                                       'items' => [
                                                                                    bless( {
                                                                                             'pattern' => 'view',
                                                                                             'hashname' => '__PATTERN1__',
                                                                                             'description' => '/view/i',
                                                                                             'lookahead' => 0,
                                                                                             'rdelim' => '/',
                                                                                             'line' => 105,
                                                                                             'mod' => 'i',
                                                                                             'ldelim' => '/'
                                                                                           }, 'Parse::RecDescent::Token' )
                                                                                  ],
                                                                       'line' => undef
                                                                     }, 'Parse::RecDescent::Production' )
                                                            ],
                                                 'name' => 'VIEW',
                                                 'vars' => '',
                                                 'line' => 105
                                               }, 'Parse::RecDescent::Rule' ),
                              'with_expression' => bless( {
                                                            'impcount' => 0,
                                                            'calls' => [
                                                                         'common_table_expression'
                                                                       ],
                                                            'changed' => 0,
                                                            'opcount' => 0,
                                                            'prods' => [
                                                                         bless( {
                                                                                  'number' => '0',
                                                                                  'strcount' => 0,
                                                                                  'dircount' => 1,
                                                                                  'uncommit' => undef,
                                                                                  'error' => undef,
                                                                                  'patcount' => 2,
                                                                                  'actcount' => 1,
                                                                                  'op' => [],
                                                                                  'items' => [
                                                                                               bless( {
                                                                                                        'pattern' => 'WITH',
                                                                                                        'hashname' => '__PATTERN1__',
                                                                                                        'description' => '/WITH/i',
                                                                                                        'lookahead' => 0,
                                                                                                        'rdelim' => '/',
                                                                                                        'line' => 89,
                                                                                                        'mod' => 'i',
                                                                                                        'ldelim' => '/'
                                                                                                      }, 'Parse::RecDescent::Token' ),
                                                                                               bless( {
                                                                                                        'expected' => '<leftop: common_table_expression /,/ common_table_expression>',
                                                                                                        'min' => 1,
                                                                                                        'name' => '\'common_table_expression(s)\'',
                                                                                                        'max' => 100000000,
                                                                                                        'leftarg' => bless( {
                                                                                                                              'subrule' => 'common_table_expression',
                                                                                                                              'matchrule' => 0,
                                                                                                                              'implicit' => undef,
                                                                                                                              'argcode' => undef,
                                                                                                                              'lookahead' => 0,
                                                                                                                              'line' => 89
                                                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                                        'rightarg' => bless( {
                                                                                                                               'subrule' => 'common_table_expression',
                                                                                                                               'matchrule' => 0,
                                                                                                                               'implicit' => undef,
                                                                                                                               'argcode' => undef,
                                                                                                                               'lookahead' => 0,
                                                                                                                               'line' => 89
                                                                                                                             }, 'Parse::RecDescent::Subrule' ),
                                                                                                        'hashname' => '__DIRECTIVE1__',
                                                                                                        'type' => 'leftop',
                                                                                                        'op' => bless( {
                                                                                                                         'pattern' => ',',
                                                                                                                         'hashname' => '__PATTERN2__',
                                                                                                                         'description' => '/,/',
                                                                                                                         'lookahead' => 0,
                                                                                                                         'rdelim' => '/',
                                                                                                                         'line' => 89,
                                                                                                                         'mod' => '',
                                                                                                                         'ldelim' => '/'
                                                                                                                       }, 'Parse::RecDescent::Token' )
                                                                                                      }, 'Parse::RecDescent::Operator' ),
                                                                                               bless( {
                                                                                                        'hashname' => '__ACTION1__',
                                                                                                        'lookahead' => 0,
                                                                                                        'line' => 90,
                                                                                                        'code' => '{
    $return = $item{\'common_table_expression\'};
}'
                                                                                                      }, 'Parse::RecDescent::Action' )
                                                                                             ],
                                                                                  'line' => undef
                                                                                }, 'Parse::RecDescent::Production' )
                                                                       ],
                                                            'name' => 'with_expression',
                                                            'vars' => '',
                                                            'line' => 87
                                                          }, 'Parse::RecDescent::Rule' ),
                              'numeric_constant' => bless( {
                                                             'impcount' => 0,
                                                             'calls' => [],
                                                             'changed' => 0,
                                                             'opcount' => 0,
                                                             'prods' => [
                                                                          bless( {
                                                                                   'number' => '0',
                                                                                   'strcount' => 0,
                                                                                   'dircount' => 0,
                                                                                   'uncommit' => undef,
                                                                                   'error' => undef,
                                                                                   'patcount' => 1,
                                                                                   'actcount' => 0,
                                                                                   'items' => [
                                                                                                bless( {
                                                                                                         'pattern' => '\\d+',
                                                                                                         'hashname' => '__PATTERN1__',
                                                                                                         'description' => '/\\\\d+/',
                                                                                                         'lookahead' => 0,
                                                                                                         'rdelim' => '/',
                                                                                                         'line' => 140,
                                                                                                         'mod' => '',
                                                                                                         'ldelim' => '/'
                                                                                                       }, 'Parse::RecDescent::Token' )
                                                                                              ],
                                                                                   'line' => undef
                                                                                 }, 'Parse::RecDescent::Production' )
                                                                        ],
                                                             'name' => 'numeric_constant',
                                                             'vars' => '',
                                                             'line' => 140
                                                           }, 'Parse::RecDescent::Rule' ),
                              'old_new_table' => bless( {
                                                          'impcount' => 0,
                                                          'calls' => [
                                                                       'identifier'
                                                                     ],
                                                          'changed' => 0,
                                                          'opcount' => 0,
                                                          'prods' => [
                                                                       bless( {
                                                                                'number' => '0',
                                                                                'strcount' => 0,
                                                                                'dircount' => 0,
                                                                                'uncommit' => undef,
                                                                                'error' => undef,
                                                                                'patcount' => 2,
                                                                                'actcount' => 1,
                                                                                'items' => [
                                                                                             bless( {
                                                                                                      'pattern' => 'OLD_TABLE',
                                                                                                      'hashname' => '__PATTERN1__',
                                                                                                      'description' => '/OLD_TABLE/i',
                                                                                                      'lookahead' => 0,
                                                                                                      'rdelim' => '/',
                                                                                                      'line' => 291,
                                                                                                      'mod' => 'i',
                                                                                                      'ldelim' => '/'
                                                                                                    }, 'Parse::RecDescent::Token' ),
                                                                                             bless( {
                                                                                                      'pattern' => '(AS)?',
                                                                                                      'hashname' => '__PATTERN2__',
                                                                                                      'description' => '/(AS)?/i',
                                                                                                      'lookahead' => 0,
                                                                                                      'rdelim' => '/',
                                                                                                      'line' => 291,
                                                                                                      'mod' => 'i',
                                                                                                      'ldelim' => '/'
                                                                                                    }, 'Parse::RecDescent::Token' ),
                                                                                             bless( {
                                                                                                      'subrule' => 'identifier',
                                                                                                      'matchrule' => 0,
                                                                                                      'implicit' => undef,
                                                                                                      'argcode' => undef,
                                                                                                      'lookahead' => 0,
                                                                                                      'line' => 291
                                                                                                    }, 'Parse::RecDescent::Subrule' ),
                                                                                             bless( {
                                                                                                      'hashname' => '__ACTION1__',
                                                                                                      'lookahead' => 0,
                                                                                                      'line' => 292,
                                                                                                      'code' => '{ $return = join(\' \', @item[1..3] ) }'
                                                                                                    }, 'Parse::RecDescent::Action' )
                                                                                           ],
                                                                                'line' => undef
                                                                              }, 'Parse::RecDescent::Production' ),
                                                                       bless( {
                                                                                'number' => '1',
                                                                                'strcount' => 0,
                                                                                'dircount' => 0,
                                                                                'uncommit' => undef,
                                                                                'error' => undef,
                                                                                'patcount' => 2,
                                                                                'actcount' => 1,
                                                                                'items' => [
                                                                                             bless( {
                                                                                                      'pattern' => 'NEW_TABLE',
                                                                                                      'hashname' => '__PATTERN1__',
                                                                                                      'description' => '/NEW_TABLE/i',
                                                                                                      'lookahead' => 0,
                                                                                                      'rdelim' => '/',
                                                                                                      'line' => 293,
                                                                                                      'mod' => 'i',
                                                                                                      'ldelim' => '/'
                                                                                                    }, 'Parse::RecDescent::Token' ),
                                                                                             bless( {
                                                                                                      'pattern' => '(AS)?',
                                                                                                      'hashname' => '__PATTERN2__',
                                                                                                      'description' => '/(AS)?/i',
                                                                                                      'lookahead' => 0,
                                                                                                      'rdelim' => '/',
                                                                                                      'line' => 293,
                                                                                                      'mod' => 'i',
                                                                                                      'ldelim' => '/'
                                                                                                    }, 'Parse::RecDescent::Token' ),
                                                                                             bless( {
                                                                                                      'subrule' => 'identifier',
                                                                                                      'matchrule' => 0,
                                                                                                      'implicit' => undef,
                                                                                                      'argcode' => undef,
                                                                                                      'lookahead' => 0,
                                                                                                      'line' => 293
                                                                                                    }, 'Parse::RecDescent::Subrule' ),
                                                                                             bless( {
                                                                                                      'hashname' => '__ACTION1__',
                                                                                                      'lookahead' => 0,
                                                                                                      'line' => 294,
                                                                                                      'code' => '{ $return = join(\' \', @item[1..3] ) }'
                                                                                                    }, 'Parse::RecDescent::Action' )
                                                                                           ],
                                                                                'line' => 293
                                                                              }, 'Parse::RecDescent::Production' )
                                                                     ],
                                                          'name' => 'old_new_table',
                                                          'vars' => '',
                                                          'line' => 291
                                                        }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule_numbering_function' => bless( {
                                                                                                      'impcount' => 0,
                                                                                                      'calls' => [
                                                                                                                   'window_order_clause',
                                                                                                                   'window_aggregation_group_clause'
                                                                                                                 ],
                                                                                                      'changed' => 0,
                                                                                                      'opcount' => 0,
                                                                                                      'prods' => [
                                                                                                                   bless( {
                                                                                                                            'number' => '0',
                                                                                                                            'strcount' => 0,
                                                                                                                            'dircount' => 0,
                                                                                                                            'uncommit' => undef,
                                                                                                                            'error' => undef,
                                                                                                                            'patcount' => 0,
                                                                                                                            'actcount' => 0,
                                                                                                                            'items' => [
                                                                                                                                         bless( {
                                                                                                                                                  'subrule' => 'window_order_clause',
                                                                                                                                                  'matchrule' => 0,
                                                                                                                                                  'implicit' => undef,
                                                                                                                                                  'argcode' => undef,
                                                                                                                                                  'lookahead' => 0,
                                                                                                                                                  'line' => 627
                                                                                                                                                }, 'Parse::RecDescent::Subrule' ),
                                                                                                                                         bless( {
                                                                                                                                                  'subrule' => 'window_aggregation_group_clause',
                                                                                                                                                  'expected' => undef,
                                                                                                                                                  'min' => 0,
                                                                                                                                                  'argcode' => undef,
                                                                                                                                                  'max' => 1,
                                                                                                                                                  'matchrule' => 0,
                                                                                                                                                  'repspec' => '?',
                                                                                                                                                  'lookahead' => 0,
                                                                                                                                                  'line' => 627
                                                                                                                                                }, 'Parse::RecDescent::Repetition' )
                                                                                                                                       ],
                                                                                                                            'line' => undef
                                                                                                                          }, 'Parse::RecDescent::Production' )
                                                                                                                 ],
                                                                                                      'name' => '_alternation_1_of_production_1_of_rule_numbering_function',
                                                                                                      'vars' => '',
                                                                                                      'line' => 627
                                                                                                    }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_searched_when_clause' => bless( {
                                                                                                                                               'impcount' => 0,
                                                                                                                                               'calls' => [
                                                                                                                                                            'result_expression'
                                                                                                                                                          ],
                                                                                                                                               'changed' => 0,
                                                                                                                                               'opcount' => 0,
                                                                                                                                               'prods' => [
                                                                                                                                                            bless( {
                                                                                                                                                                     'number' => '0',
                                                                                                                                                                     'strcount' => 0,
                                                                                                                                                                     'dircount' => 0,
                                                                                                                                                                     'uncommit' => undef,
                                                                                                                                                                     'error' => undef,
                                                                                                                                                                     'patcount' => 0,
                                                                                                                                                                     'actcount' => 0,
                                                                                                                                                                     'items' => [
                                                                                                                                                                                  bless( {
                                                                                                                                                                                           'subrule' => 'result_expression',
                                                                                                                                                                                           'matchrule' => 0,
                                                                                                                                                                                           'implicit' => undef,
                                                                                                                                                                                           'argcode' => undef,
                                                                                                                                                                                           'lookahead' => 0,
                                                                                                                                                                                           'line' => 626
                                                                                                                                                                                         }, 'Parse::RecDescent::Subrule' )
                                                                                                                                                                                ],
                                                                                                                                                                     'line' => undef
                                                                                                                                                                   }, 'Parse::RecDescent::Production' ),
                                                                                                                                                            bless( {
                                                                                                                                                                     'number' => '1',
                                                                                                                                                                     'strcount' => 0,
                                                                                                                                                                     'dircount' => 0,
                                                                                                                                                                     'uncommit' => undef,
                                                                                                                                                                     'error' => undef,
                                                                                                                                                                     'patcount' => 1,
                                                                                                                                                                     'actcount' => 0,
                                                                                                                                                                     'items' => [
                                                                                                                                                                                  bless( {
                                                                                                                                                                                           'pattern' => 'NULL',
                                                                                                                                                                                           'hashname' => '__PATTERN1__',
                                                                                                                                                                                           'description' => '/NULL/i',
                                                                                                                                                                                           'lookahead' => 0,
                                                                                                                                                                                           'rdelim' => '/',
                                                                                                                                                                                           'line' => 627,
                                                                                                                                                                                           'mod' => 'i',
                                                                                                                                                                                           'ldelim' => '/'
                                                                                                                                                                                         }, 'Parse::RecDescent::Token' )
                                                                                                                                                                                ],
                                                                                                                                                                     'line' => 627
                                                                                                                                                                   }, 'Parse::RecDescent::Production' )
                                                                                                                                                          ],
                                                                                                                                               'name' => '_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_searched_when_clause',
                                                                                                                                               'vars' => '',
                                                                                                                                               'line' => 626
                                                                                                                                             }, 'Parse::RecDescent::Rule' ),
                              'old_new_corr' => bless( {
                                                         'impcount' => 0,
                                                         'calls' => [
                                                                      'correlation_name'
                                                                    ],
                                                         'changed' => 0,
                                                         'opcount' => 0,
                                                         'prods' => [
                                                                      bless( {
                                                                               'number' => '0',
                                                                               'strcount' => 0,
                                                                               'dircount' => 0,
                                                                               'uncommit' => undef,
                                                                               'error' => undef,
                                                                               'patcount' => 2,
                                                                               'actcount' => 1,
                                                                               'items' => [
                                                                                            bless( {
                                                                                                     'pattern' => 'OLD',
                                                                                                     'hashname' => '__PATTERN1__',
                                                                                                     'description' => '/OLD/i',
                                                                                                     'lookahead' => 0,
                                                                                                     'rdelim' => '/',
                                                                                                     'line' => 286,
                                                                                                     'mod' => 'i',
                                                                                                     'ldelim' => '/'
                                                                                                   }, 'Parse::RecDescent::Token' ),
                                                                                            bless( {
                                                                                                     'pattern' => '(AS)?',
                                                                                                     'hashname' => '__PATTERN2__',
                                                                                                     'description' => '/(AS)?/i',
                                                                                                     'lookahead' => 0,
                                                                                                     'rdelim' => '/',
                                                                                                     'line' => 286,
                                                                                                     'mod' => 'i',
                                                                                                     'ldelim' => '/'
                                                                                                   }, 'Parse::RecDescent::Token' ),
                                                                                            bless( {
                                                                                                     'subrule' => 'correlation_name',
                                                                                                     'matchrule' => 0,
                                                                                                     'implicit' => undef,
                                                                                                     'argcode' => undef,
                                                                                                     'lookahead' => 0,
                                                                                                     'line' => 286
                                                                                                   }, 'Parse::RecDescent::Subrule' ),
                                                                                            bless( {
                                                                                                     'hashname' => '__ACTION1__',
                                                                                                     'lookahead' => 0,
                                                                                                     'line' => 287,
                                                                                                     'code' => '{ $return = join(\' \', @item[1..3] ) }'
                                                                                                   }, 'Parse::RecDescent::Action' )
                                                                                          ],
                                                                               'line' => undef
                                                                             }, 'Parse::RecDescent::Production' ),
                                                                      bless( {
                                                                               'number' => '1',
                                                                               'strcount' => 0,
                                                                               'dircount' => 0,
                                                                               'uncommit' => undef,
                                                                               'error' => undef,
                                                                               'patcount' => 2,
                                                                               'actcount' => 1,
                                                                               'items' => [
                                                                                            bless( {
                                                                                                     'pattern' => 'NEW',
                                                                                                     'hashname' => '__PATTERN1__',
                                                                                                     'description' => '/NEW/i',
                                                                                                     'lookahead' => 0,
                                                                                                     'rdelim' => '/',
                                                                                                     'line' => 288,
                                                                                                     'mod' => 'i',
                                                                                                     'ldelim' => '/'
                                                                                                   }, 'Parse::RecDescent::Token' ),
                                                                                            bless( {
                                                                                                     'pattern' => '(AS)?',
                                                                                                     'hashname' => '__PATTERN2__',
                                                                                                     'description' => '/(AS)?/i',
                                                                                                     'lookahead' => 0,
                                                                                                     'rdelim' => '/',
                                                                                                     'line' => 288,
                                                                                                     'mod' => 'i',
                                                                                                     'ldelim' => '/'
                                                                                                   }, 'Parse::RecDescent::Token' ),
                                                                                            bless( {
                                                                                                     'subrule' => 'correlation_name',
                                                                                                     'matchrule' => 0,
                                                                                                     'implicit' => undef,
                                                                                                     'argcode' => undef,
                                                                                                     'lookahead' => 0,
                                                                                                     'line' => 288
                                                                                                   }, 'Parse::RecDescent::Subrule' ),
                                                                                            bless( {
                                                                                                     'hashname' => '__ACTION1__',
                                                                                                     'lookahead' => 0,
                                                                                                     'line' => 289,
                                                                                                     'code' => '{ $return = join(\' \', @item[1..3] ) }'
                                                                                                   }, 'Parse::RecDescent::Action' )
                                                                                          ],
                                                                               'line' => 288
                                                                             }, 'Parse::RecDescent::Production' )
                                                                    ],
                                                         'name' => 'old_new_corr',
                                                         'vars' => '',
                                                         'line' => 286
                                                       }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_42_of_rule_sysibm_function' => bless( {
                                                                                                    'impcount' => 0,
                                                                                                    'calls' => [],
                                                                                                    'changed' => 0,
                                                                                                    'opcount' => 0,
                                                                                                    'prods' => [
                                                                                                                 bless( {
                                                                                                                          'number' => '0',
                                                                                                                          'strcount' => 0,
                                                                                                                          'dircount' => 0,
                                                                                                                          'uncommit' => undef,
                                                                                                                          'error' => undef,
                                                                                                                          'patcount' => 1,
                                                                                                                          'actcount' => 0,
                                                                                                                          'items' => [
                                                                                                                                       bless( {
                                                                                                                                                'pattern' => 'LCASE',
                                                                                                                                                'hashname' => '__PATTERN1__',
                                                                                                                                                'description' => '/LCASE/i',
                                                                                                                                                'lookahead' => 0,
                                                                                                                                                'rdelim' => '/',
                                                                                                                                                'line' => 628,
                                                                                                                                                'mod' => 'i',
                                                                                                                                                'ldelim' => '/'
                                                                                                                                              }, 'Parse::RecDescent::Token' )
                                                                                                                                     ],
                                                                                                                          'line' => undef
                                                                                                                        }, 'Parse::RecDescent::Production' ),
                                                                                                                 bless( {
                                                                                                                          'number' => '1',
                                                                                                                          'strcount' => 0,
                                                                                                                          'dircount' => 0,
                                                                                                                          'uncommit' => undef,
                                                                                                                          'error' => undef,
                                                                                                                          'patcount' => 1,
                                                                                                                          'actcount' => 0,
                                                                                                                          'items' => [
                                                                                                                                       bless( {
                                                                                                                                                'pattern' => 'LOWER',
                                                                                                                                                'hashname' => '__PATTERN1__',
                                                                                                                                                'description' => '/LOWER/',
                                                                                                                                                'lookahead' => 0,
                                                                                                                                                'rdelim' => '/',
                                                                                                                                                'line' => 628,
                                                                                                                                                'mod' => '',
                                                                                                                                                'ldelim' => '/'
                                                                                                                                              }, 'Parse::RecDescent::Token' )
                                                                                                                                     ],
                                                                                                                          'line' => 628
                                                                                                                        }, 'Parse::RecDescent::Production' )
                                                                                                               ],
                                                                                                    'name' => '_alternation_1_of_production_42_of_rule_sysibm_function',
                                                                                                    'vars' => '',
                                                                                                    'line' => 628
                                                                                                  }, 'Parse::RecDescent::Rule' ),
                              'subtype_treatment' => bless( {
                                                              'impcount' => 0,
                                                              'calls' => [
                                                                           'expression',
                                                                           'data_type'
                                                                         ],
                                                              'changed' => 0,
                                                              'opcount' => 0,
                                                              'prods' => [
                                                                           bless( {
                                                                                    'number' => '0',
                                                                                    'strcount' => 2,
                                                                                    'dircount' => 0,
                                                                                    'uncommit' => undef,
                                                                                    'error' => undef,
                                                                                    'patcount' => 2,
                                                                                    'actcount' => 0,
                                                                                    'items' => [
                                                                                                 bless( {
                                                                                                          'pattern' => 'TREAT',
                                                                                                          'hashname' => '__PATTERN1__',
                                                                                                          'description' => '/TREAT/i',
                                                                                                          'lookahead' => 0,
                                                                                                          'rdelim' => '/',
                                                                                                          'line' => 606,
                                                                                                          'mod' => 'i',
                                                                                                          'ldelim' => '/'
                                                                                                        }, 'Parse::RecDescent::Token' ),
                                                                                                 bless( {
                                                                                                          'pattern' => '(',
                                                                                                          'hashname' => '__STRING1__',
                                                                                                          'description' => '\'(\'',
                                                                                                          'lookahead' => 0,
                                                                                                          'line' => 606
                                                                                                        }, 'Parse::RecDescent::Literal' ),
                                                                                                 bless( {
                                                                                                          'subrule' => 'expression',
                                                                                                          'matchrule' => 0,
                                                                                                          'implicit' => undef,
                                                                                                          'argcode' => undef,
                                                                                                          'lookahead' => 0,
                                                                                                          'line' => 606
                                                                                                        }, 'Parse::RecDescent::Subrule' ),
                                                                                                 bless( {
                                                                                                          'pattern' => 'AS',
                                                                                                          'hashname' => '__PATTERN2__',
                                                                                                          'description' => '/AS/i',
                                                                                                          'lookahead' => 0,
                                                                                                          'rdelim' => '/',
                                                                                                          'line' => 606,
                                                                                                          'mod' => 'i',
                                                                                                          'ldelim' => '/'
                                                                                                        }, 'Parse::RecDescent::Token' ),
                                                                                                 bless( {
                                                                                                          'subrule' => 'data_type',
                                                                                                          'matchrule' => 0,
                                                                                                          'implicit' => undef,
                                                                                                          'argcode' => undef,
                                                                                                          'lookahead' => 0,
                                                                                                          'line' => 606
                                                                                                        }, 'Parse::RecDescent::Subrule' ),
                                                                                                 bless( {
                                                                                                          'pattern' => ')',
                                                                                                          'hashname' => '__STRING2__',
                                                                                                          'description' => '\')\'',
                                                                                                          'lookahead' => 0,
                                                                                                          'line' => 606
                                                                                                        }, 'Parse::RecDescent::Literal' )
                                                                                               ],
                                                                                    'line' => undef
                                                                                  }, 'Parse::RecDescent::Production' )
                                                                         ],
                                                              'name' => 'subtype_treatment',
                                                              'vars' => '',
                                                              'line' => 606
                                                            }, 'Parse::RecDescent::Rule' ),
                              'expression' => bless( {
                                                       'impcount' => 1,
                                                       'calls' => [
                                                                    '_alternation_1_of_production_1_of_rule_expression'
                                                                  ],
                                                       'changed' => 0,
                                                       'opcount' => 0,
                                                       'prods' => [
                                                                    bless( {
                                                                             'number' => '0',
                                                                             'strcount' => 0,
                                                                             'dircount' => 1,
                                                                             'uncommit' => undef,
                                                                             'error' => undef,
                                                                             'patcount' => 1,
                                                                             'actcount' => 0,
                                                                             'op' => [],
                                                                             'items' => [
                                                                                          bless( {
                                                                                                   'expected' => '<leftop: \'+\', or \'-\' /operator/ \'+\', or \'-\'>',
                                                                                                   'min' => 1,
                                                                                                   'name' => '\'_alternation_1_of_production_1_of_rule_expression(s)\'',
                                                                                                   'max' => 100000000,
                                                                                                   'leftarg' => bless( {
                                                                                                                         'subrule' => '_alternation_1_of_production_1_of_rule_expression',
                                                                                                                         'matchrule' => 0,
                                                                                                                         'implicit' => '\'+\', or \'-\'',
                                                                                                                         'argcode' => undef,
                                                                                                                         'lookahead' => 0,
                                                                                                                         'line' => 319
                                                                                                                       }, 'Parse::RecDescent::Subrule' ),
                                                                                                   'rightarg' => bless( {
                                                                                                                          'subrule' => '_alternation_1_of_production_1_of_rule_expression',
                                                                                                                          'matchrule' => 0,
                                                                                                                          'implicit' => '\'+\', or \'-\'',
                                                                                                                          'argcode' => undef,
                                                                                                                          'lookahead' => 0,
                                                                                                                          'line' => 319
                                                                                                                        }, 'Parse::RecDescent::Subrule' ),
                                                                                                   'hashname' => '__DIRECTIVE1__',
                                                                                                   'type' => 'leftop',
                                                                                                   'op' => bless( {
                                                                                                                    'pattern' => 'operator',
                                                                                                                    'hashname' => '__PATTERN1__',
                                                                                                                    'description' => '/operator/',
                                                                                                                    'lookahead' => 0,
                                                                                                                    'rdelim' => '/',
                                                                                                                    'line' => 319,
                                                                                                                    'mod' => '',
                                                                                                                    'ldelim' => '/'
                                                                                                                  }, 'Parse::RecDescent::Token' )
                                                                                                 }, 'Parse::RecDescent::Operator' )
                                                                                        ],
                                                                             'line' => undef
                                                                           }, 'Parse::RecDescent::Production' )
                                                                  ],
                                                       'name' => 'expression',
                                                       'vars' => '',
                                                       'line' => 299
                                                     }, 'Parse::RecDescent::Rule' ),
                              '_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression' => bless( {
                                                                                                                                     'impcount' => 0,
                                                                                                                                     'calls' => [
                                                                                                                                                  'function',
                                                                                                                                                  'expression',
                                                                                                                                                  'constant',
                                                                                                                                                  'column_name',
                                                                                                                                                  'host_variable',
                                                                                                                                                  'special_register',
                                                                                                                                                  'scalar_fullselect',
                                                                                                                                                  'labeled_duration',
                                                                                                                                                  'case_expression',
                                                                                                                                                  'cast_specification',
                                                                                                                                                  'OLAP_function',
                                                                                                                                                  'method_invocation',
                                                                                                                                                  'subtype_treatment',
                                                                                                                                                  'sequence_reference'
                                                                                                                                                ],
                                                                                                                                     'changed' => 0,
                                                                                                                                     'opcount' => 0,
                                                                                                                                     'prods' => [
                                                                                                                                                  bless( {
                                                                                                                                                           'number' => '0',
                                                                                                                                                           'strcount' => 0,
                                                                                                                                                           'dircount' => 0,
                                                                                                                                                           'uncommit' => undef,
                                                                                                                                                           'error' => undef,
                                                                                                                                                           'patcount' => 0,
                                                                                                                                                           'actcount' => 0,
                                                                                                                                                           'items' => [
                                                                                                                                                                        bless( {
                                                                                                                                                                                 'subrule' => 'function',
                                                                                                                                                                                 'matchrule' => 0,
                                                                                                                                                                                 'implicit' => undef,
                                                                                                                                                                                 'argcode' => undef,
                                                                                                                                                                                 'lookahead' => 0,
                                                                                                                                                                                 'line' => 613
                                                                                                                                                                               }, 'Parse::RecDescent::Subrule' )
                                                                                                                                                                      ],
                                                                                                                                                           'line' => undef
                                                                                                                                                         }, 'Parse::RecDescent::Production' ),
                                                                                                                                                  bless( {
                                                                                                                                                           'number' => '1',
                                                                                                                                                           'strcount' => 2,
                                                                                                                                                           'dircount' => 0,
                                                                                                                                                           'uncommit' => undef,
                                                                                                                                                           'error' => undef,
                                                                                                                                                           'patcount' => 0,
                                                                                                                                                           'actcount' => 0,
                                                                                                                                                           'items' => [
                                                                                                                                                                        bless( {
                                                                                                                                                                                 'pattern' => '(',
                                                                                                                                                                                 'hashname' => '__STRING1__',
                                                                                                                                                                                 'description' => '\'(\'',
                                                                                                                                                                                 'lookahead' => 0,
                                                                                                                                                                                 'line' => 614
                                                                                                                                                                               }, 'Parse::RecDescent::Literal' ),
                                                                                                                                                                        bless( {
                                                                                                                                                                                 'subrule' => 'expression',
                                                                                                                                                                                 'matchrule' => 0,
                                                                                                                                                                                 'implicit' => undef,
                                                                                                                                                                                 'argcode' => undef,
                                                                                                                                                                                 'lookahead' => 0,
                                                                                                                                                                                 'line' => 614
                                                                                                                                                                               }, 'Parse::RecDescent::Subrule' ),
                                                                                                                                                                        bless( {
                                                                                                                                                                                 'pattern' => ')',
                                                                                                                                                                                 'hashname' => '__STRING2__',
                                                                                                                                                                                 'description' => '\')\'',
                                                                                                                                                                                 'lookahead' => 0,
                                                                                                                                                                                 'line' => 614
                                                                                                                                                                               }, 'Parse::RecDescent::Literal' )
                                                                                                                                                                      ],
                                                                                                                                                           'line' => 614
                                                                                                                                                         }, 'Parse::RecDescent::Production' ),
                                                                                                                                                  bless( {
                                                                                                                                                           'number' => '2',
                                                                                                                                                           'strcount' => 0,
                                                                                                                                                           'dircount' => 0,
                                                                                                                                                           'uncommit' => undef,
                                                                                                                                                           'error' => undef,
                                                                                                                                                           'patcount' => 0,
                                                                                                                                                           'actcount' => 0,
                                                                                                                                                           'items' => [
                                                                                                                                                                        bless( {
                                                                                                                                                                                 'subrule' => 'constant',
                                                                                                                                                                                 'matchrule' => 0,
                                                                                                                                                                                 'implicit' => undef,
                                                                                                                                                                                 'argcode' => undef,
                                                                                                                                                                                 'lookahead' => 0,
                                                                                                                                                                                 'line' => 615
                                                                                                                                                                               }, 'Parse::RecDescent::Subrule' )
                                                                                                                                                                      ],
                                                                                                                                                           'line' => 615
                                                                                                                                                         }, 'Parse::RecDescent::Production' ),
                                                                                                                                                  bless( {
                                                                                                                                                           'number' => '3',
                                                                                                                                                           'strcount' => 0,
                                                                                                                                                           'dircount' => 0,
                                                                                                                                                           'uncommit' => undef,
                                                                                                                                                           'error' => undef,
                                                                                                                                                           'patcount' => 0,
                                                                                                                                                           'actcount' => 0,
                                                                                                                                                           'items' => [
                                                                                                                                                                        bless( {
                                                                                                                                                                                 'subrule' => 'column_name',
                                                                                                                                                                                 'matchrule' => 0,
                                                                                                                                                                                 'implicit' => undef,
                                                                                                                                                                                 'argcode' => undef,
                                                                                                                                                                                 'lookahead' => 0,
                                                                                                                                                                                 'line' => 616
                                                                                                                                                                               }, 'Parse::RecDescent::Subrule' )
                                                                                                                                                                      ],
                                                                                                                                                           'line' => 616
                                                                                                                                                         }, 'Parse::RecDescent::Production' ),
                                                                                                                                                  bless( {
                                                                                                                                                           'number' => '4',
                                                                                                                                                           'strcount' => 0,
                                                                                                                                                           'dircount' => 0,
                                                                                                                                                           'uncommit' => undef,
                                                                                                                                                           'error' => undef,
                                                                                                                                                           'patcount' => 0,
                                                                                                                                                           'actcount' => 0,
                                                                                                                                                           'items' => [
                                                                                                                                                                        bless( {
                                                                                                                                                                                 'subrule' => 'host_variable',
                                                                                                                                                                                 'matchrule' => 0,
                                                                                                                                                                                 'implicit' => undef,
                                                                                                                                                                                 'argcode' => undef,
                                                                                                                                                                                 'lookahead' => 0,
                                                                                                                                                                                 'line' => 617
                                                                                                                                                                               }, 'Parse::RecDescent::Subrule' )
                                                                                                                                                                      ],
                                                                                                                                                           'line' => 617
                                                                                                                                                         }, 'Parse::RecDescent::Production' ),
                                                                                                                                                  bless( {
                                                                                                                                                           'number' => '5',
                                                                                                                                                           'strcount' => 0,
                                                                                                                                                           'dircount' => 0,
                                                                                                                                                           'uncommit' => undef,
                                                                                                                                                           'error' => undef,
                                                                                                                                                           'patcount' => 0,
                                                                                                                                                           'actcount' => 0,
                                                                                                                                                           'items' => [
                                                                                                                                                                        bless( {
                                                                                                                                                                                 'subrule' => 'special_register',
                                                                                                                                                                                 'matchrule' => 0,
                                                                                                                                                                                 'implicit' => undef,
                                                                                                                                                                                 'argcode' => undef,
                                                                                                                                                                                 'lookahead' => 0,
                                                                                                                                                                                 'line' => 618
                                                                                                                                                                               }, 'Parse::RecDescent::Subrule' )
                                                                                                                                                                      ],
                                                                                                                                                           'line' => 618
                                                                                                                                                         }, 'Parse::RecDescent::Production' ),
                                                                                                                                                  bless( {
                                                                                                                                                           'number' => '6',
                                                                                                                                                           'strcount' => 2,
                                                                                                                                                           'dircount' => 0,
                                                                                                                                                           'uncommit' => undef,
                                                                                                                                                           'error' => undef,
                                                                                                                                                           'patcount' => 0,
                                                                                                                                                           'actcount' => 0,
                                                                                                                                                           'items' => [
                                                                                                                                                                        bless( {
                                                                                                                                                                                 'pattern' => '(',
                                                                                                                                                                                 'hashname' => '__STRING1__',
                                                                                                                                                                                 'description' => '\'(\'',
                                                                                                                                                                                 'lookahead' => 0,
                                                                                                                                                                                 'line' => 619
                                                                                                                                                                               }, 'Parse::RecDescent::Literal' ),
                                                                                                                                                                        bless( {
                                                                                                                                                                                 'subrule' => 'scalar_fullselect',
                                                                                                                                                                                 'matchrule' => 0,
                                                                                                                                                                                 'implicit' => undef,
                                                                                                                                                                                 'argcode' => undef,
                                                                                                                                                                                 'lookahead' => 0,
                                                                                                                                                                                 'line' => 619
                                                                                                                                                                               }, 'Parse::RecDescent::Subrule' ),
                                                                                                                                                                        bless( {
                                                                                                                                                                                 'pattern' => ')',
                                                                                                                                                                                 'hashname' => '__STRING2__',
                                                                                                                                                                                 'description' => '\')\'',
                                                                                                                                                                                 'lookahead' => 0,
                                                                                                                                                                                 'line' => 619
                                                                                                                                                                               }, 'Parse::RecDescent::Literal' )
                                                                                                                                                                      ],
                                                                                                                                                           'line' => 619
                                                                                                                                                         }, 'Parse::RecDescent::Production' ),
                                                                                                                                                  bless( {
                                                                                                                                                           'number' => '7',
                                                                                                                                                           'strcount' => 0,
                                                                                                                                                           'dircount' => 0,
                                                                                                                                                           'uncommit' => undef,
                                                                                                                                                           'error' => undef,
                                                                                                                                                           'patcount' => 0,
                                                                                                                                                           'actcount' => 0,
                                                                                                                                                           'items' => [
                                                                                                                                                                        bless( {
                                                                                                                                                                                 'subrule' => 'labeled_duration',
                                                                                                                                                                                 'matchrule' => 0,
                                                                                                                                                                                 'implicit' => undef,
                                                                                                                                                                                 'argcode' => undef,
                                                                                                                                                                                 'lookahead' => 0,
                                                                                                                                                                                 'line' => 620
                                                                                                                                                                               }, 'Parse::RecDescent::Subrule' )
                                                                                                                                                                      ],
                                                                                                                                                           'line' => 620
                                                                                                                                                         }, 'Parse::RecDescent::Production' ),
                                                                                                                                                  bless( {
                                                                                                                                                           'number' => '8',
                                                                                                                                                           'strcount' => 0,
                                                                                                                                                           'dircount' => 0,
                                                                                                                                                           'uncommit' => undef,
                                                                                                                                                           'error' => undef,
                                                                                                                                                           'patcount' => 0,
                                                                                                                                                           'actcount' => 0,
                                                                                                                                                           'items' => [
                                                                                                                                                                        bless( {
                                                                                                                                                                                 'subrule' => 'case_expression',
                                                                                                                                                                                 'matchrule' => 0,
                                                                                                                                                                                 'implicit' => undef,
                                                                                                                                                                                 'argcode' => undef,
                                                                                                                                                                                 'lookahead' => 0,
                                                                                                                                                                                 'line' => 621
                                                                                                                                                                               }, 'Parse::RecDescent::Subrule' )
                                                                                                                                                                      ],
                                                                                                                                                           'line' => 621
                                                                                                                                                         }, 'Parse::RecDescent::Production' ),
                                                                                                                                                  bless( {
                                                                                                                                                           'number' => '9',
                                                                                                                                                           'strcount' => 0,
                                                                                                                                                           'dircount' => 0,
                                                                                                                                                           'uncommit' => undef,
                                                                                                                                                           'error' => undef,
                                                                                                                                                           'patcount' => 0,
                                                                                                                                                           'actcount' => 0,
                                                                                                                                                           'items' => [
                                                                                                                                                                        bless( {
                                                                                                                                                                                 'subrule' => 'cast_specification',
                                                                                                                                                                                 'matchrule' => 0,
                                                                                                                                                                                 'implicit' => undef,
                                                                                                                                                                                 'argcode' => undef,
                                                                                                                                                                                 'lookahead' => 0,
                                                                                                                                                                                 'line' => 622
                                                                                                                                                                               }, 'Parse::RecDescent::Subrule' )
                                                                                                                                                                      ],
                                                                                                                                                           'line' => 622
                                                                                                                                                         }, 'Parse::RecDescent::Production' ),
                                                                                                                                                  bless( {
                                                                                                                                                           'number' => '10',
                                                                                                                                                           'strcount' => 0,
                                                                                                                                                           'dircount' => 0,
                                                                                                                                                           'uncommit' => undef,
                                                                                                                                                           'error' => undef,
                                                                                                                                                           'patcount' => 0,
                                                                                                                                                           'actcount' => 0,
                                                                                                                                                           'items' => [
                                                                                                                                                                        bless( {
                                                                                                                                                                                 'subrule' => 'OLAP_function',
                                                                                                                                                                                 'matchrule' => 0,
                                                                                                                                                                                 'implicit' => undef,
                                                                                                                                                                                 'argcode' => undef,
                                                                                                                                                                                 'lookahead' => 0,
                                                                                                                                                                                 'line' => 624
                                                                                                                                                                               }, 'Parse::RecDescent::Subrule' )
                                                                                                                                                                      ],
                                                                                                                                                           'line' => 623
                                                                                                                                                         }, 'Parse::RecDescent::Production' ),
                                                                                                                                                  bless( {
                                                                                                                                                           'number' => '11',
                                                                                                                                                           'strcount' => 0,
                                                                                                                                                           'dircount' => 0,
                                                                                                                                                           'uncommit' => undef,
                                                                                                                                                           'error' => undef,
                                                                                                                                                           'patcount' => 0,
                                                                                                                                                           'actcount' => 0,
                                                                                                                                                           'items' => [
                                                                                                                                                                        bless( {
                                                                                                                                                                                 'subrule' => 'method_invocation',
                                                                                                                                                                                 'matchrule' => 0,
                                                                                                                                                                                 'implicit' => undef,
                                                                                                                                                                                 'argcode' => undef,
                                                                                                                                                                                 'lookahead' => 0,
                                                                                                                                                                                 'line' => 625
                                                                                                                                                                               }, 'Parse::RecDescent::Subrule' )
                                                                                                                                                                      ],
                                                                                                                                                           'line' => 625
                                                                                                                                                         }, 'Parse::RecDescent::Production' ),
                                                                                                                                                  bless( {
                                                                                                                                                           'number' => '12',
                                                                                                                                                           'strcount' => 0,
                                                                                                                                                           'dircount' => 0,
                                                                                                                                                           'uncommit' => undef,
                                                                                                                                                           'error' => undef,
                                                                                                                                                           'patcount' => 0,
                                                                                                                                                           'actcount' => 0,
                                                                                                                                                           'items' => [
                                                                                                                                                                        bless( {
                                                                                                                                                                                 'subrule' => 'subtype_treatment',
                                                                                                                                                                                 'matchrule' => 0,
                                                                                                                                                                                 'implicit' => undef,
                                                                                                                                                                                 'argcode' => undef,
                                                                                                                                                                                 'lookahead' => 0,
                                                                                                                                                                                 'line' => 626
                                                                                                                                                                               }, 'Parse::RecDescent::Subrule' )
                                                                                                                                                                      ],
                                                                                                                                                           'line' => 626
                                                                                                                                                         }, 'Parse::RecDescent::Production' ),
                                                                                                                                                  bless( {
                                                                                                                                                           'number' => '13',
                                                                                                                                                           'strcount' => 0,
                                                                                                                                                           'dircount' => 0,
                                                                                                                                                           'uncommit' => undef,
                                                                                                                                                           'error' => undef,
                                                                                                                                                           'patcount' => 0,
                                                                                                                                                           'actcount' => 0,
                                                                                                                                                           'items' => [
                                                                                                                                                                        bless( {
                                                                                                                                                                                 'subrule' => 'sequence_reference',
                                                                                                                                                                                 'matchrule' => 0,
                                                                                                                                                                                 'implicit' => undef,
                                                                                                                                                                                 'argcode' => undef,
                                                                                                                                                                                 'lookahead' => 0,
                                                                                                                                                                                 'line' => 627
                                                                                                                                                                               }, 'Parse::RecDescent::Subrule' )
                                                                                                                                                                      ],
                                                                                                                                                           'line' => 627
                                                                                                                                                         }, 'Parse::RecDescent::Production' )
                                                                                                                                                ],
                                                                                                                                     'name' => '_alternation_2_of_production_1_of_rule__alternation_1_of_production_1_of_rule_expression',
                                                                                                                                     'vars' => '',
                                                                                                                                     'line' => 613
                                                                                                                                   }, 'Parse::RecDescent::Rule' ),
                              'startrule' => bless( {
                                                      'impcount' => 0,
                                                      'calls' => [
                                                                   'statement',
                                                                   'eofile'
                                                                 ],
                                                      'changed' => 0,
                                                      'opcount' => 0,
                                                      'prods' => [
                                                                   bless( {
                                                                            'number' => '0',
                                                                            'strcount' => 0,
                                                                            'dircount' => 0,
                                                                            'uncommit' => undef,
                                                                            'error' => undef,
                                                                            'patcount' => 0,
                                                                            'actcount' => 1,
                                                                            'items' => [
                                                                                         bless( {
                                                                                                  'subrule' => 'statement',
                                                                                                  'expected' => undef,
                                                                                                  'min' => 1,
                                                                                                  'argcode' => undef,
                                                                                                  'max' => 100000000,
                                                                                                  'matchrule' => 0,
                                                                                                  'repspec' => 's',
                                                                                                  'lookahead' => 0,
                                                                                                  'line' => 12
                                                                                                }, 'Parse::RecDescent::Repetition' ),
                                                                                         bless( {
                                                                                                  'subrule' => 'eofile',
                                                                                                  'matchrule' => 0,
                                                                                                  'implicit' => undef,
                                                                                                  'argcode' => undef,
                                                                                                  'lookahead' => 0,
                                                                                                  'line' => 12
                                                                                                }, 'Parse::RecDescent::Subrule' ),
                                                                                         bless( {
                                                                                                  'hashname' => '__ACTION1__',
                                                                                                  'lookahead' => 0,
                                                                                                  'line' => 12,
                                                                                                  'code' => '{
    $return      = {
        tables   => \\%tables,
        views    => \\@views,
        triggers => \\@triggers,
    }
}'
                                                                                                }, 'Parse::RecDescent::Action' )
                                                                                       ],
                                                                            'line' => undef
                                                                          }, 'Parse::RecDescent::Production' )
                                                                 ],
                                                      'name' => 'startrule',
                                                      'vars' => '',
                                                      'line' => 11
                                                    }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule_cast_specification' => bless( {
                                                                                                      'impcount' => 0,
                                                                                                      'calls' => [
                                                                                                                   'expression',
                                                                                                                   'parameter_marker'
                                                                                                                 ],
                                                                                                      'changed' => 0,
                                                                                                      'opcount' => 0,
                                                                                                      'prods' => [
                                                                                                                   bless( {
                                                                                                                            'number' => '0',
                                                                                                                            'strcount' => 0,
                                                                                                                            'dircount' => 0,
                                                                                                                            'uncommit' => undef,
                                                                                                                            'error' => undef,
                                                                                                                            'patcount' => 0,
                                                                                                                            'actcount' => 0,
                                                                                                                            'items' => [
                                                                                                                                         bless( {
                                                                                                                                                  'subrule' => 'expression',
                                                                                                                                                  'matchrule' => 0,
                                                                                                                                                  'implicit' => undef,
                                                                                                                                                  'argcode' => undef,
                                                                                                                                                  'lookahead' => 0,
                                                                                                                                                  'line' => 625
                                                                                                                                                }, 'Parse::RecDescent::Subrule' )
                                                                                                                                       ],
                                                                                                                            'line' => undef
                                                                                                                          }, 'Parse::RecDescent::Production' ),
                                                                                                                   bless( {
                                                                                                                            'number' => '1',
                                                                                                                            'strcount' => 0,
                                                                                                                            'dircount' => 0,
                                                                                                                            'uncommit' => undef,
                                                                                                                            'error' => undef,
                                                                                                                            'patcount' => 1,
                                                                                                                            'actcount' => 0,
                                                                                                                            'items' => [
                                                                                                                                         bless( {
                                                                                                                                                  'pattern' => 'NULL',
                                                                                                                                                  'hashname' => '__PATTERN1__',
                                                                                                                                                  'description' => '/NULL/i',
                                                                                                                                                  'lookahead' => 0,
                                                                                                                                                  'rdelim' => '/',
                                                                                                                                                  'line' => 626,
                                                                                                                                                  'mod' => 'i',
                                                                                                                                                  'ldelim' => '/'
                                                                                                                                                }, 'Parse::RecDescent::Token' )
                                                                                                                                       ],
                                                                                                                            'line' => 626
                                                                                                                          }, 'Parse::RecDescent::Production' ),
                                                                                                                   bless( {
                                                                                                                            'number' => '2',
                                                                                                                            'strcount' => 0,
                                                                                                                            'dircount' => 0,
                                                                                                                            'uncommit' => undef,
                                                                                                                            'error' => undef,
                                                                                                                            'patcount' => 0,
                                                                                                                            'actcount' => 0,
                                                                                                                            'items' => [
                                                                                                                                         bless( {
                                                                                                                                                  'subrule' => 'parameter_marker',
                                                                                                                                                  'matchrule' => 0,
                                                                                                                                                  'implicit' => undef,
                                                                                                                                                  'argcode' => undef,
                                                                                                                                                  'lookahead' => 0,
                                                                                                                                                  'line' => 627
                                                                                                                                                }, 'Parse::RecDescent::Subrule' )
                                                                                                                                       ],
                                                                                                                            'line' => 627
                                                                                                                          }, 'Parse::RecDescent::Production' )
                                                                                                                 ],
                                                                                                      'name' => '_alternation_1_of_production_1_of_rule_cast_specification',
                                                                                                      'vars' => '',
                                                                                                      'line' => 625
                                                                                                    }, 'Parse::RecDescent::Rule' ),
                              'before' => bless( {
                                                   'impcount' => 0,
                                                   'calls' => [],
                                                   'changed' => 0,
                                                   'opcount' => 0,
                                                   'prods' => [
                                                                bless( {
                                                                         'number' => '0',
                                                                         'strcount' => 0,
                                                                         'dircount' => 0,
                                                                         'uncommit' => undef,
                                                                         'error' => undef,
                                                                         'patcount' => 1,
                                                                         'actcount' => 0,
                                                                         'items' => [
                                                                                      bless( {
                                                                                               'pattern' => 'NO CASCADE BEFORE',
                                                                                               'hashname' => '__PATTERN1__',
                                                                                               'description' => '/NO CASCADE BEFORE/i',
                                                                                               'lookahead' => 0,
                                                                                               'rdelim' => '/',
                                                                                               'line' => 268,
                                                                                               'mod' => 'i',
                                                                                               'ldelim' => '/'
                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                    ],
                                                                         'line' => undef
                                                                       }, 'Parse::RecDescent::Production' )
                                                              ],
                                                   'name' => 'before',
                                                   'vars' => '',
                                                   'line' => 268
                                                 }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_83_of_rule_sysibm_function' => bless( {
                                                                                                    'impcount' => 0,
                                                                                                    'calls' => [],
                                                                                                    'changed' => 0,
                                                                                                    'opcount' => 0,
                                                                                                    'prods' => [
                                                                                                                 bless( {
                                                                                                                          'number' => '0',
                                                                                                                          'strcount' => 0,
                                                                                                                          'dircount' => 0,
                                                                                                                          'uncommit' => undef,
                                                                                                                          'error' => undef,
                                                                                                                          'patcount' => 1,
                                                                                                                          'actcount' => 0,
                                                                                                                          'items' => [
                                                                                                                                       bless( {
                                                                                                                                                'pattern' => 'UCASE',
                                                                                                                                                'hashname' => '__PATTERN1__',
                                                                                                                                                'description' => '/UCASE/i',
                                                                                                                                                'lookahead' => 0,
                                                                                                                                                'rdelim' => '/',
                                                                                                                                                'line' => 628,
                                                                                                                                                'mod' => 'i',
                                                                                                                                                'ldelim' => '/'
                                                                                                                                              }, 'Parse::RecDescent::Token' )
                                                                                                                                     ],
                                                                                                                          'line' => undef
                                                                                                                        }, 'Parse::RecDescent::Production' ),
                                                                                                                 bless( {
                                                                                                                          'number' => '1',
                                                                                                                          'strcount' => 0,
                                                                                                                          'dircount' => 0,
                                                                                                                          'uncommit' => undef,
                                                                                                                          'error' => undef,
                                                                                                                          'patcount' => 1,
                                                                                                                          'actcount' => 0,
                                                                                                                          'items' => [
                                                                                                                                       bless( {
                                                                                                                                                'pattern' => 'UPPER',
                                                                                                                                                'hashname' => '__PATTERN1__',
                                                                                                                                                'description' => '/UPPER/i',
                                                                                                                                                'lookahead' => 0,
                                                                                                                                                'rdelim' => '/',
                                                                                                                                                'line' => 628,
                                                                                                                                                'mod' => 'i',
                                                                                                                                                'ldelim' => '/'
                                                                                                                                              }, 'Parse::RecDescent::Token' )
                                                                                                                                     ],
                                                                                                                          'line' => 628
                                                                                                                        }, 'Parse::RecDescent::Production' )
                                                                                                               ],
                                                                                                    'name' => '_alternation_1_of_production_83_of_rule_sysibm_function',
                                                                                                    'vars' => '',
                                                                                                    'line' => 628
                                                                                                  }, 'Parse::RecDescent::Rule' ),
                              'ranking_function' => bless( {
                                                             'impcount' => 1,
                                                             'calls' => [
                                                                          '_alternation_1_of_production_1_of_rule_ranking_function',
                                                                          'window_partition_clause',
                                                                          'window_order_clause'
                                                                        ],
                                                             'changed' => 0,
                                                             'opcount' => 0,
                                                             'prods' => [
                                                                          bless( {
                                                                                   'number' => '0',
                                                                                   'strcount' => 2,
                                                                                   'dircount' => 0,
                                                                                   'uncommit' => undef,
                                                                                   'error' => undef,
                                                                                   'patcount' => 1,
                                                                                   'actcount' => 0,
                                                                                   'items' => [
                                                                                                bless( {
                                                                                                         'subrule' => '_alternation_1_of_production_1_of_rule_ranking_function',
                                                                                                         'matchrule' => 0,
                                                                                                         'implicit' => '/RANK/, or /DENSE_RANK|DENSERANK/i',
                                                                                                         'argcode' => undef,
                                                                                                         'lookahead' => 0,
                                                                                                         'line' => 544
                                                                                                       }, 'Parse::RecDescent::Subrule' ),
                                                                                                bless( {
                                                                                                         'pattern' => 'OVER',
                                                                                                         'hashname' => '__PATTERN1__',
                                                                                                         'description' => '/OVER/i',
                                                                                                         'lookahead' => 0,
                                                                                                         'rdelim' => '/',
                                                                                                         'line' => 544,
                                                                                                         'mod' => 'i',
                                                                                                         'ldelim' => '/'
                                                                                                       }, 'Parse::RecDescent::Token' ),
                                                                                                bless( {
                                                                                                         'pattern' => '(',
                                                                                                         'hashname' => '__STRING1__',
                                                                                                         'description' => '\'(\'',
                                                                                                         'lookahead' => 0,
                                                                                                         'line' => 544
                                                                                                       }, 'Parse::RecDescent::Literal' ),
                                                                                                bless( {
                                                                                                         'subrule' => 'window_partition_clause',
                                                                                                         'expected' => undef,
                                                                                                         'min' => 0,
                                                                                                         'argcode' => undef,
                                                                                                         'max' => 1,
                                                                                                         'matchrule' => 0,
                                                                                                         'repspec' => '?',
                                                                                                         'lookahead' => 0,
                                                                                                         'line' => 544
                                                                                                       }, 'Parse::RecDescent::Repetition' ),
                                                                                                bless( {
                                                                                                         'subrule' => 'window_order_clause',
                                                                                                         'matchrule' => 0,
                                                                                                         'implicit' => undef,
                                                                                                         'argcode' => undef,
                                                                                                         'lookahead' => 0,
                                                                                                         'line' => 544
                                                                                                       }, 'Parse::RecDescent::Subrule' ),
                                                                                                bless( {
                                                                                                         'pattern' => ')',
                                                                                                         'hashname' => '__STRING2__',
                                                                                                         'description' => '\')\'',
                                                                                                         'lookahead' => 0,
                                                                                                         'line' => 544
                                                                                                       }, 'Parse::RecDescent::Literal' )
                                                                                              ],
                                                                                   'line' => undef
                                                                                 }, 'Parse::RecDescent::Production' )
                                                                        ],
                                                             'name' => 'ranking_function',
                                                             'vars' => '',
                                                             'line' => 542
                                                           }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule__alternation_1_of_production_2_of_rule_search_condition' => bless( {
                                                                                                                                           'impcount' => 0,
                                                                                                                                           'calls' => [
                                                                                                                                                        'numeric_constant'
                                                                                                                                                      ],
                                                                                                                                           'changed' => 0,
                                                                                                                                           'opcount' => 0,
                                                                                                                                           'prods' => [
                                                                                                                                                        bless( {
                                                                                                                                                                 'number' => '0',
                                                                                                                                                                 'strcount' => 0,
                                                                                                                                                                 'dircount' => 0,
                                                                                                                                                                 'uncommit' => undef,
                                                                                                                                                                 'error' => undef,
                                                                                                                                                                 'patcount' => 1,
                                                                                                                                                                 'actcount' => 0,
                                                                                                                                                                 'items' => [
                                                                                                                                                                              bless( {
                                                                                                                                                                                       'pattern' => 'SELECTIVITY',
                                                                                                                                                                                       'hashname' => '__PATTERN1__',
                                                                                                                                                                                       'description' => '/SELECTIVITY/i',
                                                                                                                                                                                       'lookahead' => 0,
                                                                                                                                                                                       'rdelim' => '/',
                                                                                                                                                                                       'line' => 628,
                                                                                                                                                                                       'mod' => 'i',
                                                                                                                                                                                       'ldelim' => '/'
                                                                                                                                                                                     }, 'Parse::RecDescent::Token' ),
                                                                                                                                                                              bless( {
                                                                                                                                                                                       'subrule' => 'numeric_constant',
                                                                                                                                                                                       'matchrule' => 0,
                                                                                                                                                                                       'implicit' => undef,
                                                                                                                                                                                       'argcode' => undef,
                                                                                                                                                                                       'lookahead' => 0,
                                                                                                                                                                                       'line' => 628
                                                                                                                                                                                     }, 'Parse::RecDescent::Subrule' )
                                                                                                                                                                            ],
                                                                                                                                                                 'line' => undef
                                                                                                                                                               }, 'Parse::RecDescent::Production' )
                                                                                                                                                      ],
                                                                                                                                           'name' => '_alternation_1_of_production_1_of_rule__alternation_1_of_production_2_of_rule_search_condition',
                                                                                                                                           'vars' => '',
                                                                                                                                           'line' => 628
                                                                                                                                         }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule_sysibm_function' => bless( {
                                                                                                   'impcount' => 0,
                                                                                                   'calls' => [],
                                                                                                   'changed' => 0,
                                                                                                   'opcount' => 0,
                                                                                                   'prods' => [
                                                                                                                bless( {
                                                                                                                         'number' => '0',
                                                                                                                         'strcount' => 0,
                                                                                                                         'dircount' => 0,
                                                                                                                         'uncommit' => undef,
                                                                                                                         'error' => undef,
                                                                                                                         'patcount' => 1,
                                                                                                                         'actcount' => 0,
                                                                                                                         'items' => [
                                                                                                                                      bless( {
                                                                                                                                               'pattern' => 'ABS',
                                                                                                                                               'hashname' => '__PATTERN1__',
                                                                                                                                               'description' => '/ABS/i',
                                                                                                                                               'lookahead' => 0,
                                                                                                                                               'rdelim' => '/',
                                                                                                                                               'line' => 628,
                                                                                                                                               'mod' => 'i',
                                                                                                                                               'ldelim' => '/'
                                                                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                                                                    ],
                                                                                                                         'line' => undef
                                                                                                                       }, 'Parse::RecDescent::Production' ),
                                                                                                                bless( {
                                                                                                                         'number' => '1',
                                                                                                                         'strcount' => 0,
                                                                                                                         'dircount' => 0,
                                                                                                                         'uncommit' => undef,
                                                                                                                         'error' => undef,
                                                                                                                         'patcount' => 1,
                                                                                                                         'actcount' => 0,
                                                                                                                         'items' => [
                                                                                                                                      bless( {
                                                                                                                                               'pattern' => 'ABSVAL',
                                                                                                                                               'hashname' => '__PATTERN1__',
                                                                                                                                               'description' => '/ABSVAL/i',
                                                                                                                                               'lookahead' => 0,
                                                                                                                                               'rdelim' => '/',
                                                                                                                                               'line' => 628,
                                                                                                                                               'mod' => 'i',
                                                                                                                                               'ldelim' => '/'
                                                                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                                                                    ],
                                                                                                                         'line' => 628
                                                                                                                       }, 'Parse::RecDescent::Production' )
                                                                                                              ],
                                                                                                   'name' => '_alternation_1_of_production_1_of_rule_sysibm_function',
                                                                                                   'vars' => '',
                                                                                                   'line' => 628
                                                                                                 }, 'Parse::RecDescent::Rule' ),
                              'reference_b' => bless( {
                                                        'impcount' => 0,
                                                        'calls' => [
                                                                     'old_new_corr'
                                                                   ],
                                                        'changed' => 0,
                                                        'opcount' => 0,
                                                        'prods' => [
                                                                     bless( {
                                                                              'number' => '0',
                                                                              'strcount' => 0,
                                                                              'dircount' => 0,
                                                                              'uncommit' => undef,
                                                                              'error' => undef,
                                                                              'patcount' => 1,
                                                                              'actcount' => 1,
                                                                              'items' => [
                                                                                           bless( {
                                                                                                    'pattern' => 'REFERENCING',
                                                                                                    'hashname' => '__PATTERN1__',
                                                                                                    'description' => '/REFERENCING/i',
                                                                                                    'lookahead' => 0,
                                                                                                    'rdelim' => '/',
                                                                                                    'line' => 280,
                                                                                                    'mod' => 'i',
                                                                                                    'ldelim' => '/'
                                                                                                  }, 'Parse::RecDescent::Token' ),
                                                                                           bless( {
                                                                                                    'subrule' => 'old_new_corr',
                                                                                                    'expected' => undef,
                                                                                                    'min' => 0,
                                                                                                    'argcode' => undef,
                                                                                                    'max' => 2,
                                                                                                    'matchrule' => 0,
                                                                                                    'repspec' => '0..2',
                                                                                                    'lookahead' => 0,
                                                                                                    'line' => 280
                                                                                                  }, 'Parse::RecDescent::Repetition' ),
                                                                                           bless( {
                                                                                                    'hashname' => '__ACTION1__',
                                                                                                    'lookahead' => 0,
                                                                                                    'line' => 281,
                                                                                                    'code' => '{ $return = join(\' \', $item[1], join(\' \', @{$item[2]}) ) }'
                                                                                                  }, 'Parse::RecDescent::Action' )
                                                                                         ],
                                                                              'line' => undef
                                                                            }, 'Parse::RecDescent::Production' )
                                                                   ],
                                                        'name' => 'reference_b',
                                                        'vars' => '',
                                                        'line' => 280
                                                      }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_1_of_rule_simple_when_clause' => bless( {
                                                                                                      'impcount' => 1,
                                                                                                      'calls' => [
                                                                                                                   'search_condition',
                                                                                                                   '_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_simple_when_clause'
                                                                                                                 ],
                                                                                                      'changed' => 0,
                                                                                                      'opcount' => 0,
                                                                                                      'prods' => [
                                                                                                                   bless( {
                                                                                                                            'number' => '0',
                                                                                                                            'strcount' => 0,
                                                                                                                            'dircount' => 0,
                                                                                                                            'uncommit' => undef,
                                                                                                                            'error' => undef,
                                                                                                                            'patcount' => 2,
                                                                                                                            'actcount' => 0,
                                                                                                                            'items' => [
                                                                                                                                         bless( {
                                                                                                                                                  'pattern' => 'WHEN',
                                                                                                                                                  'hashname' => '__PATTERN1__',
                                                                                                                                                  'description' => '/WHEN/i',
                                                                                                                                                  'lookahead' => 0,
                                                                                                                                                  'rdelim' => '/',
                                                                                                                                                  'line' => 624,
                                                                                                                                                  'mod' => 'i',
                                                                                                                                                  'ldelim' => '/'
                                                                                                                                                }, 'Parse::RecDescent::Token' ),
                                                                                                                                         bless( {
                                                                                                                                                  'subrule' => 'search_condition',
                                                                                                                                                  'matchrule' => 0,
                                                                                                                                                  'implicit' => undef,
                                                                                                                                                  'argcode' => undef,
                                                                                                                                                  'lookahead' => 0,
                                                                                                                                                  'line' => 624
                                                                                                                                                }, 'Parse::RecDescent::Subrule' ),
                                                                                                                                         bless( {
                                                                                                                                                  'pattern' => 'THEN',
                                                                                                                                                  'hashname' => '__PATTERN2__',
                                                                                                                                                  'description' => '/THEN/i',
                                                                                                                                                  'lookahead' => 0,
                                                                                                                                                  'rdelim' => '/',
                                                                                                                                                  'line' => 624,
                                                                                                                                                  'mod' => 'i',
                                                                                                                                                  'ldelim' => '/'
                                                                                                                                                }, 'Parse::RecDescent::Token' ),
                                                                                                                                         bless( {
                                                                                                                                                  'subrule' => '_alternation_1_of_production_1_of_rule__alternation_1_of_production_1_of_rule_simple_when_clause',
                                                                                                                                                  'matchrule' => 0,
                                                                                                                                                  'implicit' => 'result_expression, or /NULL/i',
                                                                                                                                                  'argcode' => undef,
                                                                                                                                                  'lookahead' => 0,
                                                                                                                                                  'line' => 627
                                                                                                                                                }, 'Parse::RecDescent::Subrule' )
                                                                                                                                       ],
                                                                                                                            'line' => undef
                                                                                                                          }, 'Parse::RecDescent::Production' )
                                                                                                                 ],
                                                                                                      'name' => '_alternation_1_of_production_1_of_rule_simple_when_clause',
                                                                                                      'vars' => '',
                                                                                                      'line' => 624
                                                                                                    }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_9_of_rule_sysibm_function' => bless( {
                                                                                                   'impcount' => 0,
                                                                                                   'calls' => [],
                                                                                                   'changed' => 0,
                                                                                                   'opcount' => 0,
                                                                                                   'prods' => [
                                                                                                                bless( {
                                                                                                                         'number' => '0',
                                                                                                                         'strcount' => 0,
                                                                                                                         'dircount' => 0,
                                                                                                                         'uncommit' => undef,
                                                                                                                         'error' => undef,
                                                                                                                         'patcount' => 1,
                                                                                                                         'actcount' => 0,
                                                                                                                         'items' => [
                                                                                                                                      bless( {
                                                                                                                                               'pattern' => 'CORRELATION',
                                                                                                                                               'hashname' => '__PATTERN1__',
                                                                                                                                               'description' => '/CORRELATION/i',
                                                                                                                                               'lookahead' => 0,
                                                                                                                                               'rdelim' => '/',
                                                                                                                                               'line' => 628,
                                                                                                                                               'mod' => 'i',
                                                                                                                                               'ldelim' => '/'
                                                                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                                                                    ],
                                                                                                                         'line' => undef
                                                                                                                       }, 'Parse::RecDescent::Production' ),
                                                                                                                bless( {
                                                                                                                         'number' => '1',
                                                                                                                         'strcount' => 0,
                                                                                                                         'dircount' => 0,
                                                                                                                         'uncommit' => undef,
                                                                                                                         'error' => undef,
                                                                                                                         'patcount' => 1,
                                                                                                                         'actcount' => 0,
                                                                                                                         'items' => [
                                                                                                                                      bless( {
                                                                                                                                               'pattern' => 'CORR',
                                                                                                                                               'hashname' => '__PATTERN1__',
                                                                                                                                               'description' => '/CORR/',
                                                                                                                                               'lookahead' => 0,
                                                                                                                                               'rdelim' => '/',
                                                                                                                                               'line' => 628,
                                                                                                                                               'mod' => '',
                                                                                                                                               'ldelim' => '/'
                                                                                                                                             }, 'Parse::RecDescent::Token' )
                                                                                                                                    ],
                                                                                                                         'line' => 628
                                                                                                                       }, 'Parse::RecDescent::Production' )
                                                                                                              ],
                                                                                                   'name' => '_alternation_1_of_production_9_of_rule_sysibm_function',
                                                                                                   'vars' => '',
                                                                                                   'line' => 628
                                                                                                 }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_7_of_rule_sysfun' => bless( {
                                                                                          'impcount' => 0,
                                                                                          'calls' => [],
                                                                                          'changed' => 0,
                                                                                          'opcount' => 0,
                                                                                          'prods' => [
                                                                                                       bless( {
                                                                                                                'number' => '0',
                                                                                                                'strcount' => 0,
                                                                                                                'dircount' => 0,
                                                                                                                'uncommit' => undef,
                                                                                                                'error' => undef,
                                                                                                                'patcount' => 1,
                                                                                                                'actcount' => 0,
                                                                                                                'items' => [
                                                                                                                             bless( {
                                                                                                                                      'pattern' => 'CEIL',
                                                                                                                                      'hashname' => '__PATTERN1__',
                                                                                                                                      'description' => '/CEIL/i',
                                                                                                                                      'lookahead' => 0,
                                                                                                                                      'rdelim' => '/',
                                                                                                                                      'line' => 628,
                                                                                                                                      'mod' => 'i',
                                                                                                                                      'ldelim' => '/'
                                                                                                                                    }, 'Parse::RecDescent::Token' )
                                                                                                                           ],
                                                                                                                'line' => undef
                                                                                                              }, 'Parse::RecDescent::Production' ),
                                                                                                       bless( {
                                                                                                                'number' => '1',
                                                                                                                'strcount' => 0,
                                                                                                                'dircount' => 0,
                                                                                                                'uncommit' => undef,
                                                                                                                'error' => undef,
                                                                                                                'patcount' => 1,
                                                                                                                'actcount' => 0,
                                                                                                                'items' => [
                                                                                                                             bless( {
                                                                                                                                      'pattern' => 'CEILING',
                                                                                                                                      'hashname' => '__PATTERN1__',
                                                                                                                                      'description' => '/CEILING/i',
                                                                                                                                      'lookahead' => 0,
                                                                                                                                      'rdelim' => '/',
                                                                                                                                      'line' => 628,
                                                                                                                                      'mod' => 'i',
                                                                                                                                      'ldelim' => '/'
                                                                                                                                    }, 'Parse::RecDescent::Token' )
                                                                                                                           ],
                                                                                                                'line' => 628
                                                                                                              }, 'Parse::RecDescent::Production' )
                                                                                                     ],
                                                                                          'name' => '_alternation_1_of_production_7_of_rule_sysfun',
                                                                                          'vars' => '',
                                                                                          'line' => 628
                                                                                        }, 'Parse::RecDescent::Rule' ),
                              'prevval_expression' => bless( {
                                                               'impcount' => 0,
                                                               'calls' => [
                                                                            'sequence_name'
                                                                          ],
                                                               'changed' => 0,
                                                               'opcount' => 0,
                                                               'prods' => [
                                                                            bless( {
                                                                                     'number' => '0',
                                                                                     'strcount' => 0,
                                                                                     'dircount' => 0,
                                                                                     'uncommit' => undef,
                                                                                     'error' => undef,
                                                                                     'patcount' => 1,
                                                                                     'actcount' => 0,
                                                                                     'items' => [
                                                                                                  bless( {
                                                                                                           'pattern' => 'PREVVAL\\s+FOR',
                                                                                                           'hashname' => '__PATTERN1__',
                                                                                                           'description' => '/PREVVAL\\\\s+FOR/i',
                                                                                                           'lookahead' => 0,
                                                                                                           'rdelim' => '/',
                                                                                                           'line' => 613,
                                                                                                           'mod' => 'i',
                                                                                                           'ldelim' => '/'
                                                                                                         }, 'Parse::RecDescent::Token' ),
                                                                                                  bless( {
                                                                                                           'subrule' => 'sequence_name',
                                                                                                           'matchrule' => 0,
                                                                                                           'implicit' => undef,
                                                                                                           'argcode' => undef,
                                                                                                           'lookahead' => 0,
                                                                                                           'line' => 613
                                                                                                         }, 'Parse::RecDescent::Subrule' )
                                                                                                ],
                                                                                     'line' => undef
                                                                                   }, 'Parse::RecDescent::Production' )
                                                                          ],
                                                               'name' => 'prevval_expression',
                                                               'vars' => '',
                                                               'line' => 613
                                                             }, 'Parse::RecDescent::Rule' ),
                              'where_clause' => bless( {
                                                         'impcount' => 0,
                                                         'calls' => [
                                                                      'WHERE',
                                                                      'search_condition'
                                                                    ],
                                                         'changed' => 0,
                                                         'opcount' => 0,
                                                         'prods' => [
                                                                      bless( {
                                                                               'number' => '0',
                                                                               'strcount' => 0,
                                                                               'dircount' => 0,
                                                                               'uncommit' => undef,
                                                                               'error' => undef,
                                                                               'patcount' => 0,
                                                                               'actcount' => 0,
                                                                               'items' => [
                                                                                            bless( {
                                                                                                     'subrule' => 'WHERE',
                                                                                                     'matchrule' => 0,
                                                                                                     'implicit' => undef,
                                                                                                     'argcode' => undef,
                                                                                                     'lookahead' => 0,
                                                                                                     'line' => 218
                                                                                                   }, 'Parse::RecDescent::Subrule' ),
                                                                                            bless( {
                                                                                                     'subrule' => 'search_condition',
                                                                                                     'matchrule' => 0,
                                                                                                     'implicit' => undef,
                                                                                                     'argcode' => undef,
                                                                                                     'lookahead' => 0,
                                                                                                     'line' => 218
                                                                                                   }, 'Parse::RecDescent::Subrule' )
                                                                                          ],
                                                                               'line' => undef
                                                                             }, 'Parse::RecDescent::Production' )
                                                                    ],
                                                         'name' => 'where_clause',
                                                         'vars' => '',
                                                         'line' => 216
                                                       }, 'Parse::RecDescent::Rule' ),
                              'group_start' => bless( {
                                                        'impcount' => 0,
                                                        'calls' => [
                                                                     'unsigned_constant'
                                                                   ],
                                                        'changed' => 0,
                                                        'opcount' => 0,
                                                        'prods' => [
                                                                     bless( {
                                                                              'number' => '0',
                                                                              'strcount' => 0,
                                                                              'dircount' => 0,
                                                                              'uncommit' => undef,
                                                                              'error' => undef,
                                                                              'patcount' => 1,
                                                                              'actcount' => 0,
                                                                              'items' => [
                                                                                           bless( {
                                                                                                    'pattern' => 'UNBOUNDED\\s+PRECEDING',
                                                                                                    'hashname' => '__PATTERN1__',
                                                                                                    'description' => '/UNBOUNDED\\\\s+PRECEDING/i',
                                                                                                    'lookahead' => 0,
                                                                                                    'rdelim' => '/',
                                                                                                    'line' => 574,
                                                                                                    'mod' => 'i',
                                                                                                    'ldelim' => '/'
                                                                                                  }, 'Parse::RecDescent::Token' )
                                                                                         ],
                                                                              'line' => undef
                                                                            }, 'Parse::RecDescent::Production' ),
                                                                     bless( {
                                                                              'number' => '1',
                                                                              'strcount' => 0,
                                                                              'dircount' => 0,
                                                                              'uncommit' => undef,
                                                                              'error' => undef,
                                                                              'patcount' => 1,
                                                                              'actcount' => 0,
                                                                              'items' => [
                                                                                           bless( {
                                                                                                    'subrule' => 'unsigned_constant',
                                                                                                    'matchrule' => 0,
                                                                                                    'implicit' => undef,
                                                                                                    'argcode' => undef,
                                                                                                    'lookahead' => 0,
                                                                                                    'line' => 575
                                                                                                  }, 'Parse::RecDescent::Subrule' ),
                                                                                           bless( {
                                                                                                    'pattern' => 'PRECEDING',
                                                                                                    'hashname' => '__PATTERN1__',
                                                                                                    'description' => '/PRECEDING/i',
                                                                                                    'lookahead' => 0,
                                                                                                    'rdelim' => '/',
                                                                                                    'line' => 575,
                                                                                                    'mod' => 'i',
                                                                                                    'ldelim' => '/'
                                                                                                  }, 'Parse::RecDescent::Token' )
                                                                                         ],
                                                                              'line' => 575
                                                                            }, 'Parse::RecDescent::Production' ),
                                                                     bless( {
                                                                              'number' => '2',
                                                                              'strcount' => 0,
                                                                              'dircount' => 0,
                                                                              'uncommit' => undef,
                                                                              'error' => undef,
                                                                              'patcount' => 1,
                                                                              'actcount' => 0,
                                                                              'items' => [
                                                                                           bless( {
                                                                                                    'pattern' => 'CURRENT\\s+ROW',
                                                                                                    'hashname' => '__PATTERN1__',
                                                                                                    'description' => '/CURRENT\\\\s+ROW/i',
                                                                                                    'lookahead' => 0,
                                                                                                    'rdelim' => '/',
                                                                                                    'line' => 576,
                                                                                                    'mod' => 'i',
                                                                                                    'ldelim' => '/'
                                                                                                  }, 'Parse::RecDescent::Token' )
                                                                                         ],
                                                                              'line' => 576
                                                                            }, 'Parse::RecDescent::Production' )
                                                                   ],
                                                        'name' => 'group_start',
                                                        'vars' => '',
                                                        'line' => 574
                                                      }, 'Parse::RecDescent::Rule' ),
                              'correlation_name' => bless( {
                                                             'impcount' => 0,
                                                             'calls' => [
                                                                          'NAME'
                                                                        ],
                                                             'changed' => 0,
                                                             'opcount' => 0,
                                                             'prods' => [
                                                                          bless( {
                                                                                   'number' => '0',
                                                                                   'strcount' => 0,
                                                                                   'dircount' => 0,
                                                                                   'uncommit' => undef,
                                                                                   'error' => undef,
                                                                                   'patcount' => 0,
                                                                                   'actcount' => 0,
                                                                                   'items' => [
                                                                                                bless( {
                                                                                                         'subrule' => 'NAME',
                                                                                                         'matchrule' => 0,
                                                                                                         'implicit' => undef,
                                                                                                         'argcode' => undef,
                                                                                                         'lookahead' => 0,
                                                                                                         'line' => 138
                                                                                                       }, 'Parse::RecDescent::Subrule' )
                                                                                              ],
                                                                                   'line' => undef
                                                                                 }, 'Parse::RecDescent::Production' )
                                                                        ],
                                                             'name' => 'correlation_name',
                                                             'vars' => '',
                                                             'line' => 138
                                                           }, 'Parse::RecDescent::Rule' ),
                              'SQL_procedure_statement' => bless( {
                                                                    'impcount' => 0,
                                                                    'calls' => [],
                                                                    'changed' => 0,
                                                                    'opcount' => 0,
                                                                    'prods' => [
                                                                                 bless( {
                                                                                          'number' => '0',
                                                                                          'strcount' => 0,
                                                                                          'dircount' => 0,
                                                                                          'uncommit' => undef,
                                                                                          'error' => undef,
                                                                                          'patcount' => 2,
                                                                                          'actcount' => 1,
                                                                                          'items' => [
                                                                                                       bless( {
                                                                                                                'pattern' => '[^;]*',
                                                                                                                'hashname' => '__PATTERN1__',
                                                                                                                'description' => '/[^;]*/',
                                                                                                                'lookahead' => 0,
                                                                                                                'rdelim' => '/',
                                                                                                                'line' => 94,
                                                                                                                'mod' => '',
                                                                                                                'ldelim' => '/'
                                                                                                              }, 'Parse::RecDescent::Token' ),
                                                                                                       bless( {
                                                                                                                'pattern' => '(;|\\z)',
                                                                                                                'hashname' => '__PATTERN2__',
                                                                                                                'description' => '/(;|\\\\z)/',
                                                                                                                'lookahead' => 0,
                                                                                                                'rdelim' => '/',
                                                                                                                'line' => 94,
                                                                                                                'mod' => '',
                                                                                                                'ldelim' => '/'
                                                                                                              }, 'Parse::RecDescent::Token' ),
                                                                                                       bless( {
                                                                                                                'hashname' => '__ACTION1__',
                                                                                                                'lookahead' => 0,
                                                                                                                'line' => 94,
                                                                                                                'code' => '{ $return = $item[1] . $item[2] }'
                                                                                                              }, 'Parse::RecDescent::Action' )
                                                                                                     ],
                                                                                          'line' => undef
                                                                                        }, 'Parse::RecDescent::Production' )
                                                                               ],
                                                                    'name' => 'SQL_procedure_statement',
                                                                    'vars' => '',
                                                                    'line' => 94
                                                                  }, 'Parse::RecDescent::Rule' ),
                              'group_between' => bless( {
                                                          'impcount' => 0,
                                                          'calls' => [
                                                                       'group_bound1',
                                                                       'group_bound2'
                                                                     ],
                                                          'changed' => 0,
                                                          'opcount' => 0,
                                                          'prods' => [
                                                                       bless( {
                                                                                'number' => '0',
                                                                                'strcount' => 0,
                                                                                'dircount' => 0,
                                                                                'uncommit' => undef,
                                                                                'error' => undef,
                                                                                'patcount' => 2,
                                                                                'actcount' => 0,
                                                                                'items' => [
                                                                                             bless( {
                                                                                                      'pattern' => 'BETWEEN',
                                                                                                      'hashname' => '__PATTERN1__',
                                                                                                      'description' => '/BETWEEN/i',
                                                                                                      'lookahead' => 0,
                                                                                                      'rdelim' => '/',
                                                                                                      'line' => 578,
                                                                                                      'mod' => 'i',
                                                                                                      'ldelim' => '/'
                                                                                                    }, 'Parse::RecDescent::Token' ),
                                                                                             bless( {
                                                                                                      'subrule' => 'group_bound1',
                                                                                                      'matchrule' => 0,
                                                                                                      'implicit' => undef,
                                                                                                      'argcode' => undef,
                                                                                                      'lookahead' => 0,
                                                                                                      'line' => 578
                                                                                                    }, 'Parse::RecDescent::Subrule' ),
                                                                                             bless( {
                                                                                                      'pattern' => 'AND',
                                                                                                      'hashname' => '__PATTERN2__',
                                                                                                      'description' => '/AND/i',
                                                                                                      'lookahead' => 0,
                                                                                                      'rdelim' => '/',
                                                                                                      'line' => 578,
                                                                                                      'mod' => 'i',
                                                                                                      'ldelim' => '/'
                                                                                                    }, 'Parse::RecDescent::Token' ),
                                                                                             bless( {
                                                                                                      'subrule' => 'group_bound2',
                                                                                                      'matchrule' => 0,
                                                                                                      'implicit' => undef,
                                                                                                      'argcode' => undef,
                                                                                                      'lookahead' => 0,
                                                                                                      'line' => 578
                                                                                                    }, 'Parse::RecDescent::Subrule' )
                                                                                           ],
                                                                                'line' => undef
                                                                              }, 'Parse::RecDescent::Production' )
                                                                     ],
                                                          'name' => 'group_between',
                                                          'vars' => '',
                                                          'line' => 578
                                                        }, 'Parse::RecDescent::Rule' ),
                              'nextval_expression' => bless( {
                                                               'impcount' => 0,
                                                               'calls' => [
                                                                            'sequence_name'
                                                                          ],
                                                               'changed' => 0,
                                                               'opcount' => 0,
                                                               'prods' => [
                                                                            bless( {
                                                                                     'number' => '0',
                                                                                     'strcount' => 0,
                                                                                     'dircount' => 0,
                                                                                     'uncommit' => undef,
                                                                                     'error' => undef,
                                                                                     'patcount' => 1,
                                                                                     'actcount' => 0,
                                                                                     'items' => [
                                                                                                  bless( {
                                                                                                           'pattern' => 'NEXTVAL\\s+FOR',
                                                                                                           'hashname' => '__PATTERN1__',
                                                                                                           'description' => '/NEXTVAL\\\\s+FOR/i',
                                                                                                           'lookahead' => 0,
                                                                                                           'rdelim' => '/',
                                                                                                           'line' => 611,
                                                                                                           'mod' => 'i',
                                                                                                           'ldelim' => '/'
                                                                                                         }, 'Parse::RecDescent::Token' ),
                                                                                                  bless( {
                                                                                                           'subrule' => 'sequence_name',
                                                                                                           'matchrule' => 0,
                                                                                                           'implicit' => undef,
                                                                                                           'argcode' => undef,
                                                                                                           'lookahead' => 0,
                                                                                                           'line' => 611
                                                                                                         }, 'Parse::RecDescent::Subrule' )
                                                                                                ],
                                                                                     'line' => undef
                                                                                   }, 'Parse::RecDescent::Production' )
                                                                          ],
                                                               'name' => 'nextval_expression',
                                                               'vars' => '',
                                                               'line' => 611
                                                             }, 'Parse::RecDescent::Rule' ),
                              'desc_option' => bless( {
                                                        'impcount' => 1,
                                                        'calls' => [
                                                                     '_alternation_1_of_production_1_of_rule_desc_option'
                                                                   ],
                                                        'changed' => 0,
                                                        'opcount' => 0,
                                                        'prods' => [
                                                                     bless( {
                                                                              'number' => '0',
                                                                              'strcount' => 0,
                                                                              'dircount' => 0,
                                                                              'uncommit' => undef,
                                                                              'error' => undef,
                                                                              'patcount' => 1,
                                                                              'actcount' => 0,
                                                                              'items' => [
                                                                                           bless( {
                                                                                                    'pattern' => 'DESC',
                                                                                                    'hashname' => '__PATTERN1__',
                                                                                                    'description' => '/DESC/i',
                                                                                                    'lookahead' => 0,
                                                                                                    'rdelim' => '/',
                                                                                                    'line' => 564,
                                                                                                    'mod' => 'i',
                                                                                                    'ldelim' => '/'
                                                                                                  }, 'Parse::RecDescent::Token' ),
                                                                                           bless( {
                                                                                                    'subrule' => '_alternation_1_of_production_1_of_rule_desc_option',
                                                                                                    'expected' => '/NULLS\\\\s+FIRST/i, or /NULLS\\\\s+LAST/i',
                                                                                                    'min' => 0,
                                                                                                    'argcode' => undef,
                                                                                                    'max' => 1,
                                                                                                    'matchrule' => 0,
                                                                                                    'repspec' => '?',
                                                                                                    'lookahead' => 0,
                                                                                                    'line' => 564
                                                                                                  }, 'Parse::RecDescent::Repetition' )
                                                                                         ],
                                                                              'line' => undef
                                                                            }, 'Parse::RecDescent::Production' )
                                                                   ],
                                                        'name' => 'desc_option',
                                                        'vars' => '',
                                                        'line' => 564
                                                      }, 'Parse::RecDescent::Rule' ),
                              'column_list' => bless( {
                                                        'impcount' => 0,
                                                        'calls' => [
                                                                     'column_name'
                                                                   ],
                                                        'changed' => 0,
                                                        'opcount' => 0,
                                                        'prods' => [
                                                                     bless( {
                                                                              'number' => '0',
                                                                              'strcount' => 2,
                                                                              'dircount' => 1,
                                                                              'uncommit' => undef,
                                                                              'error' => undef,
                                                                              'patcount' => 1,
                                                                              'actcount' => 1,
                                                                              'op' => [],
                                                                              'items' => [
                                                                                           bless( {
                                                                                                    'pattern' => '(',
                                                                                                    'hashname' => '__STRING1__',
                                                                                                    'description' => '\'(\'',
                                                                                                    'lookahead' => 0,
                                                                                                    'line' => 96
                                                                                                  }, 'Parse::RecDescent::Literal' ),
                                                                                           bless( {
                                                                                                    'expected' => '<leftop: column_name /,/ column_name>',
                                                                                                    'min' => 1,
                                                                                                    'name' => '\'column_name(s)\'',
                                                                                                    'max' => 100000000,
                                                                                                    'leftarg' => bless( {
                                                                                                                          'subrule' => 'column_name',
                                                                                                                          'matchrule' => 0,
                                                                                                                          'implicit' => undef,
                                                                                                                          'argcode' => undef,
                                                                                                                          'lookahead' => 0,
                                                                                                                          'line' => 96
                                                                                                                        }, 'Parse::RecDescent::Subrule' ),
                                                                                                    'rightarg' => bless( {
                                                                                                                           'subrule' => 'column_name',
                                                                                                                           'matchrule' => 0,
                                                                                                                           'implicit' => undef,
                                                                                                                           'argcode' => undef,
                                                                                                                           'lookahead' => 0,
                                                                                                                           'line' => 96
                                                                                                                         }, 'Parse::RecDescent::Subrule' ),
                                                                                                    'hashname' => '__DIRECTIVE1__',
                                                                                                    'type' => 'leftop',
                                                                                                    'op' => bless( {
                                                                                                                     'pattern' => ',',
                                                                                                                     'hashname' => '__PATTERN1__',
                                                                                                                     'description' => '/,/',
                                                                                                                     'lookahead' => 0,
                                                                                                                     'rdelim' => '/',
                                                                                                                     'line' => 96,
                                                                                                                     'mod' => '',
                                                                                                                     'ldelim' => '/'
                                                                                                                   }, 'Parse::RecDescent::Token' )
                                                                                                  }, 'Parse::RecDescent::Operator' ),
                                                                                           bless( {
                                                                                                    'pattern' => ')',
                                                                                                    'hashname' => '__STRING2__',
                                                                                                    'description' => '\')\'',
                                                                                                    'lookahead' => 0,
                                                                                                    'line' => 96
                                                                                                  }, 'Parse::RecDescent::Literal' ),
                                                                                           bless( {
                                                                                                    'hashname' => '__ACTION1__',
                                                                                                    'lookahead' => 0,
                                                                                                    'line' => 97,
                                                                                                    'code' => '{
    $return = join(\' \', \'(\', @{$item[2]}, \')\');
}'
                                                                                                  }, 'Parse::RecDescent::Action' )
                                                                                         ],
                                                                              'line' => undef
                                                                            }, 'Parse::RecDescent::Production' )
                                                                   ],
                                                        'name' => 'column_list',
                                                        'vars' => '',
                                                        'line' => 96
                                                      }, 'Parse::RecDescent::Rule' ),
                              '_alternation_1_of_production_63_of_rule_sysibm_function' => bless( {
                                                                                                    'impcount' => 0,
                                                                                                    'calls' => [],
                                                                                                    'changed' => 0,
                                                                                                    'opcount' => 0,
                                                                                                    'prods' => [
                                                                                                                 bless( {
                                                                                                                          'number' => '0',
                                                                                                                          'strcount' => 0,
                                                                                                                          'dircount' => 0,
                                                                                                                          'uncommit' => undef,
                                                                                                                          'error' => undef,
                                                                                                                          'patcount' => 1,
                                                                                                                          'actcount' => 0,
                                                                                                                          'items' => [
                                                                                                                                       bless( {
                                                                                                                                                'pattern' => 'REGR_INTERCEPT',
                                                                                                                                                'hashname' => '__PATTERN1__',
                                                                                                                                                'description' => '/REGR_INTERCEPT/i',
                                                                                                                                                'lookahead' => 0,
                                                                                                                                                'rdelim' => '/',
                                                                                                                                                'line' => 628,
                                                                                                                                                'mod' => 'i',
                                                                                                                                                'ldelim' => '/'
                                                                                                                                              }, 'Parse::RecDescent::Token' )
                                                                                                                                     ],
                                                                                                                          'line' => undef
                                                                                                                        }, 'Parse::RecDescent::Production' ),
                                                                                                                 bless( {
                                                                                                                          'number' => '1',
                                                                                                                          'strcount' => 0,
                                                                                                                          'dircount' => 0,
                                                                                                                          'uncommit' => undef,
                                                                                                                          'error' => undef,
                                                                                                                          'patcount' => 1,
                                                                                                                          'actcount' => 0,
                                                                                                                          'items' => [
                                                                                                                                       bless( {
                                                                                                                                                'pattern' => 'REGR_ICPT',
                                                                                                                                                'hashname' => '__PATTERN1__',
                                                                                                                                                'description' => '/REGR_ICPT/i',
                                                                                                                                                'lookahead' => 0,
                                                                                                                                                'rdelim' => '/',
                                                                                                                                                'line' => 628,
                                                                                                                                                'mod' => 'i',
                                                                                                                                                'ldelim' => '/'
                                                                                                                                              }, 'Parse::RecDescent::Token' )
                                                                                                                                     ],
                                                                                                                          'line' => 628
                                                                                                                        }, 'Parse::RecDescent::Production' )
                                                                                                               ],
                                                                                                    'name' => '_alternation_1_of_production_63_of_rule_sysibm_function',
                                                                                                    'vars' => '',
                                                                                                    'line' => 628
                                                                                                  }, 'Parse::RecDescent::Rule' ),
                              'dereference_operation' => bless( {
                                                                  'impcount' => 1,
                                                                  'calls' => [
                                                                               'scoped_reference_expression',
                                                                               'name1',
                                                                               '_alternation_1_of_production_1_of_rule_dereference_operation'
                                                                             ],
                                                                  'changed' => 0,
                                                                  'opcount' => 0,
                                                                  'prods' => [
                                                                               bless( {
                                                                                        'number' => '0',
                                                                                        'strcount' => 1,
                                                                                        'dircount' => 0,
                                                                                        'uncommit' => undef,
                                                                                        'error' => undef,
                                                                                        'patcount' => 0,
                                                                                        'actcount' => 0,
                                                                                        'items' => [
                                                                                                     bless( {
                                                                                                              'subrule' => 'scoped_reference_expression',
                                                                                                              'matchrule' => 0,
                                                                                                              'implicit' => undef,
                                                                                                              'argcode' => undef,
                                                                                                              'lookahead' => 0,
                                                                                                              'line' => 526
                                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                                     bless( {
                                                                                                              'pattern' => '->',
                                                                                                              'hashname' => '__STRING1__',
                                                                                                              'description' => '\'->\'',
                                                                                                              'lookahead' => 0,
                                                                                                              'line' => 526
                                                                                                            }, 'Parse::RecDescent::Literal' ),
                                                                                                     bless( {
                                                                                                              'subrule' => 'name1',
                                                                                                              'matchrule' => 0,
                                                                                                              'implicit' => undef,
                                                                                                              'argcode' => undef,
                                                                                                              'lookahead' => 0,
                                                                                                              'line' => 526
                                                                                                            }, 'Parse::RecDescent::Subrule' ),
                                                                                                     bless( {
                                                                                                              'subrule' => '_alternation_1_of_production_1_of_rule_dereference_operation',
                                                                                                              'expected' => '\'(\'',
                                                                                                              'min' => 0,
                                                                                                              'argcode' => undef,
                                                                                                              'max' => 1,
                                                                                                              'matchrule' => 0,
                                                                                                              'repspec' => '?',
                                                                                                              'lookahead' => 0,
                                                                                                              'line' => 527
                                                                                                            }, 'Parse::RecDescent::Repetition' )
                                                                                                   ],
                                                                                        'line' => undef
                                                                                      }, 'Parse::RecDescent::Production' )
                                                                             ],
                                                                  'name' => 'dereference_operation',
                                                                  'vars' => '',
                                                                  'line' => 526
                                                                }, 'Parse::RecDescent::Rule' ),
                              'OUTER' => bless( {
                                                  'impcount' => 0,
                                                  'calls' => [],
                                                  'changed' => 0,
                                                  'opcount' => 0,
                                                  'prods' => [
                                                               bless( {
                                                                        'number' => '0',
                                                                        'strcount' => 0,
                                                                        'dircount' => 0,
                                                                        'uncommit' => undef,
                                                                        'error' => undef,
                                                                        'patcount' => 1,
                                                                        'actcount' => 0,
                                                                        'items' => [
                                                                                     bless( {
                                                                                              'pattern' => 'outer',
                                                                                              'hashname' => '__PATTERN1__',
                                                                                              'description' => '/outer/i',
                                                                                              'lookahead' => 0,
                                                                                              'rdelim' => '/',
                                                                                              'line' => 115,
                                                                                              'mod' => 'i',
                                                                                              'ldelim' => '/'
                                                                                            }, 'Parse::RecDescent::Token' )
                                                                                   ],
                                                                        'line' => undef
                                                                      }, 'Parse::RecDescent::Production' )
                                                             ],
                                                  'name' => 'OUTER',
                                                  'vars' => '',
                                                  'line' => 115
                                                }, 'Parse::RecDescent::Rule' ),
                              'window_order_clause' => bless( {
                                                                'impcount' => 1,
                                                                'calls' => [
                                                                             '_alternation_1_of_production_1_of_rule_window_order_clause'
                                                                           ],
                                                                'changed' => 0,
                                                                'opcount' => 0,
                                                                'prods' => [
                                                                             bless( {
                                                                                      'number' => '0',
                                                                                      'strcount' => 0,
                                                                                      'dircount' => 1,
                                                                                      'uncommit' => undef,
                                                                                      'error' => undef,
                                                                                      'patcount' => 2,
                                                                                      'actcount' => 0,
                                                                                      'op' => [],
                                                                                      'items' => [
                                                                                                   bless( {
                                                                                                            'pattern' => 'ORDER\\s+BY',
                                                                                                            'hashname' => '__PATTERN1__',
                                                                                                            'description' => '/ORDER\\\\s+BY/i',
                                                                                                            'lookahead' => 0,
                                                                                                            'rdelim' => '/',
                                                                                                            'line' => 555,
                                                                                                            'mod' => 'i',
                                                                                                            'ldelim' => '/'
                                                                                                          }, 'Parse::RecDescent::Token' ),
                                                                                                   bless( {
                                                                                                            'expected' => '<leftop: sort_key_expression /,/ sort_key_expression>',
                                                                                                            'min' => 1,
                                                                                                            'name' => '\'_alternation_1_of_production_1_of_rule_window_order_clause(s)\'',
                                                                                                            'max' => 100000000,
                                                                                                            'leftarg' => bless( {
                                                                                                                                  'subrule' => '_alternation_1_of_production_1_of_rule_window_order_clause',
                                                                                                                                  'matchrule' => 0,
                                                                                                                                  'implicit' => 'sort_key_expression',
                                                                                                                                  'argcode' => undef,
                                                                                                                                  'lookahead' => 0,
                                                                                                                                  'line' => 560
                                                                                                                                }, 'Parse::RecDescent::Subrule' ),
                                                                                                            'rightarg' => bless( {
                                                                                                                                   'subrule' => '_alternation_1_of_production_1_of_rule_window_order_clause',
                                                                                                                                   'matchrule' => 0,
                                                                                                                                   'implicit' => 'sort_key_expression',
                                                                                                                                   'argcode' => undef,
                                                                                                                                   'lookahead' => 0,
                                                                                                                                   'line' => 560
                                                                                                                                 }, 'Parse::RecDescent::Subrule' ),
                                                                                                            'hashname' => '__DIRECTIVE1__',
                                                                                                            'type' => 'leftop',
                                                                                                            'op' => bless( {
                                                                                                                             'pattern' => ',',
                                                                                                                             'hashname' => '__PATTERN2__',
                                                                                                                             'description' => '/,/',
                                                                                                                             'lookahead' => 0,
                                                                                                                             'rdelim' => '/',
                                                                                                                             'line' => 560,
                                                                                                                             'mod' => '',
                                                                                                                             'ldelim' => '/'
                                                                                                                           }, 'Parse::RecDescent::Token' )
                                                                                                          }, 'Parse::RecDescent::Operator' )
                                                                                                 ],
                                                                                      'line' => undef
                                                                                    }, 'Parse::RecDescent::Production' )
                                                                           ],
                                                                'name' => 'window_order_clause',
                                                                'vars' => '',
                                                                'line' => 555
                                                              }, 'Parse::RecDescent::Rule' ),
                              'TRIGGER' => bless( {
                                                    'impcount' => 0,
                                                    'calls' => [],
                                                    'changed' => 0,
                                                    'opcount' => 0,
                                                    'prods' => [
                                                                 bless( {
                                                                          'number' => '0',
                                                                          'strcount' => 0,
                                                                          'dircount' => 0,
                                                                          'uncommit' => undef,
                                                                          'error' => undef,
                                                                          'patcount' => 1,
                                                                          'actcount' => 0,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'pattern' => 'trigger',
                                                                                                'hashname' => '__PATTERN1__',
                                                                                                'description' => '/trigger/i',
                                                                                                'lookahead' => 0,
                                                                                                'rdelim' => '/',
                                                                                                'line' => 103,
                                                                                                'mod' => 'i',
                                                                                                'ldelim' => '/'
                                                                                              }, 'Parse::RecDescent::Token' )
                                                                                     ],
                                                                          'line' => undef
                                                                        }, 'Parse::RecDescent::Production' )
                                                               ],
                                                    'name' => 'TRIGGER',
                                                    'vars' => '',
                                                    'line' => 103
                                                  }, 'Parse::RecDescent::Rule' ),
                              'comment' => bless( {
                                                    'impcount' => 0,
                                                    'calls' => [],
                                                    'changed' => 0,
                                                    'opcount' => 0,
                                                    'prods' => [
                                                                 bless( {
                                                                          'number' => '0',
                                                                          'strcount' => 0,
                                                                          'dircount' => 0,
                                                                          'uncommit' => undef,
                                                                          'error' => undef,
                                                                          'patcount' => 1,
                                                                          'actcount' => 1,
                                                                          'items' => [
                                                                                       bless( {
                                                                                                'pattern' => '^\\s*-{2}.*\\n',
                                                                                                'hashname' => '__PATTERN1__',
                                                                                                'description' => '/^\\\\s*-\\{2\\}.*\\\\n/',
                                                                                                'lookahead' => 0,
                                                                                                'rdelim' => '/',
                                                                                                'line' => 27,
                                                                                                'mod' => '',
                                                                                                'ldelim' => '/'
                                                                                              }, 'Parse::RecDescent::Token' ),
                                                                                       bless( {
                                                                                                'hashname' => '__ACTION1__',
                                                                                                'lookahead' => 0,
                                                                                                'line' => 28,
                                                                                                'code' => '{
        my $comment =  $item[1];
        $comment    =~ s/^\\s*(-{2})\\s*//;
        $comment    =~ s/\\s*$//;
        $return     = $comment;
    }'
                                                                                              }, 'Parse::RecDescent::Action' )
                                                                                     ],
                                                                          'line' => undef
                                                                        }, 'Parse::RecDescent::Production' )
                                                               ],
                                                    'name' => 'comment',
                                                    'vars' => '',
                                                    'line' => 27
                                                  }, 'Parse::RecDescent::Rule' )
                            }
               }, 'Parse::RecDescent' );
}
